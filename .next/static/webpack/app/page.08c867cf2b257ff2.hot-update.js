"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/utilities.ts":
/*!********************************!*\
  !*** ./src/utils/utilities.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CABINET_SIZE_CONSTRAINTS: function() { return /* binding */ CABINET_SIZE_CONSTRAINTS; },\n/* harmony export */   CELL_SIZE: function() { return /* binding */ CELL_SIZE; },\n/* harmony export */   ECabinetFinishes: function() { return /* binding */ ECabinetFinishes; },\n/* harmony export */   ECabinetHandles: function() { return /* binding */ ECabinetHandles; },\n/* harmony export */   ECabinetLegs: function() { return /* binding */ ECabinetLegs; },\n/* harmony export */   ECabinetStyle: function() { return /* binding */ ECabinetStyle; },\n/* harmony export */   EDGE_GAP: function() { return /* binding */ EDGE_GAP; },\n/* harmony export */   EOcclusionImages: function() { return /* binding */ EOcclusionImages; },\n/* harmony export */   EPlywoodTextures: function() { return /* binding */ EPlywoodTextures; },\n/* harmony export */   EVeneerTextures: function() { return /* binding */ EVeneerTextures; },\n/* harmony export */   LEG_DEPTH: function() { return /* binding */ LEG_DEPTH; },\n/* harmony export */   LEG_HEIGHT: function() { return /* binding */ LEG_HEIGHT; },\n/* harmony export */   LEG_WIDTH: function() { return /* binding */ LEG_WIDTH; },\n/* harmony export */   PLATE_THICKNESS: function() { return /* binding */ PLATE_THICKNESS; },\n/* harmony export */   ambientLightColor: function() { return /* binding */ ambientLightColor; },\n/* harmony export */   applyRandomLayoutsToColumns: function() { return /* binding */ applyRandomLayoutsToColumns; },\n/* harmony export */   backOcclusionTexturePath: function() { return /* binding */ backOcclusionTexturePath; },\n/* harmony export */   createColumnWithLayout: function() { return /* binding */ createColumnWithLayout; },\n/* harmony export */   directionalLightColor: function() { return /* binding */ directionalLightColor; },\n/* harmony export */   environmentPath: function() { return /* binding */ environmentPath; },\n/* harmony export */   floorColor: function() { return /* binding */ floorColor; },\n/* harmony export */   getBottomHeight: function() { return /* binding */ getBottomHeight; },\n/* harmony export */   getCalculatedColumns: function() { return /* binding */ getCalculatedColumns; },\n/* harmony export */   getCellHeight: function() { return /* binding */ getCellHeight; },\n/* harmony export */   getCellWidth: function() { return /* binding */ getCellWidth; },\n/* harmony export */   getColumnCount: function() { return /* binding */ getColumnCount; },\n/* harmony export */   getColumnVerticalLayout: function() { return /* binding */ getColumnVerticalLayout; },\n/* harmony export */   getDistance: function() { return /* binding */ getDistance; },\n/* harmony export */   getId: function() { return /* binding */ getId; },\n/* harmony export */   getIndividualColumn: function() { return /* binding */ getIndividualColumn; },\n/* harmony export */   getLayoutImages: function() { return /* binding */ getLayoutImages; },\n/* harmony export */   getPartitonPlates: function() { return /* binding */ getPartitonPlates; },\n/* harmony export */   getRemainingColumns: function() { return /* binding */ getRemainingColumns; },\n/* harmony export */   getRowCount: function() { return /* binding */ getRowCount; },\n/* harmony export */   getWidthArray: function() { return /* binding */ getWidthArray; },\n/* harmony export */   handleAModelPath: function() { return /* binding */ handleAModelPath; },\n/* harmony export */   handleBModelPath: function() { return /* binding */ handleBModelPath; },\n/* harmony export */   horizontalOcclusionTexturePath: function() { return /* binding */ horizontalOcclusionTexturePath; },\n/* harmony export */   iconifyIcons: function() { return /* binding */ iconifyIcons; },\n/* harmony export */   legsModelPath: function() { return /* binding */ legsModelPath; },\n/* harmony export */   menuIconPaths: function() { return /* binding */ menuIconPaths; },\n/* harmony export */   noLegsModelPath: function() { return /* binding */ noLegsModelPath; },\n/* harmony export */   plywoodTextures: function() { return /* binding */ plywoodTextures; },\n/* harmony export */   shadowManModelPath: function() { return /* binding */ shadowManModelPath; },\n/* harmony export */   tvModelPath: function() { return /* binding */ tvModelPath; },\n/* harmony export */   veneerTextures: function() { return /* binding */ veneerTextures; },\n/* harmony export */   verticalOcclusionTexturePath: function() { return /* binding */ verticalOcclusionTexturePath; },\n/* harmony export */   wallColor: function() { return /* binding */ wallColor; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./columnLayoutOptions */ \"(app-pages-browser)/./src/utils/columnLayoutOptions.ts\");\n\n\n//--- CONSTANTS\n// Dimensions\nconst PLATE_THICKNESS = 0.02;\nconst CELL_SIZE = {\n    maxWidth: 0.60,\n    minWidth: 0.25,\n    maxHeight: 0.35,\n    minHeight: 0.15\n};\nconst LEG_HEIGHT = 0.18;\nconst LEG_WIDTH = 0.05;\nconst LEG_DEPTH = 0.05;\nconst EDGE_GAP = 0.006;\n// Colors\nconst wallColor = \"#e7e7e7\";\nconst floorColor = \"#b7b7b7\";\nconst ambientLightColor = \"#f0f0f0\";\nconst directionalLightColor = \"#f0f0f0\";\n// Texture paths\nconst texturesRootPath = \"/assets/textures/\";\nconst environmentPath = texturesRootPath + \"environment.hdr\";\nconst plywoodRootPath = texturesRootPath + \"plywood_1k/textures/\";\nconst plywoodAoMapPath = plywoodRootPath + \"plywood_ao_1k.jpg\";\nconst plywoodNormalMapPath = plywoodRootPath + \"plywood_nor_gl_1k.jpg\";\nconst plywoodRoughnessMapPath = plywoodRootPath + \"plywood_rough_1k.jpg\";\nconst plywoodTextures = {\n    aoMap: plywoodAoMapPath,\n    normalMap: plywoodNormalMapPath,\n    roughnessMap: plywoodRoughnessMapPath\n};\n// Base Textures Veener\nconst woodRootPath = texturesRootPath + \"wood_27/\";\nconst veneerAoMapPath = woodRootPath + \"ambient-occlusion.jpg\";\nconst veneerNormalMapPath = woodRootPath + \"normal.jpg\";\nconst veneerRoughnessMapPath = woodRootPath + \"roughness.jpg\";\nconst veneerTextures = {\n    aoMap: veneerAoMapPath,\n    normalMap: veneerNormalMapPath,\n    roughnessMap: veneerRoughnessMapPath\n};\nvar EVeneerTextures;\n(function(EVeneerTextures) {\n    EVeneerTextures[EVeneerTextures[\"BEIGE_GREY_LORENZO_OAK\"] = texturesRootPath + \"veneer-oak-wood/beige_grey_lorenzo_oak.jpg\"] = \"BEIGE_GREY_LORENZO_OAK\";\n    // BEIGE_TEXTILE = texturesRootPath + 'veneer-oak-wood/beige_textile.jpg',\n    EVeneerTextures[EVeneerTextures[\"BROWN_ABANO_ASH\"] = texturesRootPath + \"veneer-oak-wood/brown_abano_ash.jpg\"] = \"BROWN_ABANO_ASH\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_HALIFAX_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_halifax_oak.jpg\"] = \"BROWN_HALIFAX_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_TONNSBERG_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_tonnsberg_oak.jpg\"] = \"BROWN_TONNSBERG_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_WARMIA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/brown_warmia_wallnut.jpg\"] = \"BROWN_WARMIA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_BARONIA_OAK\"] = texturesRootPath + \"veneer-oak-wood/light_baronia_oak.jpg\"] = \"LIGHT_BARONIA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_NATURAL_DAVENPORT_OAK\"] = texturesRootPath + \"veneer-oak-wood/Light_Natural_Davenport_oak.jpg\"] = \"LIGHT_NATURAL_DAVENPORT_OAK\";\n    EVeneerTextures[EVeneerTextures[\"NATURAL_CASELLA_OAK\"] = texturesRootPath + \"veneer-oak-wood/natural_casella_oak.jpg\"] = \"NATURAL_CASELLA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"PARONA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/parona_wallnut.jpg\"] = \"PARONA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"SEVILLA_ASH\"] = texturesRootPath + \"veneer-oak-wood/sevilla_ash.jpg\"] = \"SEVILLA_ASH\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak.jpg\"] = \"VICENZA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK_2\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak2.jpg\"] = \"VICENZA_OAK_2\";\n})(EVeneerTextures || (EVeneerTextures = {}));\nvar EPlywoodTextures;\n(function(EPlywoodTextures) {\n    EPlywoodTextures[EPlywoodTextures[\"BRONZE_BRUSHED_METAL\"] = texturesRootPath + \"plywood-colors/bronze_brushed_metal.jpg\"] = \"BRONZE_BRUSHED_METAL\";\n    EPlywoodTextures[EPlywoodTextures[\"ALMOND_BEIGE\"] = texturesRootPath + \"plywood-colors/almond_beige.jpg\"] = \"ALMOND_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CARAT_BEIGE\"] = texturesRootPath + \"plywood-colors/carat_beige.jpg\"] = \"CARAT_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CASHMERE_GREY\"] = texturesRootPath + \"plywood-colors/cashmere_grey.jpg\"] = \"CASHMERE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"CORA_BRONZE\"] = texturesRootPath + \"plywood-colors/cobra_bronze.jpg\"] = \"CORA_BRONZE\";\n    EPlywoodTextures[EPlywoodTextures[\"CUBANITE_GREY\"] = texturesRootPath + \"plywood-colors/cubanite_grey.jpg\"] = \"CUBANITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"FIR_GREEN\"] = texturesRootPath + \"plywood-colors/fir_green.jpg\"] = \"FIR_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"FJORD_GREEN\"] = texturesRootPath + \"plywood-colors/fjord_green.jpg\"] = \"FJORD_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"GRAPHITE_GREY\"] = texturesRootPath + \"plywood-colors/graphite_grey.jpg\"] = \"GRAPHITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"INDIGO_BLUE\"] = texturesRootPath + \"plywood-colors/indigo_blue.jpg\"] = \"INDIGO_BLUE\";\n    EPlywoodTextures[EPlywoodTextures[\"REED_GREEN\"] = texturesRootPath + \"plywood-colors/reed_green.jpg\"] = \"REED_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"SAGE_GREEN\"] = texturesRootPath + \"plywood-colors/sage_green.jpg\"] = \"SAGE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"STONE_GREEN\"] = texturesRootPath + \"plywood-colors/stone_green.jpg\"] = \"STONE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"TAUPE_GREY\"] = texturesRootPath + \"plywood-colors/taupe_grey.jpg\"] = \"TAUPE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"TRUFFLE_BROWN\"] = texturesRootPath + \"plywood-colors/truffle_brown.jpg\"] = \"TRUFFLE_BROWN\";\n    EPlywoodTextures[EPlywoodTextures[\"U999_PM_BLACK\"] = texturesRootPath + \"plywood-colors/U999_PM_Black.jpg\"] = \"U999_PM_BLACK\";\n})(EPlywoodTextures || (EPlywoodTextures = {}));\n// Occlusion Textures\nconst horizontalOcclusionTexturePath = texturesRootPath + \"horizontal-panel.jpg\";\nconst verticalOcclusionTexturePath = texturesRootPath + \"vertical-panel.jpg\";\nconst backOcclusionTexturePath = texturesRootPath + \"back-panel.jpg\";\nvar EOcclusionImages;\n(function(EOcclusionImages) {\n    EOcclusionImages[EOcclusionImages[\"HORIZONTAL\"] = horizontalOcclusionTexturePath] = \"HORIZONTAL\";\n    EOcclusionImages[EOcclusionImages[\"BACK\"] = verticalOcclusionTexturePath] = \"BACK\";\n    EOcclusionImages[EOcclusionImages[\"VERTICAL\"] = backOcclusionTexturePath] = \"VERTICAL\";\n})(EOcclusionImages || (EOcclusionImages = {}));\n// Layout Icons\nconst layoutIconRootPath = \"/assets/icons/on-model-editor/\";\nconst iconifyIcons = {\n    layoutIcons: {\n        undoIcon: \"solar:undo-left-round-outline\",\n        dimensionsIcon: \"solar:ruler-linear\",\n        doorsIcon: \"fluent:door-20-regular\",\n        alignColumnsIcon: \"flowbite:grid-plus-outline\",\n        showDecorationsIcon: \"hugeicons:paint-brush-02\",\n        assemblyIcon: \"carbon:3d-cursor\"\n    },\n    menuIcons: {\n        arrowUp: \"iwwa:arrow-up\",\n        arrowDown: \"iwwa:arrow-down\",\n        infoQuestion: \"ph:question-bold\"\n    },\n    sceneIcons: {\n        editLayout: \"ic-outline-create\"\n    }\n};\nconst menuIconPaths = {\n    legs: {\n        no_leg: \"/assets/icons/menu-icons/legs/no_leg.svg\",\n        legs: \"/assets/icons/menu-icons/legs/legs.svg\",\n        floating: \"/assets/icons/menu-icons/legs/floating.svg\"\n    },\n    handles: {\n        handle_a: \"/assets/icons/menu-icons/handles/handle_A.svg\",\n        handle_b: \"/assets/icons/menu-icons/handles/handle_B.svg\",\n        push: \"/assets/icons/menu-icons/handles/push.svg\"\n    },\n    styles: {\n        frame: \"/assets/icons/menu-icons/styles/frame.svg\",\n        gradient: \"/assets/icons/menu-icons/styles/gradient.svg\",\n        grid: \"/assets/icons/menu-icons/styles/grid.svg\",\n        mosaic: \"/assets/icons/menu-icons/styles/mosaic.svg\",\n        pixel: \"/assets/icons/menu-icons/styles/pixel.svg\",\n        slant: \"/assets/icons/menu-icons/styles/slant.svg\"\n    }\n};\nconst generateLayoutIcons = (layoutHeight, iconCount)=>{\n    const layoutRootPath = \"\".concat(layoutIconRootPath).concat(layoutHeight, \"/\");\n    return Array.from({\n        length: iconCount\n    }, (_, i)=>\"\".concat(layoutRootPath).concat(i + 1, \".svg\"));\n};\n// Generating icon paths for each layout\nconst layout53Icons = generateLayoutIcons(53, 3);\nconst layout63Icons = generateLayoutIcons(63, 6);\nconst layout73Icons = generateLayoutIcons(73, 7);\nconst layout93Icons = generateLayoutIcons(93, 8);\nconst layout103Icons = generateLayoutIcons(103, 8);\nconst layout123Icons = generateLayoutIcons(123, 8);\nconst layout133Icons = generateLayoutIcons(133, 6); // Adjusted for 6 icons only\nconst layout143Icons = generateLayoutIcons(143, 6);\n// Model Paths\nconst modelsRootPath = \"/assets/models/\";\nconst shadowManModelPath = modelsRootPath + \"shadow_man.glb\";\nconst handleAModelPath = modelsRootPath + \"handle_A.glb\";\nconst handleBModelPath = modelsRootPath + \"handle_B.glb\";\nconst legsModelPath = modelsRootPath + \"legs.glb\";\nconst noLegsModelPath = modelsRootPath + \"no_legs.glb\";\nconst tvModelPath = modelsRootPath + \"tv.glb\";\nvar ECabinetStyle;\n(function(ECabinetStyle) {\n    ECabinetStyle[\"GRID\"] = \"grid\";\n    ECabinetStyle[\"GRADIENT\"] = \"gradient\";\n    ECabinetStyle[\"MOSAIC\"] = \"mosaic\";\n    ECabinetStyle[\"FRAME\"] = \"frame\";\n    ECabinetStyle[\"SLANT\"] = \"slant\";\n    ECabinetStyle[\"PIXEL\"] = \"pixel\";\n})(ECabinetStyle || (ECabinetStyle = {}));\nvar ECabinetLegs;\n(function(ECabinetLegs) {\n    ECabinetLegs[\"LEGS\"] = \"LEGS\";\n    ECabinetLegs[\"NO_LEG\"] = \"NO_LEG\";\n    ECabinetLegs[\"FLOATING\"] = \"FLOATING\";\n})(ECabinetLegs || (ECabinetLegs = {}));\nvar ECabinetHandles;\n(function(ECabinetHandles) {\n    ECabinetHandles[\"HANDLE_A\"] = \"HANDLE_A\";\n    ECabinetHandles[\"HANDLE_B\"] = \"HANDLE_B\";\n    ECabinetHandles[\"PUSH\"] = \"PUSH\";\n})(ECabinetHandles || (ECabinetHandles = {}));\nvar ECabinetFinishes;\n(function(ECabinetFinishes) {\n    ECabinetFinishes[\"PLYWOOD\"] = \"Plywood\";\n    ECabinetFinishes[\"VENEER\"] = \"Veneer\";\n})(ECabinetFinishes || (ECabinetFinishes = {}));\n// Functions\n// Get the array of remaining columns widths\nconst getWidthArray = (style, totalWidth)=>{\n    let widthArray = [];\n    const unit = 100;\n    switch(style){\n        case \"grid\":\n            if (totalWidth < CELL_SIZE.maxWidth * unit) {\n                widthArray = [\n                    totalWidth - 2 * PLATE_THICKNESS * unit\n                ];\n            } else if (totalWidth < 112) {\n                widthArray = getRemainingColumns(totalWidth - 3 * PLATE_THICKNESS * unit);\n            } else if (totalWidth < 154) {\n                widthArray = [\n                    44\n                ];\n            } else if (totalWidth < 197) {\n                widthArray = [\n                    44,\n                    38\n                ];\n            } else if (totalWidth < 243) {\n                widthArray = [\n                    44,\n                    38,\n                    44\n                ];\n            } else if (totalWidth < 282) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37\n                ];\n            } else if (totalWidth < 327) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43\n                ];\n            } else if (totalWidth < 372) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43\n                ];\n            } else if (totalWidth < 412) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38\n                ];\n            } else {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38,\n                    44\n                ];\n            }\n            break;\n        default:\n            break;\n    }\n    return widthArray;\n};\n// Get the vertical layout of a column for a given cabinet height\nconst getColumnVerticalLayout = (param)=>{\n    let { cabinetHeight } = param;\n    const currentlayout = [];\n    const numberOfRows = getRowCount({\n        cabinetHeight\n    });\n    for(let i = 0; i < numberOfRows; i++){\n        currentlayout.push({\n            index: i,\n            height: getCellHeight(numberOfRows, cabinetHeight)\n        });\n    }\n    return currentlayout;\n};\n// Get the distance between two Vector3s\nfunction getDistance(p1, p2) {\n    // return the square root of the sum of the squares of the differences of the x and z coordinates\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.z - p1.z) ** 2);\n}\n// Get the count of rows for a given cabinet height\nfunction getRowCount(param) {\n    let { cabinetHeight } = param;\n    // Get the maximum height of a cell\n    const maxHeight = CELL_SIZE.maxHeight;\n    // Return the number of rows\n    return Math.floor((cabinetHeight - PLATE_THICKNESS) / (maxHeight + PLATE_THICKNESS)) + 1;\n}\n// Get the number of columns and the width of a cell for a given total width\nfunction getColumnCount(param) {\n    let { totalWidth } = param;\n    // Get the maximum width of a cell\n    const maxWidth = CELL_SIZE.maxWidth;\n    // Get the number of columns according to the total width\n    const numberOfColumns = Math.floor((totalWidth - PLATE_THICKNESS) / (maxWidth + PLATE_THICKNESS)) + 1;\n    // Get the total width of cells without\n    const sum = totalWidth - (numberOfColumns + 1) * PLATE_THICKNESS;\n    // Round to 2 decimal places\n    const widthOfCell = Math.round(sum / numberOfColumns * 100) / 100;\n    return {\n        numberOfColumns,\n        widthOfCell\n    };\n}\n// Get the height of a cell for a given number of rows and a cabinet height\nfunction getCellHeight(rowCount, cabinetHeight) {\n    // Get the height of a cell\n    const cellHeight = (cabinetHeight - (rowCount - 1) * PLATE_THICKNESS) / rowCount;\n    return cellHeight;\n}\n// Get the width of a cell for a given number of columns and a total width\nfunction getCellWidth(columnCount, totalWidth) {\n    // Get the width of a cell\n    const cellWidth = (totalWidth - (columnCount + 1) * PLATE_THICKNESS) / columnCount;\n    return cellWidth;\n}\nfunction getBottomHeight(legs) {\n    return legs === \"NO_LEG\" ? 0.02 : LEG_HEIGHT;\n}\nfunction getPartitonPlates(param) {\n    let { columns, totalHeight, totalWidth, totalDepth, legHeight } = param;\n    const verticals = [];\n    const horizontals = [];\n    const availableSpaces = [];\n    const backsides = [];\n    const spaceHeight = totalHeight - 2 * PLATE_THICKNESS - legHeight;\n    const posY = (totalHeight + legHeight) / 2;\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    verticals.push({\n        row: 0,\n        col: -1,\n        position: {\n            x: startPosX,\n            y: posY,\n            z: 0\n        },\n        scale: {\n            width: spaceHeight,\n            depth: totalDepth\n        }\n    });\n    for(let col = 0; col < columns.length; col++){\n        const column = columns[col];\n        const rows = column.rows;\n        let sum = 0;\n        for(let i = 0; i < col + 1; i++){\n            sum += columns[i].width;\n        }\n        const posX = startPosX + sum + (col + 1) * PLATE_THICKNESS;\n        const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n        verticals.push({\n            row: 0,\n            col,\n            position: {\n                x: posX,\n                y: posY,\n                z: 0\n            },\n            scale: {\n                width: spaceHeight,\n                depth: totalDepth\n            }\n        });\n        availableSpaces.push({\n            row: 0,\n            col,\n            position: {\n                x: spacePosX,\n                y: posY,\n                z: totalDepth / 2\n            },\n            scale: {\n                width: column.width,\n                depth: spaceHeight\n            }\n        });\n        for(let rowIndex = 0; rowIndex < rows.length; rowIndex++){\n            let verticalSum = 0;\n            for(let p = 0; p < rowIndex + 1; p++){\n                verticalSum += rows[rowIndex].height;\n            }\n            const middlePosY = bottomPosY + verticalSum + (rowIndex + 1) * PLATE_THICKNESS;\n            const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[rowIndex].height / 2;\n            const backPosZ = -(totalDepth - PLATE_THICKNESS) / 2;\n            if (rowIndex < rows.length - 1) {\n                horizontals.push({\n                    row: rowIndex,\n                    col,\n                    position: {\n                        x: spacePosX,\n                        y: middlePosY,\n                        z: 0\n                    },\n                    scale: {\n                        width: column.width,\n                        depth: totalDepth - EDGE_GAP\n                    }\n                });\n            }\n            backsides.push({\n                row: rowIndex,\n                col,\n                position: {\n                    x: spacePosX,\n                    y: backPosY,\n                    z: backPosZ\n                },\n                scale: {\n                    width: column.width,\n                    depth: rows[rowIndex].height\n                }\n            });\n        }\n    }\n    return {\n        verticals,\n        availableSpaces,\n        horizontals,\n        backsides\n    };\n}\n// Fix the function signature\nconst getCalculatedColumns = (param)=>{\n    let { current, cabinetSize, cabinetStyle, legHeight, columnCount } = param;\n    const { totalWidth, totalHeight, totalDepth } = cabinetSize;\n    // Calculate available width (total width minus side plates)\n    const availableWidth = totalWidth - 2 * PLATE_THICKNESS;\n    // Determine how many columns can fit\n    let numColumns;\n    if (columnCount) {\n        numColumns = columnCount;\n    } else {\n        // Calculate based on minimum column width\n        numColumns = Math.floor(availableWidth / (CELL_SIZE.minWidth + PLATE_THICKNESS));\n        // Ensure at least one column\n        numColumns = Math.max(1, numColumns);\n    }\n    // Calculate column width\n    const columnWidth = (availableWidth - (numColumns - 1) * PLATE_THICKNESS) / numColumns;\n    // Create columns array\n    const columns = [];\n    // Generate each column\n    for(let i = 0; i < numColumns; i++){\n        // Calculate position\n        const posX = -totalWidth / 2 + PLATE_THICKNESS + i * (columnWidth + PLATE_THICKNESS) + columnWidth / 2;\n        // Create column with appropriate layout\n        const column = createColumnWithLayout(columnWidth, posX, totalHeight, legHeight, cabinetStyle);\n        columns.push(column);\n    }\n    return columns;\n};\nfunction getRemainingColumns(remainingWidth) {\n    const b = remainingWidth % 2 === 0 ? remainingWidth / 2 : (remainingWidth + 1) / 2;\n    const c = remainingWidth - b;\n    return [\n        b,\n        c\n    ];\n}\nfunction getIndividualColumn(param) {\n    let { targetIndex, columns, totalWidth, totalDepth, legHeight } = param;\n    const column = columns[targetIndex];\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    const rowsPos = [];\n    const delta = 0.02;\n    const rows = column.rows;\n    let sum = 0;\n    for(let i = 0; i < targetIndex + 1; i++){\n        sum += columns[i].width;\n    }\n    const posX = startPosX + sum + (targetIndex + 1) * PLATE_THICKNESS;\n    const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n    for(let i = 0; i < rows.length; i++){\n        let verticalSum = 0;\n        for(let p = 0; p < i + 1; p++){\n            verticalSum += rows[p].height;\n        }\n        const middlePosY = bottomPosY + verticalSum + (i + 1) * PLATE_THICKNESS;\n        const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[i].height / 2;\n        rowsPos.push({\n            x: spacePosX - column.width / 2,\n            y: backPosY,\n            z: totalDepth / 2 + delta,\n            height: rows[i].height\n        });\n    }\n    return {\n        position: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(spacePosX, legHeight + PLATE_THICKNESS + delta, totalDepth / 2 + delta),\n        rows: rowsPos\n    };\n}\nconst getLayoutImages = (param)=>{\n    let { totalHeight } = param;\n    let imgsArray = [];\n    if (totalHeight < 0.53) {\n        imgsArray = [\n            ...layout53Icons\n        ];\n    } else if (totalHeight < 0.63) {\n        imgsArray = [\n            ...layout63Icons\n        ];\n    } else if (totalHeight < 0.73) {\n        imgsArray = [\n            ...layout73Icons\n        ];\n    } else if (totalHeight < 0.93) {\n        imgsArray = [\n            ...layout93Icons\n        ];\n    } else if (totalHeight < 1.03) {\n        imgsArray = [\n            ...layout103Icons\n        ];\n    } else if (totalHeight < 1.23) {\n        imgsArray = [\n            ...layout123Icons\n        ];\n    } else if (totalHeight < 1.33) {\n        imgsArray = [\n            ...layout133Icons\n        ];\n    } else {\n        imgsArray = [\n            ...layout143Icons\n        ];\n    }\n    return imgsArray;\n};\nconst getId = (item)=>\"\".concat(item, \"-\").concat(Math.random().toString(32).slice(-4));\nconst createColumnWithLayout = (columnWidth, posX, totalHeight, legHeight, cabinetStyle)=>{\n    // Calculate the cabinet height (excluding legs and plate thickness)\n    const cabinetHeight = totalHeight - legHeight - 2 * PLATE_THICKNESS;\n    // Get the basic vertical layout for the column\n    const rows = getColumnVerticalLayout({\n        cabinetHeight\n    });\n    // Get the starting position Y coordinate\n    const startPosY = legHeight + PLATE_THICKNESS;\n    // Default to an empty layout (will be populated based on style)\n    let layoutIndex = 0;\n    let doors = [];\n    let drawers = [];\n    // Based on cabinet style, choose an appropriate layout\n    switch(cabinetStyle){\n        case ECabinetStyle.Modern:\n            // For modern style, use all drawers\n            layoutIndex = 1;\n            // Create a drawer for each row\n            drawers = rows.map((row, index)=>({\n                    index,\n                    size: {\n                        width: columnWidth,\n                        height: row.height\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + (index + 0.5) * row.height + index * PLATE_THICKNESS\n                    }\n                }));\n            break;\n        case ECabinetStyle.Classic:\n        default:\n            // For classic style, use doors for all rows\n            layoutIndex = 0;\n            // Create a door for the full height\n            doors = [\n                {\n                    index: 0,\n                    size: {\n                        width: columnWidth,\n                        height: cabinetHeight\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + cabinetHeight / 2\n                    },\n                    opening: 1\n                }\n            ];\n            break;\n    }\n    // Create and return the column object\n    return {\n        index: 0,\n        width: columnWidth,\n        posX: posX,\n        rows: rows,\n        doors: doors,\n        drawers: drawers,\n        dividers: [],\n        layoutIndex: layoutIndex,\n        isDivide: false,\n        lastRow: drawers.length > 0 ? \"drawer\" : \"door\"\n    };\n};\n// Update the cabinet size constraints\nconst CABINET_SIZE_CONSTRAINTS = {\n    minWidth: 0.4,\n    maxWidth: 2.5,\n    minHeight: 0.4,\n    maxHeight: 2.4,\n    minDepth: 0.3,\n    maxDepth: 0.8\n};\nconst applyRandomLayoutsToColumns = (columns, totalHeight, legHeight)=>{\n    const startPosY = legHeight + PLATE_THICKNESS;\n    return columns.map((column)=>{\n        // Get all available layout options for this column\n        const layoutOptions = (0,_columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__.getLayoutOptionsOfColumn)({\n            totalHeight,\n            legHeight,\n            columnWidth: column.width,\n            posX: column.posX,\n            startPosY,\n            doorDir: 1 // Default door opening direction\n        });\n        // Select a random layout option\n        const randomLayoutIndex = Math.floor(Math.random() * layoutOptions.length);\n        const randomLayout = layoutOptions[randomLayoutIndex];\n        // Apply the random layout to the column\n        return {\n            ...column,\n            layoutIndex: randomLayoutIndex,\n            rows: randomLayout.rows,\n            doors: randomLayout.doors,\n            drawers: randomLayout.drawers,\n            lastRow: randomLayout.lastRow\n        };\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy91dGlsaXRpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDK0I7QUFFa0M7QUFFakUsZUFBZTtBQUNmLGFBQWE7QUFDTixNQUFNRSxrQkFBa0IsS0FBSztBQUM3QixNQUFNQyxZQUFZO0lBQ3ZCQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxXQUFXO0FBQ2IsRUFBRTtBQUNLLE1BQU1DLGFBQWEsS0FBSztBQUN4QixNQUFNQyxZQUFZLEtBQUs7QUFDdkIsTUFBTUMsWUFBWSxLQUFLO0FBQ3ZCLE1BQU1DLFdBQVcsTUFBTTtBQUU5QixTQUFTO0FBQ0YsTUFBTUMsWUFBWSxVQUFVO0FBQzVCLE1BQU1DLGFBQWEsVUFBVTtBQUM3QixNQUFNQyxvQkFBb0IsVUFBVTtBQUNwQyxNQUFNQyx3QkFBd0IsVUFBVTtBQUUvQyxnQkFBZ0I7QUFDaEIsTUFBTUMsbUJBQW1CO0FBQ2xCLE1BQU1DLGtCQUFrQkQsbUJBQW1CLGtCQUFrQjtBQUNwRSxNQUFNRSxrQkFBa0JGLG1CQUFtQjtBQUMzQyxNQUFNRyxtQkFBbUJELGtCQUFrQjtBQUMzQyxNQUFNRSx1QkFBdUJGLGtCQUFrQjtBQUMvQyxNQUFNRywwQkFBMEJILGtCQUFrQjtBQUUzQyxNQUFNSSxrQkFBa0I7SUFDN0JDLE9BQU9KO0lBQ1BLLFdBQVdKO0lBQ1hLLGNBQWNKO0FBQ2hCLEVBQUU7QUFFRix1QkFBdUI7QUFDdkIsTUFBTUssZUFBZVYsbUJBQW1CO0FBQ3hDLE1BQU1XLGtCQUFrQkQsZUFBZTtBQUN2QyxNQUFNRSxzQkFBc0JGLGVBQWU7QUFDM0MsTUFBTUcseUJBQXlCSCxlQUFlO0FBRXZDLE1BQU1JLGlCQUFpQjtJQUM1QlAsT0FBT0k7SUFDUEgsV0FBV0k7SUFDWEgsY0FBY0k7QUFDaEIsRUFBRTs7VUFHVUU7Z0VBQ2VmO0lBQ3pCLDBFQUEwRTt5REFD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QixjQUFjOUgsTUFBTTtRQUN6RSxNQUFNaUksZUFBZUgsYUFBYSxDQUFDRSxrQkFBa0I7UUFFckQsd0NBQXdDO1FBQ3hDLE9BQU87WUFDTCxHQUFHckQsTUFBTTtZQUNUbUMsYUFBYWtCO1lBQ2JwRCxNQUFNcUQsYUFBYXJELElBQUk7WUFDdkJtQyxPQUFPa0IsYUFBYWxCLEtBQUs7WUFDekJDLFNBQVNpQixhQUFhakIsT0FBTztZQUM3QlMsU0FBU1EsYUFBYVIsT0FBTztRQUMvQjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvdXRpbGl0aWVzLnRzPzMxMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUNhYmluZXRTaXplLCBJQ29sdW1uLCBJQ29sdW1uTGFzdFJvdywgSVBhcnRpdGlvbiB9IGZyb20gJ0Avc3RvcmUvdHlwZXMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGdldExheW91dE9wdGlvbnNPZkNvbHVtbiB9IGZyb20gJy4vY29sdW1uTGF5b3V0T3B0aW9ucyc7XG5cbi8vLS0tIENPTlNUQU5UU1xuLy8gRGltZW5zaW9uc1xuZXhwb3J0IGNvbnN0IFBMQVRFX1RISUNLTkVTUyA9IDAuMDI7XG5leHBvcnQgY29uc3QgQ0VMTF9TSVpFID0ge1xuICBtYXhXaWR0aDogMC42MCxcbiAgbWluV2lkdGg6IDAuMjUsXG4gIG1heEhlaWdodDogMC4zNSxcbiAgbWluSGVpZ2h0OiAwLjE1LFxufTtcbmV4cG9ydCBjb25zdCBMRUdfSEVJR0hUID0gMC4xODtcbmV4cG9ydCBjb25zdCBMRUdfV0lEVEggPSAwLjA1O1xuZXhwb3J0IGNvbnN0IExFR19ERVBUSCA9IDAuMDU7XG5leHBvcnQgY29uc3QgRURHRV9HQVAgPSAwLjAwNjtcblxuLy8gQ29sb3JzXG5leHBvcnQgY29uc3Qgd2FsbENvbG9yID0gJyNlN2U3ZTcnO1xuZXhwb3J0IGNvbnN0IGZsb29yQ29sb3IgPSAnI2I3YjdiNyc7XG5leHBvcnQgY29uc3QgYW1iaWVudExpZ2h0Q29sb3IgPSAnI2YwZjBmMCc7XG5leHBvcnQgY29uc3QgZGlyZWN0aW9uYWxMaWdodENvbG9yID0gJyNmMGYwZjAnO1xuXG4vLyBUZXh0dXJlIHBhdGhzXG5jb25zdCB0ZXh0dXJlc1Jvb3RQYXRoID0gJy9hc3NldHMvdGV4dHVyZXMvJztcbmV4cG9ydCBjb25zdCBlbnZpcm9ubWVudFBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ2Vudmlyb25tZW50Lmhkcic7XG5jb25zdCBwbHl3b29kUm9vdFBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2RfMWsvdGV4dHVyZXMvJztcbmNvbnN0IHBseXdvb2RBb01hcFBhdGggPSBwbHl3b29kUm9vdFBhdGggKyAncGx5d29vZF9hb18xay5qcGcnO1xuY29uc3QgcGx5d29vZE5vcm1hbE1hcFBhdGggPSBwbHl3b29kUm9vdFBhdGggKyAncGx5d29vZF9ub3JfZ2xfMWsuanBnJztcbmNvbnN0IHBseXdvb2RSb3VnaG5lc3NNYXBQYXRoID0gcGx5d29vZFJvb3RQYXRoICsgJ3BseXdvb2Rfcm91Z2hfMWsuanBnJztcblxuZXhwb3J0IGNvbnN0IHBseXdvb2RUZXh0dXJlcyA9IHtcbiAgYW9NYXA6IHBseXdvb2RBb01hcFBhdGgsXG4gIG5vcm1hbE1hcDogcGx5d29vZE5vcm1hbE1hcFBhdGgsXG4gIHJvdWdobmVzc01hcDogcGx5d29vZFJvdWdobmVzc01hcFBhdGgsXG59O1xuXG4vLyBCYXNlIFRleHR1cmVzIFZlZW5lclxuY29uc3Qgd29vZFJvb3RQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICd3b29kXzI3Lyc7XG5jb25zdCB2ZW5lZXJBb01hcFBhdGggPSB3b29kUm9vdFBhdGggKyAnYW1iaWVudC1vY2NsdXNpb24uanBnJztcbmNvbnN0IHZlbmVlck5vcm1hbE1hcFBhdGggPSB3b29kUm9vdFBhdGggKyAnbm9ybWFsLmpwZyc7XG5jb25zdCB2ZW5lZXJSb3VnaG5lc3NNYXBQYXRoID0gd29vZFJvb3RQYXRoICsgJ3JvdWdobmVzcy5qcGcnO1xuXG5leHBvcnQgY29uc3QgdmVuZWVyVGV4dHVyZXMgPSB7XG4gIGFvTWFwOiB2ZW5lZXJBb01hcFBhdGgsXG4gIG5vcm1hbE1hcDogdmVuZWVyTm9ybWFsTWFwUGF0aCxcbiAgcm91Z2huZXNzTWFwOiB2ZW5lZXJSb3VnaG5lc3NNYXBQYXRoLFxufTtcblxuLy8gVmVuZWVyIFRleHR1cmVzXG5leHBvcnQgZW51bSBFVmVuZWVyVGV4dHVyZXMge1xuICBCRUlHRV9HUkVZX0xPUkVOWk9fT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYmVpZ2VfZ3JleV9sb3JlbnpvX29hay5qcGcnLFxuICAvLyBCRUlHRV9URVhUSUxFID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYmVpZ2VfdGV4dGlsZS5qcGcnLFxuICBCUk9XTl9BQkFOT19BU0ggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9icm93bl9hYmFub19hc2guanBnJyxcbiAgQlJPV05fSEFMSUZBWF9PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9icm93bl9oYWxpZmF4X29hay5qcGcnLFxuICBCUk9XTl9UT05OU0JFUkdfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYnJvd25fdG9ubnNiZXJnX29hay5qcGcnLFxuICBCUk9XTl9XQVJNSUFfV0FMTE5VVCA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2Jyb3duX3dhcm1pYV93YWxsbnV0LmpwZycsXG4gIExJR0hUX0JBUk9OSUFfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvbGlnaHRfYmFyb25pYV9vYWsuanBnJyxcbiAgTElHSFRfTkFUVVJBTF9EQVZFTlBPUlRfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvTGlnaHRfTmF0dXJhbF9EYXZlbnBvcnRfb2FrLmpwZycsXG4gIE5BVFVSQUxfQ0FTRUxMQV9PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9uYXR1cmFsX2Nhc2VsbGFfb2FrLmpwZycsXG4gIFBBUk9OQV9XQUxMTlVUID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvcGFyb25hX3dhbGxudXQuanBnJyxcbiAgU0VWSUxMQV9BU0ggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9zZXZpbGxhX2FzaC5qcGcnLFxuICBWSUNFTlpBX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL3ZpY2VuemFfb2FrLmpwZycsXG4gIFZJQ0VOWkFfT0FLXzIgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC92aWNlbnphX29hazIuanBnJyxcbn1cblxuLy9QbHl3b29kIFRleHR1cmVzXG5leHBvcnQgZW51bSBFUGx5d29vZFRleHR1cmVzIHtcbiAgQlJPTlpFX0JSVVNIRURfTUVUQUwgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2Jyb256ZV9icnVzaGVkX21ldGFsLmpwZycsXG4gIEFMTU9ORF9CRUlHRSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvYWxtb25kX2JlaWdlLmpwZycsXG4gIENBUkFUX0JFSUdFID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9jYXJhdF9iZWlnZS5qcGcnLFxuICBDQVNITUVSRV9HUkVZID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9jYXNobWVyZV9ncmV5LmpwZycsXG4gIENPUkFfQlJPTlpFID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9jb2JyYV9icm9uemUuanBnJyxcbiAgQ1VCQU5JVEVfR1JFWSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvY3ViYW5pdGVfZ3JleS5qcGcnLFxuICBGSVJfR1JFRU4gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2Zpcl9ncmVlbi5qcGcnLFxuICBGSk9SRF9HUkVFTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvZmpvcmRfZ3JlZW4uanBnJyxcbiAgR1JBUEhJVEVfR1JFWSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvZ3JhcGhpdGVfZ3JleS5qcGcnLFxuICBJTkRJR09fQkxVRSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvaW5kaWdvX2JsdWUuanBnJyxcbiAgUkVFRF9HUkVFTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvcmVlZF9ncmVlbi5qcGcnLFxuICBTQUdFX0dSRUVOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9zYWdlX2dyZWVuLmpwZycsXG4gIFNUT05FX0dSRUVOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9zdG9uZV9ncmVlbi5qcGcnLFxuICBUQVVQRV9HUkVZID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy90YXVwZV9ncmV5LmpwZycsXG4gIFRSVUZGTEVfQlJPV04gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL3RydWZmbGVfYnJvd24uanBnJyxcbiAgVTk5OV9QTV9CTEFDSyA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvVTk5OV9QTV9CbGFjay5qcGcnLFxufVxuXG4vLyBPY2NsdXNpb24gVGV4dHVyZXNcbmV4cG9ydCBjb25zdCBob3Jpem9udGFsT2NjbHVzaW9uVGV4dHVyZVBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ2hvcml6b250YWwtcGFuZWwuanBnJztcbmV4cG9ydCBjb25zdCB2ZXJ0aWNhbE9jY2x1c2lvblRleHR1cmVQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICd2ZXJ0aWNhbC1wYW5lbC5qcGcnO1xuZXhwb3J0IGNvbnN0IGJhY2tPY2NsdXNpb25UZXh0dXJlUGF0aCA9IHRleHR1cmVzUm9vdFBhdGggKyAnYmFjay1wYW5lbC5qcGcnO1xuXG5leHBvcnQgZW51bSBFT2NjbHVzaW9uSW1hZ2VzIHtcbiAgSE9SSVpPTlRBTCA9IGhvcml6b250YWxPY2NsdXNpb25UZXh0dXJlUGF0aCxcbiAgQkFDSyA9IHZlcnRpY2FsT2NjbHVzaW9uVGV4dHVyZVBhdGgsXG4gIFZFUlRJQ0FMID0gYmFja09jY2x1c2lvblRleHR1cmVQYXRoLFxufVxuXG4vLyBMYXlvdXQgSWNvbnNcbmNvbnN0IGxheW91dEljb25Sb290UGF0aCA9ICcvYXNzZXRzL2ljb25zL29uLW1vZGVsLWVkaXRvci8nO1xuXG5leHBvcnQgY29uc3QgaWNvbmlmeUljb25zID0ge1xuICBsYXlvdXRJY29uczoge1xuICAgIHVuZG9JY29uOiAnc29sYXI6dW5kby1sZWZ0LXJvdW5kLW91dGxpbmUnLFxuICAgIGRpbWVuc2lvbnNJY29uOiAnc29sYXI6cnVsZXItbGluZWFyJyxcbiAgICBkb29yc0ljb246ICdmbHVlbnQ6ZG9vci0yMC1yZWd1bGFyJyxcbiAgICBhbGlnbkNvbHVtbnNJY29uOiAnZmxvd2JpdGU6Z3JpZC1wbHVzLW91dGxpbmUnLFxuICAgIHNob3dEZWNvcmF0aW9uc0ljb246ICdodWdlaWNvbnM6cGFpbnQtYnJ1c2gtMDInLFxuICAgIGFzc2VtYmx5SWNvbjogJ2NhcmJvbjozZC1jdXJzb3InLFxuICB9LFxuICBtZW51SWNvbnM6IHtcbiAgICBhcnJvd1VwOiAnaXd3YTphcnJvdy11cCcsXG4gICAgYXJyb3dEb3duOiAnaXd3YTphcnJvdy1kb3duJyxcbiAgICBpbmZvUXVlc3Rpb246ICdwaDpxdWVzdGlvbi1ib2xkJyxcbiAgfSxcbiAgc2NlbmVJY29uczoge1xuICAgIGVkaXRMYXlvdXQ6ICdpYy1vdXRsaW5lLWNyZWF0ZScsXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgbWVudUljb25QYXRoczoge1xuICBsZWdzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBoYW5kbGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBzdHlsZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59ID0ge1xuICBsZWdzOiB7XG4gICAgbm9fbGVnOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL2xlZ3Mvbm9fbGVnLnN2ZycsXG4gICAgbGVnczogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9sZWdzL2xlZ3Muc3ZnJyxcbiAgICBmbG9hdGluZzogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9sZWdzL2Zsb2F0aW5nLnN2ZycsXG4gIH0sXG4gIGhhbmRsZXM6IHtcbiAgICBoYW5kbGVfYTogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9oYW5kbGVzL2hhbmRsZV9BLnN2ZycsXG4gICAgaGFuZGxlX2I6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvaGFuZGxlcy9oYW5kbGVfQi5zdmcnLFxuICAgIHB1c2g6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvaGFuZGxlcy9wdXNoLnN2ZycsXG4gIH0sXG4gIHN0eWxlczoge1xuICAgIGZyYW1lOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9mcmFtZS5zdmcnLFxuICAgIGdyYWRpZW50OiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9ncmFkaWVudC5zdmcnLFxuICAgIGdyaWQ6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL2dyaWQuc3ZnJyxcbiAgICBtb3NhaWM6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL21vc2FpYy5zdmcnLFxuICAgIHBpeGVsOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9waXhlbC5zdmcnLFxuICAgIHNsYW50OiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9zbGFudC5zdmcnLFxuICB9LFxufTtcblxuY29uc3QgZ2VuZXJhdGVMYXlvdXRJY29ucyA9IChsYXlvdXRIZWlnaHQ6IG51bWJlciwgaWNvbkNvdW50OiBudW1iZXIpID0+IHtcbiAgY29uc3QgbGF5b3V0Um9vdFBhdGggPSBgJHtsYXlvdXRJY29uUm9vdFBhdGh9JHtsYXlvdXRIZWlnaHR9L2A7XG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpY29uQ291bnQgfSwgKF8sIGkpID0+IGAke2xheW91dFJvb3RQYXRofSR7aSArIDF9LnN2Z2ApO1xufTtcblxuLy8gR2VuZXJhdGluZyBpY29uIHBhdGhzIGZvciBlYWNoIGxheW91dFxuY29uc3QgbGF5b3V0NTNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoNTMsIDMpO1xuY29uc3QgbGF5b3V0NjNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoNjMsIDYpO1xuY29uc3QgbGF5b3V0NzNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoNzMsIDcpO1xuY29uc3QgbGF5b3V0OTNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoOTMsIDgpO1xuY29uc3QgbGF5b3V0MTAzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDEwMywgOCk7XG5jb25zdCBsYXlvdXQxMjNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoMTIzLCA4KTtcbmNvbnN0IGxheW91dDEzM0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucygxMzMsIDYpOyAvLyBBZGp1c3RlZCBmb3IgNiBpY29ucyBvbmx5XG5jb25zdCBsYXlvdXQxNDNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoMTQzLCA2KTtcblxuLy8gTW9kZWwgUGF0aHNcbmNvbnN0IG1vZGVsc1Jvb3RQYXRoID0gJy9hc3NldHMvbW9kZWxzLyc7XG5cbmV4cG9ydCBjb25zdCBzaGFkb3dNYW5Nb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICdzaGFkb3dfbWFuLmdsYic7XG5leHBvcnQgY29uc3QgaGFuZGxlQU1vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ2hhbmRsZV9BLmdsYic7XG5leHBvcnQgY29uc3QgaGFuZGxlQk1vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ2hhbmRsZV9CLmdsYic7XG5leHBvcnQgY29uc3QgbGVnc01vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ2xlZ3MuZ2xiJztcbmV4cG9ydCBjb25zdCBub0xlZ3NNb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICdub19sZWdzLmdsYic7XG5leHBvcnQgY29uc3QgdHZNb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICd0di5nbGInO1xuXG4vLyBFbnVtc1xuZXhwb3J0IGVudW0gRUNhYmluZXRTdHlsZSB7XG4gIEdSSUQgPSAnZ3JpZCcsXG4gIEdSQURJRU5UID0gJ2dyYWRpZW50JyxcbiAgTU9TQUlDID0gJ21vc2FpYycsXG4gIEZSQU1FID0gJ2ZyYW1lJyxcbiAgU0xBTlQgPSAnc2xhbnQnLFxuICBQSVhFTCA9ICdwaXhlbCcsXG59XG5cbmV4cG9ydCBlbnVtIEVDYWJpbmV0TGVncyB7XG4gIExFR1MgPSAnTEVHUycsXG4gIE5PX0xFRyA9ICdOT19MRUcnLFxuICBGTE9BVElORyA9ICdGTE9BVElORycsXG59XG5cbmV4cG9ydCBlbnVtIEVDYWJpbmV0SGFuZGxlcyB7XG4gIEhBTkRMRV9BID0gJ0hBTkRMRV9BJyxcbiAgSEFORExFX0IgPSAnSEFORExFX0InLFxuICBQVVNIID0gJ1BVU0gnLFxufVxuXG5leHBvcnQgZW51bSBFQ2FiaW5ldEZpbmlzaGVzIHtcbiAgUExZV09PRCA9ICdQbHl3b29kJyxcbiAgVkVORUVSID0gJ1ZlbmVlcicsXG59XG5cbi8vIEZ1bmN0aW9uc1xuXG4vLyBHZXQgdGhlIGFycmF5IG9mIHJlbWFpbmluZyBjb2x1bW5zIHdpZHRoc1xuZXhwb3J0IGNvbnN0IGdldFdpZHRoQXJyYXkgPSAoc3R5bGU6IEVDYWJpbmV0U3R5bGUsIHRvdGFsV2lkdGg6IG51bWJlcikgPT4ge1xuICBsZXQgd2lkdGhBcnJheTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgdW5pdCA9IDEwMDtcbiAgc3dpdGNoIChzdHlsZSkge1xuICAgIGNhc2UgRUNhYmluZXRTdHlsZS5HUklEOlxuICAgICAgaWYgKHRvdGFsV2lkdGggPCBDRUxMX1NJWkUubWF4V2lkdGggKiB1bml0KSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbdG90YWxXaWR0aCAtIDIgKiBQTEFURV9USElDS05FU1MgKiB1bml0XTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDExMikge1xuICAgICAgICB3aWR0aEFycmF5ID0gZ2V0UmVtYWluaW5nQ29sdW1ucyh0b3RhbFdpZHRoIC0gMyAqIFBMQVRFX1RISUNLTkVTUyAqIHVuaXQpO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMTU0KSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDRdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMTk3KSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4XTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDI0Mykge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOCwgNDRdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMjgyKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NCwgMzddO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMzI3KSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NCwgMzcsIDQzXTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDM3Mikge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOCwgNDQsIDM3LCA0MywgNDNdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgNDEyKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NCwgMzcsIDQzLCA0MywgMzhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzNywgNDMsIDQzLCAzOCwgNDRdO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB3aWR0aEFycmF5O1xufTtcblxuLy8gR2V0IHRoZSB2ZXJ0aWNhbCBsYXlvdXQgb2YgYSBjb2x1bW4gZm9yIGEgZ2l2ZW4gY2FiaW5ldCBoZWlnaHRcbmV4cG9ydCBjb25zdCBnZXRDb2x1bW5WZXJ0aWNhbExheW91dCA9ICh7IGNhYmluZXRIZWlnaHQgfTogeyBjYWJpbmV0SGVpZ2h0OiBudW1iZXIgfSkgPT4ge1xuICBjb25zdCBjdXJyZW50bGF5b3V0ID0gW107XG4gIGNvbnN0IG51bWJlck9mUm93cyA9IGdldFJvd0NvdW50KHsgY2FiaW5ldEhlaWdodCB9KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlJvd3M7IGkrKykge1xuICAgIGN1cnJlbnRsYXlvdXQucHVzaCh7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGhlaWdodDogZ2V0Q2VsbEhlaWdodChudW1iZXJPZlJvd3MsIGNhYmluZXRIZWlnaHQpLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjdXJyZW50bGF5b3V0O1xufTtcblxuLy8gR2V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBWZWN0b3Izc1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKHAxOiBWZWN0b3IzLCBwMjogVmVjdG9yMykge1xuICAvLyByZXR1cm4gdGhlIHNxdWFyZSByb290IG9mIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdGhlIGRpZmZlcmVuY2VzIG9mIHRoZSB4IGFuZCB6IGNvb3JkaW5hdGVzXG4gIHJldHVybiBNYXRoLnNxcnQoKHAyLnggLSBwMS54KSAqKiAyICsgKHAyLnogLSBwMS56KSAqKiAyKTtcbn1cblxuLy8gR2V0IHRoZSBjb3VudCBvZiByb3dzIGZvciBhIGdpdmVuIGNhYmluZXQgaGVpZ2h0XG5leHBvcnQgZnVuY3Rpb24gZ2V0Um93Q291bnQoeyBjYWJpbmV0SGVpZ2h0IH06IHsgY2FiaW5ldEhlaWdodDogbnVtYmVyIH0pIHtcbiAgLy8gR2V0IHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIGNlbGxcbiAgY29uc3QgbWF4SGVpZ2h0ID0gQ0VMTF9TSVpFLm1heEhlaWdodDtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiByb3dzXG4gIHJldHVybiBNYXRoLmZsb29yKChjYWJpbmV0SGVpZ2h0IC0gUExBVEVfVEhJQ0tORVNTKSAvIChtYXhIZWlnaHQgKyBQTEFURV9USElDS05FU1MpKSArIDE7XG59XG5cbi8vIEdldCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYW5kIHRoZSB3aWR0aCBvZiBhIGNlbGwgZm9yIGEgZ2l2ZW4gdG90YWwgd2lkdGhcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2x1bW5Db3VudCh7IHRvdGFsV2lkdGggfTogeyB0b3RhbFdpZHRoOiBudW1iZXIgfSkge1xuICAvLyBHZXQgdGhlIG1heGltdW0gd2lkdGggb2YgYSBjZWxsXG4gIGNvbnN0IG1heFdpZHRoID0gQ0VMTF9TSVpFLm1heFdpZHRoO1xuXG4gIC8vIEdldCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYWNjb3JkaW5nIHRvIHRoZSB0b3RhbCB3aWR0aFxuICBjb25zdCBudW1iZXJPZkNvbHVtbnMgPSBNYXRoLmZsb29yKCh0b3RhbFdpZHRoIC0gUExBVEVfVEhJQ0tORVNTKSAvIChtYXhXaWR0aCArIFBMQVRFX1RISUNLTkVTUykpICsgMTtcblxuICAvLyBHZXQgdGhlIHRvdGFsIHdpZHRoIG9mIGNlbGxzIHdpdGhvdXRcbiAgY29uc3Qgc3VtID0gdG90YWxXaWR0aCAtIChudW1iZXJPZkNvbHVtbnMgKyAxKSAqIFBMQVRFX1RISUNLTkVTUztcblxuICAvLyBSb3VuZCB0byAyIGRlY2ltYWwgcGxhY2VzXG4gIGNvbnN0IHdpZHRoT2ZDZWxsID0gTWF0aC5yb3VuZCgoc3VtIC8gbnVtYmVyT2ZDb2x1bW5zKSAqIDEwMCkgLyAxMDA7XG5cbiAgcmV0dXJuIHtcbiAgICBudW1iZXJPZkNvbHVtbnMsXG4gICAgd2lkdGhPZkNlbGwsXG4gIH07XG59XG5cbi8vIEdldCB0aGUgaGVpZ2h0IG9mIGEgY2VsbCBmb3IgYSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgYSBjYWJpbmV0IGhlaWdodFxuZXhwb3J0IGZ1bmN0aW9uIGdldENlbGxIZWlnaHQocm93Q291bnQ6IG51bWJlciwgY2FiaW5ldEhlaWdodDogbnVtYmVyKSB7XG4gIC8vIEdldCB0aGUgaGVpZ2h0IG9mIGEgY2VsbFxuICBjb25zdCBjZWxsSGVpZ2h0ID0gKGNhYmluZXRIZWlnaHQgLSAocm93Q291bnQgLSAxKSAqIFBMQVRFX1RISUNLTkVTUykgLyByb3dDb3VudDtcbiAgcmV0dXJuIGNlbGxIZWlnaHQ7XG59XG5cbi8vIEdldCB0aGUgd2lkdGggb2YgYSBjZWxsIGZvciBhIGdpdmVuIG51bWJlciBvZiBjb2x1bW5zIGFuZCBhIHRvdGFsIHdpZHRoXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VsbFdpZHRoKGNvbHVtbkNvdW50OiBudW1iZXIsIHRvdGFsV2lkdGg6IG51bWJlcikge1xuICAvLyBHZXQgdGhlIHdpZHRoIG9mIGEgY2VsbFxuICBjb25zdCBjZWxsV2lkdGggPSAodG90YWxXaWR0aCAtIChjb2x1bW5Db3VudCArIDEpICogUExBVEVfVEhJQ0tORVNTKSAvIGNvbHVtbkNvdW50O1xuICByZXR1cm4gY2VsbFdpZHRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90dG9tSGVpZ2h0KGxlZ3M6IEVDYWJpbmV0TGVncykge1xuICByZXR1cm4gbGVncyA9PT0gRUNhYmluZXRMZWdzLk5PX0xFRyA/IDAuMDIgOiBMRUdfSEVJR0hUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFydGl0b25QbGF0ZXMoeyBjb2x1bW5zLCB0b3RhbEhlaWdodCwgdG90YWxXaWR0aCwgdG90YWxEZXB0aCwgbGVnSGVpZ2h0IH06IHsgY29sdW1uczogSUNvbHVtbltdOyB0b3RhbEhlaWdodDogbnVtYmVyOyB0b3RhbFdpZHRoOiBudW1iZXI7IHRvdGFsRGVwdGg6IG51bWJlcjsgbGVnSGVpZ2h0OiBudW1iZXIgfSkge1xuICBjb25zdCB2ZXJ0aWNhbHM6IElQYXJ0aXRpb25bXSA9IFtdO1xuICBjb25zdCBob3Jpem9udGFsczogSVBhcnRpdGlvbltdID0gW107XG4gIGNvbnN0IGF2YWlsYWJsZVNwYWNlczogSVBhcnRpdGlvbltdID0gW107XG4gIGNvbnN0IGJhY2tzaWRlczogSVBhcnRpdGlvbltdID0gW107XG5cbiAgY29uc3Qgc3BhY2VIZWlnaHQgPSB0b3RhbEhlaWdodCAtIDIgKiBQTEFURV9USElDS05FU1MgLSBsZWdIZWlnaHQ7XG5cbiAgY29uc3QgcG9zWSA9ICh0b3RhbEhlaWdodCArIGxlZ0hlaWdodCkgLyAyO1xuXG4gIGNvbnN0IHN0YXJ0UG9zWCA9IC0odG90YWxXaWR0aCAtIFBMQVRFX1RISUNLTkVTUykgLyAyO1xuICBjb25zdCBib3R0b21Qb3NZID0gbGVnSGVpZ2h0ICsgUExBVEVfVEhJQ0tORVNTIC8gMjtcblxuICB2ZXJ0aWNhbHMucHVzaCh7XG4gICAgcm93OiAwLFxuICAgIGNvbDogLTEsXG4gICAgcG9zaXRpb246IHtcbiAgICAgIHg6IHN0YXJ0UG9zWCxcbiAgICAgIHk6IHBvc1ksXG4gICAgICB6OiAwLFxuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIHdpZHRoOiBzcGFjZUhlaWdodCxcbiAgICAgIGRlcHRoOiB0b3RhbERlcHRoLFxuICAgIH0sXG4gIH0pO1xuICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2x1bW5zLmxlbmd0aDsgY29sKyspIHtcbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2NvbF07XG4gICAgY29uc3Qgcm93cyA9IGNvbHVtbi5yb3dzO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sICsgMTsgaSsrKSB7XG4gICAgICBzdW0gKz0gY29sdW1uc1tpXS53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgcG9zWCA9IHN0YXJ0UG9zWCArIHN1bSArIChjb2wgKyAxKSAqIFBMQVRFX1RISUNLTkVTUztcbiAgICBjb25zdCBzcGFjZVBvc1ggPSBwb3NYIC0gUExBVEVfVEhJQ0tORVNTIC8gMiAtIGNvbHVtbi53aWR0aCAvIDI7XG5cbiAgICB2ZXJ0aWNhbHMucHVzaCh7XG4gICAgICByb3c6IDAsXG4gICAgICBjb2wsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBwb3NYLFxuICAgICAgICB5OiBwb3NZLFxuICAgICAgICB6OiAwLFxuICAgICAgfSxcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHdpZHRoOiBzcGFjZUhlaWdodCxcbiAgICAgICAgZGVwdGg6IHRvdGFsRGVwdGgsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXZhaWxhYmxlU3BhY2VzLnB1c2goe1xuICAgICAgcm93OiAwLFxuICAgICAgY29sLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogc3BhY2VQb3NYLFxuICAgICAgICB5OiBwb3NZLFxuICAgICAgICB6OiB0b3RhbERlcHRoIC8gMixcbiAgICAgIH0sXG4gICAgICBzY2FsZToge1xuICAgICAgICB3aWR0aDogY29sdW1uLndpZHRoLFxuICAgICAgICBkZXB0aDogc3BhY2VIZWlnaHQsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHJvd3MubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICBsZXQgdmVydGljYWxTdW0gPSAwO1xuICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCByb3dJbmRleCArIDE7IHArKykge1xuICAgICAgICB2ZXJ0aWNhbFN1bSArPSByb3dzW3Jvd0luZGV4XS5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pZGRsZVBvc1kgPSBib3R0b21Qb3NZICsgdmVydGljYWxTdW0gKyAocm93SW5kZXggKyAxKSAqIFBMQVRFX1RISUNLTkVTUztcblxuICAgICAgY29uc3QgYmFja1Bvc1kgPSBtaWRkbGVQb3NZIC0gUExBVEVfVEhJQ0tORVNTIC8gMiAtIHJvd3Nbcm93SW5kZXhdLmhlaWdodCAvIDI7XG4gICAgICBjb25zdCBiYWNrUG9zWiA9IC0odG90YWxEZXB0aCAtIFBMQVRFX1RISUNLTkVTUykgLyAyO1xuICAgICAgaWYgKHJvd0luZGV4IDwgcm93cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGhvcml6b250YWxzLnB1c2goe1xuICAgICAgICAgIHJvdzogcm93SW5kZXgsXG4gICAgICAgICAgY29sLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBzcGFjZVBvc1gsXG4gICAgICAgICAgICB5OiBtaWRkbGVQb3NZLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogY29sdW1uLndpZHRoLFxuICAgICAgICAgICAgZGVwdGg6IHRvdGFsRGVwdGggLSBFREdFX0dBUCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYmFja3NpZGVzLnB1c2goe1xuICAgICAgICByb3c6IHJvd0luZGV4LFxuICAgICAgICBjb2wsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogc3BhY2VQb3NYLFxuICAgICAgICAgIHk6IGJhY2tQb3NZLFxuICAgICAgICAgIHo6IGJhY2tQb3NaLFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZToge1xuICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGgsXG4gICAgICAgICAgZGVwdGg6IHJvd3Nbcm93SW5kZXhdLmhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVydGljYWxzLFxuICAgIGF2YWlsYWJsZVNwYWNlcyxcbiAgICBob3Jpem9udGFscyxcbiAgICBiYWNrc2lkZXMsXG4gIH07XG59XG5cbi8vIFVwZGF0ZSB0aGUgdHlwZSBkZWZpbml0aW9uIHRvIGluY2x1ZGUgY29sdW1uQ291bnRcbnR5cGUgVEdldENhbGN1bGF0ZWRDb2x1bW5zUHJvcHMgPSB7XG4gIGN1cnJlbnQ6IElDb2x1bW5bXTtcbiAgY2FiaW5ldFNpemU6IElDYWJpbmV0U2l6ZTtcbiAgY2FiaW5ldFN0eWxlOiBFQ2FiaW5ldFN0eWxlO1xuICBsZWdIZWlnaHQ6IG51bWJlcjtcbiAgY29sdW1uQ291bnQ/OiBudW1iZXI7IC8vIE1ha2UgaXQgb3B0aW9uYWxcbn07XG5cbi8vIEZpeCB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlXG5leHBvcnQgY29uc3QgZ2V0Q2FsY3VsYXRlZENvbHVtbnMgPSAoe1xuICBjdXJyZW50LFxuICBjYWJpbmV0U2l6ZSxcbiAgY2FiaW5ldFN0eWxlLFxuICBsZWdIZWlnaHQsXG4gIGNvbHVtbkNvdW50LFxufTogVEdldENhbGN1bGF0ZWRDb2x1bW5zUHJvcHMpOiBJQ29sdW1uW10gPT4ge1xuICBjb25zdCB7IHRvdGFsV2lkdGgsIHRvdGFsSGVpZ2h0LCB0b3RhbERlcHRoIH0gPSBjYWJpbmV0U2l6ZTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBhdmFpbGFibGUgd2lkdGggKHRvdGFsIHdpZHRoIG1pbnVzIHNpZGUgcGxhdGVzKVxuICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IHRvdGFsV2lkdGggLSAyICogUExBVEVfVEhJQ0tORVNTO1xuICBcbiAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IGNvbHVtbnMgY2FuIGZpdFxuICBsZXQgbnVtQ29sdW1ucztcbiAgaWYgKGNvbHVtbkNvdW50KSB7XG4gICAgbnVtQ29sdW1ucyA9IGNvbHVtbkNvdW50O1xuICB9IGVsc2Uge1xuICAgIC8vIENhbGN1bGF0ZSBiYXNlZCBvbiBtaW5pbXVtIGNvbHVtbiB3aWR0aFxuICAgIG51bUNvbHVtbnMgPSBNYXRoLmZsb29yKGF2YWlsYWJsZVdpZHRoIC8gKENFTExfU0laRS5taW5XaWR0aCArIFBMQVRFX1RISUNLTkVTUykpO1xuICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBvbmUgY29sdW1uXG4gICAgbnVtQ29sdW1ucyA9IE1hdGgubWF4KDEsIG51bUNvbHVtbnMpO1xuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgY29sdW1uIHdpZHRoXG4gIGNvbnN0IGNvbHVtbldpZHRoID0gKGF2YWlsYWJsZVdpZHRoIC0gKG51bUNvbHVtbnMgLSAxKSAqIFBMQVRFX1RISUNLTkVTUykgLyBudW1Db2x1bW5zO1xuICBcbiAgLy8gQ3JlYXRlIGNvbHVtbnMgYXJyYXlcbiAgY29uc3QgY29sdW1uczogSUNvbHVtbltdID0gW107XG4gIFxuICAvLyBHZW5lcmF0ZSBlYWNoIGNvbHVtblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvbHVtbnM7IGkrKykge1xuICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvblxuICAgIGNvbnN0IHBvc1ggPSAtdG90YWxXaWR0aCAvIDIgKyBQTEFURV9USElDS05FU1MgKyBpICogKGNvbHVtbldpZHRoICsgUExBVEVfVEhJQ0tORVNTKSArIGNvbHVtbldpZHRoIC8gMjtcbiAgICBcbiAgICAvLyBDcmVhdGUgY29sdW1uIHdpdGggYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgY29uc3QgY29sdW1uID0gY3JlYXRlQ29sdW1uV2l0aExheW91dChjb2x1bW5XaWR0aCwgcG9zWCwgdG90YWxIZWlnaHQsIGxlZ0hlaWdodCwgY2FiaW5ldFN0eWxlKTtcbiAgICBcbiAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgfVxuICBcbiAgcmV0dXJuIGNvbHVtbnM7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVtYWluaW5nQ29sdW1ucyhyZW1haW5pbmdXaWR0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGIgPSByZW1haW5pbmdXaWR0aCAlIDIgPT09IDAgPyByZW1haW5pbmdXaWR0aCAvIDIgOiAocmVtYWluaW5nV2lkdGggKyAxKSAvIDI7XG4gIGNvbnN0IGMgPSByZW1haW5pbmdXaWR0aCAtIGI7XG5cbiAgcmV0dXJuIFtiLCBjXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGl2aWR1YWxDb2x1bW4oe1xuICB0YXJnZXRJbmRleCxcbiAgY29sdW1ucyxcbiAgdG90YWxXaWR0aCxcbiAgdG90YWxEZXB0aCxcbiAgbGVnSGVpZ2h0LFxufToge1xuICB0YXJnZXRJbmRleDogbnVtYmVyO1xuICBjb2x1bW5zOiBJQ29sdW1uW107XG4gIHRvdGFsV2lkdGg6IG51bWJlcjtcbiAgdG90YWxEZXB0aDogbnVtYmVyO1xuICBsZWdIZWlnaHQ6IG51bWJlcjtcbn0pIHtcbiAgY29uc3QgY29sdW1uID0gY29sdW1uc1t0YXJnZXRJbmRleF07XG5cbiAgY29uc3Qgc3RhcnRQb3NYID0gLSh0b3RhbFdpZHRoIC0gUExBVEVfVEhJQ0tORVNTKSAvIDI7XG4gIGNvbnN0IGJvdHRvbVBvc1kgPSBsZWdIZWlnaHQgKyBQTEFURV9USElDS05FU1MgLyAyO1xuICBjb25zdCByb3dzUG9zID0gW107XG4gIGNvbnN0IGRlbHRhID0gMC4wMjtcbiAgY29uc3Qgcm93cyA9IGNvbHVtbi5yb3dzO1xuXG4gIGxldCBzdW0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEluZGV4ICsgMTsgaSsrKSB7XG4gICAgc3VtICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gIH1cbiAgY29uc3QgcG9zWCA9IHN0YXJ0UG9zWCArIHN1bSArICh0YXJnZXRJbmRleCArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuICBjb25zdCBzcGFjZVBvc1ggPSBwb3NYIC0gUExBVEVfVEhJQ0tORVNTIC8gMiAtIGNvbHVtbi53aWR0aCAvIDI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHZlcnRpY2FsU3VtID0gMDtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8IGkgKyAxOyBwKyspIHtcbiAgICAgIHZlcnRpY2FsU3VtICs9IHJvd3NbcF0uaGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBtaWRkbGVQb3NZID0gYm90dG9tUG9zWSArIHZlcnRpY2FsU3VtICsgKGkgKyAxKSAqIFBMQVRFX1RISUNLTkVTUztcbiAgICBjb25zdCBiYWNrUG9zWSA9IG1pZGRsZVBvc1kgLSBQTEFURV9USElDS05FU1MgLyAyIC0gcm93c1tpXS5oZWlnaHQgLyAyO1xuICAgIHJvd3NQb3MucHVzaCh7XG4gICAgICB4OiBzcGFjZVBvc1ggLSBjb2x1bW4ud2lkdGggLyAyLFxuICAgICAgeTogYmFja1Bvc1ksXG4gICAgICB6OiB0b3RhbERlcHRoIC8gMiArIGRlbHRhLFxuICAgICAgaGVpZ2h0OiByb3dzW2ldLmhlaWdodCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKHNwYWNlUG9zWCwgbGVnSGVpZ2h0ICsgUExBVEVfVEhJQ0tORVNTICsgZGVsdGEsIHRvdGFsRGVwdGggLyAyICsgZGVsdGEpLFxuICAgIHJvd3M6IHJvd3NQb3MsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRMYXlvdXRJbWFnZXMgPSAoeyB0b3RhbEhlaWdodCB9OiB7IHRvdGFsSGVpZ2h0OiBudW1iZXIgfSkgPT4ge1xuICBsZXQgaW1nc0FycmF5ID0gW107XG4gIGlmICh0b3RhbEhlaWdodCA8IDAuNTMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0NTNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAwLjYzKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDYzSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMC43Mykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQ3M0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDAuOTMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0OTNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAxLjAzKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDEwM0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDEuMjMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0MTIzSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMS4zMykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQxMzNJY29uc107XG4gIH0gZWxzZSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDE0M0ljb25zXTtcbiAgfVxuXG4gIHJldHVybiBpbWdzQXJyYXk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SWQgPSAoaXRlbTogc3RyaW5nKSA9PiBgJHtpdGVtfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKC00KX1gO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29sdW1uV2l0aExheW91dCA9IChjb2x1bW5XaWR0aDogbnVtYmVyLCBwb3NYOiBudW1iZXIsIHRvdGFsSGVpZ2h0OiBudW1iZXIsIGxlZ0hlaWdodDogbnVtYmVyLCBjYWJpbmV0U3R5bGU6IEVDYWJpbmV0U3R5bGUpOiBJQ29sdW1uID0+IHtcbiAgLy8gQ2FsY3VsYXRlIHRoZSBjYWJpbmV0IGhlaWdodCAoZXhjbHVkaW5nIGxlZ3MgYW5kIHBsYXRlIHRoaWNrbmVzcylcbiAgY29uc3QgY2FiaW5ldEhlaWdodCA9IHRvdGFsSGVpZ2h0IC0gbGVnSGVpZ2h0IC0gMiAqIFBMQVRFX1RISUNLTkVTUztcbiAgXG4gIC8vIEdldCB0aGUgYmFzaWMgdmVydGljYWwgbGF5b3V0IGZvciB0aGUgY29sdW1uXG4gIGNvbnN0IHJvd3MgPSBnZXRDb2x1bW5WZXJ0aWNhbExheW91dCh7IGNhYmluZXRIZWlnaHQgfSk7XG4gIFxuICAvLyBHZXQgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIFkgY29vcmRpbmF0ZVxuICBjb25zdCBzdGFydFBvc1kgPSBsZWdIZWlnaHQgKyBQTEFURV9USElDS05FU1M7XG4gIFxuICAvLyBEZWZhdWx0IHRvIGFuIGVtcHR5IGxheW91dCAod2lsbCBiZSBwb3B1bGF0ZWQgYmFzZWQgb24gc3R5bGUpXG4gIGxldCBsYXlvdXRJbmRleCA9IDA7XG4gIGxldCBkb29yczogYW55W10gPSBbXTtcbiAgbGV0IGRyYXdlcnM6IGFueVtdID0gW107XG4gIFxuICAvLyBCYXNlZCBvbiBjYWJpbmV0IHN0eWxlLCBjaG9vc2UgYW4gYXBwcm9wcmlhdGUgbGF5b3V0XG4gIHN3aXRjaCAoY2FiaW5ldFN0eWxlKSB7XG4gICAgY2FzZSBFQ2FiaW5ldFN0eWxlLk1vZGVybjpcbiAgICAgIC8vIEZvciBtb2Rlcm4gc3R5bGUsIHVzZSBhbGwgZHJhd2Vyc1xuICAgICAgbGF5b3V0SW5kZXggPSAxO1xuICAgICAgLy8gQ3JlYXRlIGEgZHJhd2VyIGZvciBlYWNoIHJvd1xuICAgICAgZHJhd2VycyA9IHJvd3MubWFwKChyb3csIGluZGV4KSA9PiAoe1xuICAgICAgICBpbmRleCxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHJvdy5oZWlnaHQsXG4gICAgICAgIH0sXG4gICAgICAgIHBvczoge1xuICAgICAgICAgIHg6IHBvc1gsXG4gICAgICAgICAgeTogc3RhcnRQb3NZICsgKGluZGV4ICsgMC41KSAqIHJvdy5oZWlnaHQgKyBpbmRleCAqIFBMQVRFX1RISUNLTkVTUyxcbiAgICAgICAgfSxcbiAgICAgIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgICAgXG4gICAgY2FzZSBFQ2FiaW5ldFN0eWxlLkNsYXNzaWM6XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBjbGFzc2ljIHN0eWxlLCB1c2UgZG9vcnMgZm9yIGFsbCByb3dzXG4gICAgICBsYXlvdXRJbmRleCA9IDA7XG4gICAgICAvLyBDcmVhdGUgYSBkb29yIGZvciB0aGUgZnVsbCBoZWlnaHRcbiAgICAgIGRvb3JzID0gW3tcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjYWJpbmV0SGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgICBwb3M6IHtcbiAgICAgICAgICB4OiBwb3NYLFxuICAgICAgICAgIHk6IHN0YXJ0UG9zWSArIGNhYmluZXRIZWlnaHQgLyAyLFxuICAgICAgICB9LFxuICAgICAgICBvcGVuaW5nOiAxLCAvLyBEZWZhdWx0IG9wZW5pbmcgZGlyZWN0aW9uXG4gICAgICB9XTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICAvLyBDcmVhdGUgYW5kIHJldHVybiB0aGUgY29sdW1uIG9iamVjdFxuICByZXR1cm4ge1xuICAgIGluZGV4OiAwLCAvLyBXaWxsIGJlIHVwZGF0ZWQgd2hlbiBhbGwgY29sdW1ucyBhcmUgY3JlYXRlZFxuICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICBwb3NYOiBwb3NYLFxuICAgIHJvd3M6IHJvd3MsXG4gICAgZG9vcnM6IGRvb3JzLFxuICAgIGRyYXdlcnM6IGRyYXdlcnMsXG4gICAgZGl2aWRlcnM6IFtdLFxuICAgIGxheW91dEluZGV4OiBsYXlvdXRJbmRleCxcbiAgICBpc0RpdmlkZTogZmFsc2UsXG4gICAgbGFzdFJvdzogZHJhd2Vycy5sZW5ndGggPiAwID8gJ2RyYXdlcicgOiAnZG9vcicsXG4gIH07XG59O1xuXG4vLyBVcGRhdGUgdGhlIGNhYmluZXQgc2l6ZSBjb25zdHJhaW50c1xuZXhwb3J0IGNvbnN0IENBQklORVRfU0laRV9DT05TVFJBSU5UUyA9IHtcbiAgbWluV2lkdGg6IDAuNCwgLy8gNDBjbSBpbiBtZXRlcnNcbiAgbWF4V2lkdGg6IDIuNSwgLy8gMjUwY20gaW4gbWV0ZXJzIChjaGFuZ2VkIGZyb20gNC41bS80NTBjbSlcbiAgbWluSGVpZ2h0OiAwLjQsIC8vIDQwY20gaW4gbWV0ZXJzXG4gIG1heEhlaWdodDogMi40LCAvLyAyNDBjbSBpbiBtZXRlcnNcbiAgbWluRGVwdGg6IDAuMywgLy8gMzBjbSBpbiBtZXRlcnNcbiAgbWF4RGVwdGg6IDAuOCwgLy8gODBjbSBpbiBtZXRlcnNcbn07XG5cbmV4cG9ydCBjb25zdCBhcHBseVJhbmRvbUxheW91dHNUb0NvbHVtbnMgPSAoY29sdW1uczogSUNvbHVtbltdLCB0b3RhbEhlaWdodDogbnVtYmVyLCBsZWdIZWlnaHQ6IG51bWJlcik6IElDb2x1bW5bXSA9PiB7XG4gIGNvbnN0IHN0YXJ0UG9zWSA9IGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUztcbiAgXG4gIHJldHVybiBjb2x1bW5zLm1hcChjb2x1bW4gPT4ge1xuICAgIC8vIEdldCBhbGwgYXZhaWxhYmxlIGxheW91dCBvcHRpb25zIGZvciB0aGlzIGNvbHVtblxuICAgIGNvbnN0IGxheW91dE9wdGlvbnMgPSBnZXRMYXlvdXRPcHRpb25zT2ZDb2x1bW4oeyBcbiAgICAgIHRvdGFsSGVpZ2h0LCBcbiAgICAgIGxlZ0hlaWdodCwgXG4gICAgICBjb2x1bW5XaWR0aDogY29sdW1uLndpZHRoLCBcbiAgICAgIHBvc1g6IGNvbHVtbi5wb3NYLCBcbiAgICAgIHN0YXJ0UG9zWSxcbiAgICAgIGRvb3JEaXI6IDEgLy8gRGVmYXVsdCBkb29yIG9wZW5pbmcgZGlyZWN0aW9uXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2VsZWN0IGEgcmFuZG9tIGxheW91dCBvcHRpb25cbiAgICBjb25zdCByYW5kb21MYXlvdXRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxheW91dE9wdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCByYW5kb21MYXlvdXQgPSBsYXlvdXRPcHRpb25zW3JhbmRvbUxheW91dEluZGV4XTtcbiAgICBcbiAgICAvLyBBcHBseSB0aGUgcmFuZG9tIGxheW91dCB0byB0aGUgY29sdW1uXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbHVtbixcbiAgICAgIGxheW91dEluZGV4OiByYW5kb21MYXlvdXRJbmRleCxcbiAgICAgIHJvd3M6IHJhbmRvbUxheW91dC5yb3dzLFxuICAgICAgZG9vcnM6IHJhbmRvbUxheW91dC5kb29ycyxcbiAgICAgIGRyYXdlcnM6IHJhbmRvbUxheW91dC5kcmF3ZXJzLFxuICAgICAgbGFzdFJvdzogcmFuZG9tTGF5b3V0Lmxhc3RSb3dcbiAgICB9O1xuICB9KTtcbn07XG4iXSwibmFtZXMiOlsiVEhSRUUiLCJnZXRMYXlvdXRPcHRpb25zT2ZDb2x1bW4iLCJQTEFURV9USElDS05FU1MiLCJDRUxMX1NJWkUiLCJtYXhXaWR0aCIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwibWluSGVpZ2h0IiwiTEVHX0hFSUdIVCIsIkxFR19XSURUSCIsIkxFR19ERVBUSCIsIkVER0VfR0FQIiwid2FsbENvbG9yIiwiZmxvb3JDb2xvciIsImFtYmllbnRMaWdodENvbG9yIiwiZGlyZWN0aW9uYWxMaWdodENvbG9yIiwidGV4dHVyZXNSb290UGF0aCIsImVudmlyb25tZW50UGF0aCIsInBseXdvb2RSb290UGF0aCIsInBseXdvb2RBb01hcFBhdGgiLCJwbHl3b29kTm9ybWFsTWFwUGF0aCIsInBseXdvb2RSb3VnaG5lc3NNYXBQYXRoIiwicGx5d29vZFRleHR1cmVzIiwiYW9NYXAiLCJub3JtYWxNYXAiLCJyb3VnaG5lc3NNYXAiLCJ3b29kUm9vdFBhdGgiLCJ2ZW5lZXJBb01hcFBhdGgiLCJ2ZW5lZXJOb3JtYWxNYXBQYXRoIiwidmVuZWVyUm91Z2huZXNzTWFwUGF0aCIsInZlbmVlclRleHR1cmVzIiwiRVZlbmVlclRleHR1cmVzIiwiRVBseXdvb2RUZXh0dXJlcyIsImhvcml6b250YWxPY2NsdXNpb25UZXh0dXJlUGF0aCIsInZlcnRpY2FsT2NjbHVzaW9uVGV4dHVyZVBhdGgiLCJiYWNrT2NjbHVzaW9uVGV4dHVyZVBhdGgiLCJFT2NjbHVzaW9uSW1hZ2VzIiwibGF5b3V0SWNvblJvb3RQYXRoIiwiaWNvbmlmeUljb25zIiwibGF5b3V0SWNvbnMiLCJ1bmRvSWNvbiIsImRpbWVuc2lvbnNJY29uIiwiZG9vcnNJY29uIiwiYWxpZ25Db2x1bW5zSWNvbiIsInNob3dEZWNvcmF0aW9uc0ljb24iLCJhc3NlbWJseUljb24iLCJtZW51SWNvbnMiLCJhcnJvd1VwIiwiYXJyb3dEb3duIiwiaW5mb1F1ZXN0aW9uIiwic2NlbmVJY29ucyIsImVkaXRMYXlvdXQiLCJtZW51SWNvblBhdGhzIiwibGVncyIsIm5vX2xlZyIsImZsb2F0aW5nIiwiaGFuZGxlcyIsImhhbmRsZV9hIiwiaGFuZGxlX2IiLCJwdXNoIiwic3R5bGVzIiwiZnJhbWUiLCJncmFkaWVudCIsImdyaWQiLCJtb3NhaWMiLCJwaXhlbCIsInNsYW50IiwiZ2VuZXJhdGVMYXlvdXRJY29ucyIsImxheW91dEhlaWdodCIsImljb25Db3VudCIsImxheW91dFJvb3RQYXRoIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJsYXlvdXQ1M0ljb25zIiwibGF5b3V0NjNJY29ucyIsImxheW91dDczSWNvbnMiLCJsYXlvdXQ5M0ljb25zIiwibGF5b3V0MTAzSWNvbnMiLCJsYXlvdXQxMjNJY29ucyIsImxheW91dDEzM0ljb25zIiwibGF5b3V0MTQzSWNvbnMiLCJtb2RlbHNSb290UGF0aCIsInNoYWRvd01hbk1vZGVsUGF0aCIsImhhbmRsZUFNb2RlbFBhdGgiLCJoYW5kbGVCTW9kZWxQYXRoIiwibGVnc01vZGVsUGF0aCIsIm5vTGVnc01vZGVsUGF0aCIsInR2TW9kZWxQYXRoIiwiRUNhYmluZXRTdHlsZSIsIkVDYWJpbmV0TGVncyIsIkVDYWJpbmV0SGFuZGxlcyIsIkVDYWJpbmV0RmluaXNoZXMiLCJnZXRXaWR0aEFycmF5Iiwic3R5bGUiLCJ0b3RhbFdpZHRoIiwid2lkdGhBcnJheSIsInVuaXQiLCJnZXRSZW1haW5pbmdDb2x1bW5zIiwiZ2V0Q29sdW1uVmVydGljYWxMYXlvdXQiLCJjYWJpbmV0SGVpZ2h0IiwiY3VycmVudGxheW91dCIsIm51bWJlck9mUm93cyIsImdldFJvd0NvdW50IiwiaW5kZXgiLCJoZWlnaHQiLCJnZXRDZWxsSGVpZ2h0IiwiZ2V0RGlzdGFuY2UiLCJwMSIsInAyIiwiTWF0aCIsInNxcnQiLCJ4IiwieiIsImZsb29yIiwiZ2V0Q29sdW1uQ291bnQiLCJudW1iZXJPZkNvbHVtbnMiLCJzdW0iLCJ3aWR0aE9mQ2VsbCIsInJvdW5kIiwicm93Q291bnQiLCJjZWxsSGVpZ2h0IiwiZ2V0Q2VsbFdpZHRoIiwiY29sdW1uQ291bnQiLCJjZWxsV2lkdGgiLCJnZXRCb3R0b21IZWlnaHQiLCJnZXRQYXJ0aXRvblBsYXRlcyIsImNvbHVtbnMiLCJ0b3RhbEhlaWdodCIsInRvdGFsRGVwdGgiLCJsZWdIZWlnaHQiLCJ2ZXJ0aWNhbHMiLCJob3Jpem9udGFscyIsImF2YWlsYWJsZVNwYWNlcyIsImJhY2tzaWRlcyIsInNwYWNlSGVpZ2h0IiwicG9zWSIsInN0YXJ0UG9zWCIsImJvdHRvbVBvc1kiLCJyb3ciLCJjb2wiLCJwb3NpdGlvbiIsInkiLCJzY2FsZSIsIndpZHRoIiwiZGVwdGgiLCJjb2x1bW4iLCJyb3dzIiwicG9zWCIsInNwYWNlUG9zWCIsInJvd0luZGV4IiwidmVydGljYWxTdW0iLCJwIiwibWlkZGxlUG9zWSIsImJhY2tQb3NZIiwiYmFja1Bvc1oiLCJnZXRDYWxjdWxhdGVkQ29sdW1ucyIsImN1cnJlbnQiLCJjYWJpbmV0U2l6ZSIsImNhYmluZXRTdHlsZSIsImF2YWlsYWJsZVdpZHRoIiwibnVtQ29sdW1ucyIsIm1heCIsImNvbHVtbldpZHRoIiwiY3JlYXRlQ29sdW1uV2l0aExheW91dCIsInJlbWFpbmluZ1dpZHRoIiwiYiIsImMiLCJnZXRJbmRpdmlkdWFsQ29sdW1uIiwidGFyZ2V0SW5kZXgiLCJyb3dzUG9zIiwiZGVsdGEiLCJWZWN0b3IzIiwiZ2V0TGF5b3V0SW1hZ2VzIiwiaW1nc0FycmF5IiwiZ2V0SWQiLCJpdGVtIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsInN0YXJ0UG9zWSIsImxheW91dEluZGV4IiwiZG9vcnMiLCJkcmF3ZXJzIiwiTW9kZXJuIiwibWFwIiwic2l6ZSIsInBvcyIsIkNsYXNzaWMiLCJvcGVuaW5nIiwiZGl2aWRlcnMiLCJpc0RpdmlkZSIsImxhc3RSb3ciLCJDQUJJTkVUX1NJWkVfQ09OU1RSQUlOVFMiLCJtaW5EZXB0aCIsIm1heERlcHRoIiwiYXBwbHlSYW5kb21MYXlvdXRzVG9Db2x1bW5zIiwibGF5b3V0T3B0aW9ucyIsImRvb3JEaXIiLCJyYW5kb21MYXlvdXRJbmRleCIsInJhbmRvbUxheW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/utilities.ts\n"));

/***/ })

});