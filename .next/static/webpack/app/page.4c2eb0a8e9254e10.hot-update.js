"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/utilities.ts":
/*!********************************!*\
  !*** ./src/utils/utilities.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CABINET_SIZE_CONSTRAINTS: function() { return /* binding */ CABINET_SIZE_CONSTRAINTS; },\n/* harmony export */   CELL_SIZE: function() { return /* binding */ CELL_SIZE; },\n/* harmony export */   ECabinetFinishes: function() { return /* binding */ ECabinetFinishes; },\n/* harmony export */   ECabinetHandles: function() { return /* binding */ ECabinetHandles; },\n/* harmony export */   ECabinetLegs: function() { return /* binding */ ECabinetLegs; },\n/* harmony export */   ECabinetStyle: function() { return /* binding */ ECabinetStyle; },\n/* harmony export */   EDGE_GAP: function() { return /* binding */ EDGE_GAP; },\n/* harmony export */   EOcclusionImages: function() { return /* binding */ EOcclusionImages; },\n/* harmony export */   EPlywoodTextures: function() { return /* binding */ EPlywoodTextures; },\n/* harmony export */   EVeneerTextures: function() { return /* binding */ EVeneerTextures; },\n/* harmony export */   LEG_DEPTH: function() { return /* binding */ LEG_DEPTH; },\n/* harmony export */   LEG_HEIGHT: function() { return /* binding */ LEG_HEIGHT; },\n/* harmony export */   LEG_WIDTH: function() { return /* binding */ LEG_WIDTH; },\n/* harmony export */   PLATE_THICKNESS: function() { return /* binding */ PLATE_THICKNESS; },\n/* harmony export */   ambientLightColor: function() { return /* binding */ ambientLightColor; },\n/* harmony export */   applyRandomLayoutsToColumns: function() { return /* binding */ applyRandomLayoutsToColumns; },\n/* harmony export */   backOcclusionTexturePath: function() { return /* binding */ backOcclusionTexturePath; },\n/* harmony export */   createColumnWithLayout: function() { return /* binding */ createColumnWithLayout; },\n/* harmony export */   directionalLightColor: function() { return /* binding */ directionalLightColor; },\n/* harmony export */   environmentPath: function() { return /* binding */ environmentPath; },\n/* harmony export */   floorColor: function() { return /* binding */ floorColor; },\n/* harmony export */   getBottomHeight: function() { return /* binding */ getBottomHeight; },\n/* harmony export */   getCalculatedColumns: function() { return /* binding */ getCalculatedColumns; },\n/* harmony export */   getCellHeight: function() { return /* binding */ getCellHeight; },\n/* harmony export */   getCellWidth: function() { return /* binding */ getCellWidth; },\n/* harmony export */   getColumnCount: function() { return /* binding */ getColumnCount; },\n/* harmony export */   getColumnVerticalLayout: function() { return /* binding */ getColumnVerticalLayout; },\n/* harmony export */   getDistance: function() { return /* binding */ getDistance; },\n/* harmony export */   getId: function() { return /* binding */ getId; },\n/* harmony export */   getIndividualColumn: function() { return /* binding */ getIndividualColumn; },\n/* harmony export */   getLayoutImages: function() { return /* binding */ getLayoutImages; },\n/* harmony export */   getPartitonPlates: function() { return /* binding */ getPartitonPlates; },\n/* harmony export */   getRemainingColumns: function() { return /* binding */ getRemainingColumns; },\n/* harmony export */   getRowCount: function() { return /* binding */ getRowCount; },\n/* harmony export */   getWidthArray: function() { return /* binding */ getWidthArray; },\n/* harmony export */   handleAModelPath: function() { return /* binding */ handleAModelPath; },\n/* harmony export */   handleBModelPath: function() { return /* binding */ handleBModelPath; },\n/* harmony export */   horizontalOcclusionTexturePath: function() { return /* binding */ horizontalOcclusionTexturePath; },\n/* harmony export */   iconifyIcons: function() { return /* binding */ iconifyIcons; },\n/* harmony export */   legsModelPath: function() { return /* binding */ legsModelPath; },\n/* harmony export */   menuIconPaths: function() { return /* binding */ menuIconPaths; },\n/* harmony export */   noLegsModelPath: function() { return /* binding */ noLegsModelPath; },\n/* harmony export */   plywoodTextures: function() { return /* binding */ plywoodTextures; },\n/* harmony export */   shadowManModelPath: function() { return /* binding */ shadowManModelPath; },\n/* harmony export */   tvModelPath: function() { return /* binding */ tvModelPath; },\n/* harmony export */   veneerTextures: function() { return /* binding */ veneerTextures; },\n/* harmony export */   verticalOcclusionTexturePath: function() { return /* binding */ verticalOcclusionTexturePath; },\n/* harmony export */   wallColor: function() { return /* binding */ wallColor; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./columnLayoutOptions */ \"(app-pages-browser)/./src/utils/columnLayoutOptions.ts\");\n\n\n//--- CONSTANTS\n// Dimensions\nconst PLATE_THICKNESS = 0.02;\nconst CELL_SIZE = {\n    maxWidth: 0.60,\n    minWidth: 0.25,\n    maxHeight: 0.35,\n    minHeight: 0.15\n};\nconst LEG_HEIGHT = 0.18;\nconst LEG_WIDTH = 0.05;\nconst LEG_DEPTH = 0.05;\nconst EDGE_GAP = 0.006;\n// Colors\nconst wallColor = \"#e7e7e7\";\nconst floorColor = \"#b7b7b7\";\nconst ambientLightColor = \"#f0f0f0\";\nconst directionalLightColor = \"#f0f0f0\";\n// Texture paths\nconst texturesRootPath = \"/assets/textures/\";\nconst environmentPath = texturesRootPath + \"environment.hdr\";\nconst plywoodRootPath = texturesRootPath + \"plywood_1k/textures/\";\nconst plywoodAoMapPath = plywoodRootPath + \"plywood_ao_1k.jpg\";\nconst plywoodNormalMapPath = plywoodRootPath + \"plywood_nor_gl_1k.jpg\";\nconst plywoodRoughnessMapPath = plywoodRootPath + \"plywood_rough_1k.jpg\";\nconst plywoodTextures = {\n    aoMap: plywoodAoMapPath,\n    normalMap: plywoodNormalMapPath,\n    roughnessMap: plywoodRoughnessMapPath\n};\n// Base Textures Veener\nconst woodRootPath = texturesRootPath + \"wood_27/\";\nconst veneerAoMapPath = woodRootPath + \"ambient-occlusion.jpg\";\nconst veneerNormalMapPath = woodRootPath + \"normal.jpg\";\nconst veneerRoughnessMapPath = woodRootPath + \"roughness.jpg\";\nconst veneerTextures = {\n    aoMap: veneerAoMapPath,\n    normalMap: veneerNormalMapPath,\n    roughnessMap: veneerRoughnessMapPath\n};\nvar EVeneerTextures;\n(function(EVeneerTextures) {\n    EVeneerTextures[EVeneerTextures[\"BEIGE_GREY_LORENZO_OAK\"] = texturesRootPath + \"veneer-oak-wood/beige_grey_lorenzo_oak.jpg\"] = \"BEIGE_GREY_LORENZO_OAK\";\n    // BEIGE_TEXTILE = texturesRootPath + 'veneer-oak-wood/beige_textile.jpg',\n    EVeneerTextures[EVeneerTextures[\"BROWN_ABANO_ASH\"] = texturesRootPath + \"veneer-oak-wood/brown_abano_ash.jpg\"] = \"BROWN_ABANO_ASH\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_HALIFAX_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_halifax_oak.jpg\"] = \"BROWN_HALIFAX_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_TONNSBERG_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_tonnsberg_oak.jpg\"] = \"BROWN_TONNSBERG_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_WARMIA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/brown_warmia_wallnut.jpg\"] = \"BROWN_WARMIA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_BARONIA_OAK\"] = texturesRootPath + \"veneer-oak-wood/light_baronia_oak.jpg\"] = \"LIGHT_BARONIA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_NATURAL_DAVENPORT_OAK\"] = texturesRootPath + \"veneer-oak-wood/Light_Natural_Davenport_oak.jpg\"] = \"LIGHT_NATURAL_DAVENPORT_OAK\";\n    EVeneerTextures[EVeneerTextures[\"NATURAL_CASELLA_OAK\"] = texturesRootPath + \"veneer-oak-wood/natural_casella_oak.jpg\"] = \"NATURAL_CASELLA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"PARONA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/parona_wallnut.jpg\"] = \"PARONA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"SEVILLA_ASH\"] = texturesRootPath + \"veneer-oak-wood/sevilla_ash.jpg\"] = \"SEVILLA_ASH\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak.jpg\"] = \"VICENZA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK_2\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak2.jpg\"] = \"VICENZA_OAK_2\";\n})(EVeneerTextures || (EVeneerTextures = {}));\nvar EPlywoodTextures;\n(function(EPlywoodTextures) {\n    EPlywoodTextures[EPlywoodTextures[\"BRONZE_BRUSHED_METAL\"] = texturesRootPath + \"plywood-colors/bronze_brushed_metal.jpg\"] = \"BRONZE_BRUSHED_METAL\";\n    EPlywoodTextures[EPlywoodTextures[\"ALMOND_BEIGE\"] = texturesRootPath + \"plywood-colors/almond_beige.jpg\"] = \"ALMOND_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CARAT_BEIGE\"] = texturesRootPath + \"plywood-colors/carat_beige.jpg\"] = \"CARAT_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CASHMERE_GREY\"] = texturesRootPath + \"plywood-colors/cashmere_grey.jpg\"] = \"CASHMERE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"CORA_BRONZE\"] = texturesRootPath + \"plywood-colors/cobra_bronze.jpg\"] = \"CORA_BRONZE\";\n    EPlywoodTextures[EPlywoodTextures[\"CUBANITE_GREY\"] = texturesRootPath + \"plywood-colors/cubanite_grey.jpg\"] = \"CUBANITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"FIR_GREEN\"] = texturesRootPath + \"plywood-colors/fir_green.jpg\"] = \"FIR_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"FJORD_GREEN\"] = texturesRootPath + \"plywood-colors/fjord_green.jpg\"] = \"FJORD_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"GRAPHITE_GREY\"] = texturesRootPath + \"plywood-colors/graphite_grey.jpg\"] = \"GRAPHITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"INDIGO_BLUE\"] = texturesRootPath + \"plywood-colors/indigo_blue.jpg\"] = \"INDIGO_BLUE\";\n    EPlywoodTextures[EPlywoodTextures[\"REED_GREEN\"] = texturesRootPath + \"plywood-colors/reed_green.jpg\"] = \"REED_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"SAGE_GREEN\"] = texturesRootPath + \"plywood-colors/sage_green.jpg\"] = \"SAGE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"STONE_GREEN\"] = texturesRootPath + \"plywood-colors/stone_green.jpg\"] = \"STONE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"TAUPE_GREY\"] = texturesRootPath + \"plywood-colors/taupe_grey.jpg\"] = \"TAUPE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"TRUFFLE_BROWN\"] = texturesRootPath + \"plywood-colors/truffle_brown.jpg\"] = \"TRUFFLE_BROWN\";\n    EPlywoodTextures[EPlywoodTextures[\"U999_PM_BLACK\"] = texturesRootPath + \"plywood-colors/U999_PM_Black.jpg\"] = \"U999_PM_BLACK\";\n})(EPlywoodTextures || (EPlywoodTextures = {}));\n// Occlusion Textures\nconst horizontalOcclusionTexturePath = texturesRootPath + \"horizontal-panel.jpg\";\nconst verticalOcclusionTexturePath = texturesRootPath + \"vertical-panel.jpg\";\nconst backOcclusionTexturePath = texturesRootPath + \"back-panel.jpg\";\nvar EOcclusionImages;\n(function(EOcclusionImages) {\n    EOcclusionImages[EOcclusionImages[\"HORIZONTAL\"] = horizontalOcclusionTexturePath] = \"HORIZONTAL\";\n    EOcclusionImages[EOcclusionImages[\"BACK\"] = verticalOcclusionTexturePath] = \"BACK\";\n    EOcclusionImages[EOcclusionImages[\"VERTICAL\"] = backOcclusionTexturePath] = \"VERTICAL\";\n})(EOcclusionImages || (EOcclusionImages = {}));\n// Layout Icons\nconst layoutIconRootPath = \"/assets/icons/on-model-editor/\";\nconst iconifyIcons = {\n    layoutIcons: {\n        undoIcon: \"solar:undo-left-round-outline\",\n        dimensionsIcon: \"solar:ruler-linear\",\n        doorsIcon: \"fluent:door-20-regular\",\n        alignColumnsIcon: \"flowbite:grid-plus-outline\",\n        showDecorationsIcon: \"hugeicons:paint-brush-02\",\n        assemblyIcon: \"carbon:3d-cursor\"\n    },\n    menuIcons: {\n        arrowUp: \"iwwa:arrow-up\",\n        arrowDown: \"iwwa:arrow-down\",\n        infoQuestion: \"ph:question-bold\"\n    },\n    sceneIcons: {\n        editLayout: \"ic-outline-create\"\n    }\n};\nconst menuIconPaths = {\n    legs: {\n        no_leg: \"/assets/icons/menu-icons/legs/no_leg.svg\",\n        legs: \"/assets/icons/menu-icons/legs/legs.svg\",\n        floating: \"/assets/icons/menu-icons/legs/floating.svg\"\n    },\n    handles: {\n        handle_a: \"/assets/icons/menu-icons/handles/handle_A.svg\",\n        handle_b: \"/assets/icons/menu-icons/handles/handle_B.svg\",\n        push: \"/assets/icons/menu-icons/handles/push.svg\"\n    },\n    styles: {\n        frame: \"/assets/icons/menu-icons/styles/frame.svg\",\n        gradient: \"/assets/icons/menu-icons/styles/gradient.svg\",\n        grid: \"/assets/icons/menu-icons/styles/grid.svg\",\n        mosaic: \"/assets/icons/menu-icons/styles/mosaic.svg\",\n        pixel: \"/assets/icons/menu-icons/styles/pixel.svg\",\n        slant: \"/assets/icons/menu-icons/styles/slant.svg\"\n    }\n};\nconst generateLayoutIcons = (layoutHeight, iconCount)=>{\n    const layoutRootPath = \"\".concat(layoutIconRootPath).concat(layoutHeight, \"/\");\n    return Array.from({\n        length: iconCount\n    }, (_, i)=>\"\".concat(layoutRootPath).concat(i + 1, \".svg\"));\n};\n// Generating icon paths for each layout\nconst layout53Icons = generateLayoutIcons(53, 3);\nconst layout63Icons = generateLayoutIcons(63, 6);\nconst layout73Icons = generateLayoutIcons(73, 7);\nconst layout93Icons = generateLayoutIcons(93, 8);\nconst layout103Icons = generateLayoutIcons(103, 8);\nconst layout123Icons = generateLayoutIcons(123, 8);\nconst layout133Icons = generateLayoutIcons(133, 6); // Adjusted for 6 icons only\nconst layout143Icons = generateLayoutIcons(143, 6);\n// Model Paths\nconst modelsRootPath = \"/assets/models/\";\nconst shadowManModelPath = modelsRootPath + \"shadow_man.glb\";\nconst handleAModelPath = modelsRootPath + \"handle_A.glb\";\nconst handleBModelPath = modelsRootPath + \"handle_B.glb\";\nconst legsModelPath = modelsRootPath + \"legs.glb\";\nconst noLegsModelPath = modelsRootPath + \"no_legs.glb\";\nconst tvModelPath = modelsRootPath + \"tv.glb\";\nvar ECabinetStyle;\n(function(ECabinetStyle) {\n    ECabinetStyle[\"GRID\"] = \"grid\";\n    ECabinetStyle[\"GRADIENT\"] = \"gradient\";\n    ECabinetStyle[\"MOSAIC\"] = \"mosaic\";\n    ECabinetStyle[\"FRAME\"] = \"frame\";\n    ECabinetStyle[\"SLANT\"] = \"slant\";\n    ECabinetStyle[\"PIXEL\"] = \"pixel\";\n})(ECabinetStyle || (ECabinetStyle = {}));\nvar ECabinetLegs;\n(function(ECabinetLegs) {\n    ECabinetLegs[\"LEGS\"] = \"LEGS\";\n    ECabinetLegs[\"NO_LEG\"] = \"NO_LEG\";\n    ECabinetLegs[\"FLOATING\"] = \"FLOATING\";\n})(ECabinetLegs || (ECabinetLegs = {}));\nvar ECabinetHandles;\n(function(ECabinetHandles) {\n    ECabinetHandles[\"HANDLE_A\"] = \"HANDLE_A\";\n    ECabinetHandles[\"HANDLE_B\"] = \"HANDLE_B\";\n    ECabinetHandles[\"PUSH\"] = \"PUSH\";\n})(ECabinetHandles || (ECabinetHandles = {}));\nvar ECabinetFinishes;\n(function(ECabinetFinishes) {\n    ECabinetFinishes[\"PLYWOOD\"] = \"Plywood\";\n    ECabinetFinishes[\"VENEER\"] = \"Veneer\";\n})(ECabinetFinishes || (ECabinetFinishes = {}));\n// Functions\n// Get the array of remaining columns widths\nconst getWidthArray = (style, totalWidth)=>{\n    let widthArray = [];\n    const unit = 100;\n    switch(style){\n        case \"grid\":\n            if (totalWidth < CELL_SIZE.maxWidth * unit) {\n                widthArray = [\n                    totalWidth - 2 * PLATE_THICKNESS * unit\n                ];\n            } else if (totalWidth < 112) {\n                widthArray = getRemainingColumns(totalWidth - 3 * PLATE_THICKNESS * unit);\n            } else if (totalWidth < 154) {\n                widthArray = [\n                    44\n                ];\n            } else if (totalWidth < 197) {\n                widthArray = [\n                    44,\n                    38\n                ];\n            } else if (totalWidth < 243) {\n                widthArray = [\n                    44,\n                    38,\n                    44\n                ];\n            } else if (totalWidth < 282) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37\n                ];\n            } else if (totalWidth < 327) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43\n                ];\n            } else if (totalWidth < 372) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43\n                ];\n            } else if (totalWidth < 412) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38\n                ];\n            } else {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38,\n                    44\n                ];\n            }\n            break;\n        default:\n            break;\n    }\n    return widthArray;\n};\n// Get the vertical layout of a column for a given cabinet height\nconst getColumnVerticalLayout = (param)=>{\n    let { cabinetHeight } = param;\n    const currentlayout = [];\n    const numberOfRows = getRowCount({\n        cabinetHeight\n    });\n    for(let i = 0; i < numberOfRows; i++){\n        currentlayout.push({\n            index: i,\n            height: getCellHeight(numberOfRows, cabinetHeight)\n        });\n    }\n    return currentlayout;\n};\n// Get the distance between two Vector3s\nfunction getDistance(p1, p2) {\n    // return the square root of the sum of the squares of the differences of the x and z coordinates\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.z - p1.z) ** 2);\n}\n// Get the count of rows for a given cabinet height\nfunction getRowCount(param) {\n    let { cabinetHeight } = param;\n    // Get the maximum height of a cell\n    const maxHeight = CELL_SIZE.maxHeight;\n    // Return the number of rows\n    return Math.floor((cabinetHeight - PLATE_THICKNESS) / (maxHeight + PLATE_THICKNESS)) + 1;\n}\n// Get the number of columns and the width of a cell for a given total width\nfunction getColumnCount(param) {\n    let { totalWidth } = param;\n    // Get the maximum width of a cell\n    const maxWidth = CELL_SIZE.maxWidth;\n    // Get the number of columns according to the total width\n    const numberOfColumns = Math.floor((totalWidth - PLATE_THICKNESS) / (maxWidth + PLATE_THICKNESS)) + 1;\n    // Get the total width of cells without\n    const sum = totalWidth - (numberOfColumns + 1) * PLATE_THICKNESS;\n    // Round to 2 decimal places\n    const widthOfCell = Math.round(sum / numberOfColumns * 100) / 100;\n    return {\n        numberOfColumns,\n        widthOfCell\n    };\n}\n// Get the height of a cell for a given number of rows and a cabinet height\nfunction getCellHeight(rowCount, cabinetHeight) {\n    // Get the height of a cell\n    const cellHeight = (cabinetHeight - (rowCount - 1) * PLATE_THICKNESS) / rowCount;\n    return cellHeight;\n}\n// Get the width of a cell for a given number of columns and a total width\nfunction getCellWidth(columnCount, totalWidth) {\n    // Get the width of a cell\n    const cellWidth = (totalWidth - (columnCount + 1) * PLATE_THICKNESS) / columnCount;\n    return cellWidth;\n}\nfunction getBottomHeight(legs) {\n    return legs === \"NO_LEG\" ? 0.02 : LEG_HEIGHT;\n}\nfunction getPartitonPlates(param) {\n    let { columns, totalHeight, totalWidth, totalDepth, legHeight } = param;\n    const verticals = [];\n    const horizontals = [];\n    const availableSpaces = [];\n    const backsides = [];\n    const spaceHeight = totalHeight - 2 * PLATE_THICKNESS - legHeight;\n    const posY = (totalHeight + legHeight) / 2;\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    verticals.push({\n        row: 0,\n        col: -1,\n        position: {\n            x: startPosX,\n            y: posY,\n            z: 0\n        },\n        scale: {\n            width: spaceHeight,\n            depth: totalDepth\n        }\n    });\n    for(let col = 0; col < columns.length; col++){\n        const column = columns[col];\n        const rows = column.rows;\n        let sum = 0;\n        for(let i = 0; i < col + 1; i++){\n            sum += columns[i].width;\n        }\n        const posX = startPosX + sum + (col + 1) * PLATE_THICKNESS;\n        const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n        verticals.push({\n            row: 0,\n            col,\n            position: {\n                x: posX,\n                y: posY,\n                z: 0\n            },\n            scale: {\n                width: spaceHeight,\n                depth: totalDepth\n            }\n        });\n        availableSpaces.push({\n            row: 0,\n            col,\n            position: {\n                x: spacePosX,\n                y: posY,\n                z: totalDepth / 2\n            },\n            scale: {\n                width: column.width,\n                depth: spaceHeight\n            }\n        });\n        for(let rowIndex = 0; rowIndex < rows.length; rowIndex++){\n            let verticalSum = 0;\n            for(let p = 0; p < rowIndex + 1; p++){\n                verticalSum += rows[rowIndex].height;\n            }\n            const middlePosY = bottomPosY + verticalSum + (rowIndex + 1) * PLATE_THICKNESS;\n            const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[rowIndex].height / 2;\n            const backPosZ = -(totalDepth - PLATE_THICKNESS) / 2;\n            if (rowIndex < rows.length - 1) {\n                horizontals.push({\n                    row: rowIndex,\n                    col,\n                    position: {\n                        x: spacePosX,\n                        y: middlePosY,\n                        z: 0\n                    },\n                    scale: {\n                        width: column.width,\n                        depth: totalDepth - EDGE_GAP\n                    }\n                });\n            }\n            backsides.push({\n                row: rowIndex,\n                col,\n                position: {\n                    x: spacePosX,\n                    y: backPosY,\n                    z: backPosZ\n                },\n                scale: {\n                    width: column.width,\n                    depth: rows[rowIndex].height\n                }\n            });\n        }\n    }\n    return {\n        verticals,\n        availableSpaces,\n        horizontals,\n        backsides\n    };\n}\nconst getCalculatedColumns = (param)=>{\n    let { current, cabinetStyle, cabinetSize, legHeight, columnCount } = param;\n    const { totalWidth, totalHeight, totalDepth } = cabinetSize;\n    // Calculate available width (total width minus side plates)\n    const availableWidth = totalWidth - 2 * PLATE_THICKNESS;\n    // Determine how many columns can fit\n    let numColumns;\n    if (columnCount) {\n        numColumns = columnCount;\n    } else {\n        // Calculate based on minimum column width\n        numColumns = Math.floor(availableWidth / (CELL_SIZE.minWidth + PLATE_THICKNESS));\n        // Ensure at least one column\n        numColumns = Math.max(1, numColumns);\n    }\n    // Calculate column width\n    const columnWidth = (availableWidth - (numColumns - 1) * PLATE_THICKNESS) / numColumns;\n    // Create columns array\n    const columns = [];\n    // Generate each column\n    for(let i = 0; i < numColumns; i++){\n        // Calculate position\n        const posX = -totalWidth / 2 + PLATE_THICKNESS + i * (columnWidth + PLATE_THICKNESS) + columnWidth / 2;\n        // Create column with appropriate layout\n        const column = createColumnWithLayout(columnWidth, posX, totalHeight, legHeight, cabinetStyle);\n        columns.push(column);\n    }\n    return columns;\n};\nfunction getRemainingColumns(remainingWidth) {\n    const b = remainingWidth % 2 === 0 ? remainingWidth / 2 : (remainingWidth + 1) / 2;\n    const c = remainingWidth - b;\n    return [\n        b,\n        c\n    ];\n}\nfunction getIndividualColumn(param) {\n    let { targetIndex, columns, totalWidth, totalDepth, legHeight } = param;\n    const column = columns[targetIndex];\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    const rowsPos = [];\n    const delta = 0.02;\n    const rows = column.rows;\n    let sum = 0;\n    for(let i = 0; i < targetIndex + 1; i++){\n        sum += columns[i].width;\n    }\n    const posX = startPosX + sum + (targetIndex + 1) * PLATE_THICKNESS;\n    const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n    for(let i = 0; i < rows.length; i++){\n        let verticalSum = 0;\n        for(let p = 0; p < i + 1; p++){\n            verticalSum += rows[p].height;\n        }\n        const middlePosY = bottomPosY + verticalSum + (i + 1) * PLATE_THICKNESS;\n        const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[i].height / 2;\n        rowsPos.push({\n            x: spacePosX - column.width / 2,\n            y: backPosY,\n            z: totalDepth / 2 + delta,\n            height: rows[i].height\n        });\n    }\n    return {\n        position: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(spacePosX, legHeight + PLATE_THICKNESS + delta, totalDepth / 2 + delta),\n        rows: rowsPos\n    };\n}\nconst getLayoutImages = (param)=>{\n    let { totalHeight } = param;\n    let imgsArray = [];\n    if (totalHeight < 0.53) {\n        imgsArray = [\n            ...layout53Icons\n        ];\n    } else if (totalHeight < 0.63) {\n        imgsArray = [\n            ...layout63Icons\n        ];\n    } else if (totalHeight < 0.73) {\n        imgsArray = [\n            ...layout73Icons\n        ];\n    } else if (totalHeight < 0.93) {\n        imgsArray = [\n            ...layout93Icons\n        ];\n    } else if (totalHeight < 1.03) {\n        imgsArray = [\n            ...layout103Icons\n        ];\n    } else if (totalHeight < 1.23) {\n        imgsArray = [\n            ...layout123Icons\n        ];\n    } else if (totalHeight < 1.33) {\n        imgsArray = [\n            ...layout133Icons\n        ];\n    } else {\n        imgsArray = [\n            ...layout143Icons\n        ];\n    }\n    return imgsArray;\n};\nconst getId = (item)=>\"\".concat(item, \"-\").concat(Math.random().toString(32).slice(-4));\nconst createColumnWithLayout = (columnWidth, posX, totalHeight, legHeight, cabinetStyle)=>{\n    // Calculate the cabinet height (excluding legs and plate thickness)\n    const cabinetHeight = totalHeight - legHeight - 2 * PLATE_THICKNESS;\n    // Get the basic vertical layout for the column\n    const rows = getColumnVerticalLayout({\n        cabinetHeight\n    });\n    // Get the starting position Y coordinate\n    const startPosY = legHeight + PLATE_THICKNESS;\n    // Default to an empty layout (will be populated based on style)\n    let layoutIndex = 0;\n    let doors = [];\n    let drawers = [];\n    // Based on cabinet style, choose an appropriate layout\n    switch(cabinetStyle){\n        case ECabinetStyle.Modern:\n            // For modern style, use all drawers\n            layoutIndex = 1;\n            // Create a drawer for each row\n            drawers = rows.map((row, index)=>({\n                    index,\n                    size: {\n                        width: columnWidth,\n                        height: row.height\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + (index + 0.5) * row.height + index * PLATE_THICKNESS\n                    }\n                }));\n            break;\n        case ECabinetStyle.Classic:\n        default:\n            // For classic style, use doors for all rows\n            layoutIndex = 0;\n            // Create a door for the full height\n            doors = [\n                {\n                    index: 0,\n                    size: {\n                        width: columnWidth,\n                        height: cabinetHeight\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + cabinetHeight / 2\n                    },\n                    opening: 1\n                }\n            ];\n            break;\n    }\n    // Create and return the column object\n    return {\n        index: 0,\n        width: columnWidth,\n        posX: posX,\n        rows: rows,\n        doors: doors,\n        drawers: drawers,\n        dividers: [],\n        layoutIndex: layoutIndex,\n        isDivide: false,\n        lastRow: drawers.length > 0 ? \"drawer\" : \"door\"\n    };\n};\n// Update the cabinet size constraints\nconst CABINET_SIZE_CONSTRAINTS = {\n    minWidth: 0.4,\n    maxWidth: 2.5,\n    minHeight: 0.4,\n    maxHeight: 2.4,\n    minDepth: 0.3,\n    maxDepth: 0.8\n};\nconst applyRandomLayoutsToColumns = (columns, totalHeight, legHeight)=>{\n    const startPosY = legHeight + PLATE_THICKNESS;\n    return columns.map((column)=>{\n        // Get all available layout options for this column\n        const layoutOptions = (0,_columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__.getLayoutOptionsOfColumn)({\n            totalHeight,\n            legHeight,\n            columnWidth: column.width,\n            posX: column.posX,\n            startPosY,\n            doorDir: 1 // Default door opening direction\n        });\n        // Select a random layout option\n        const randomLayoutIndex = Math.floor(Math.random() * layoutOptions.length);\n        const randomLayout = layoutOptions[randomLayoutIndex];\n        // Apply the random layout to the column\n        return {\n            ...column,\n            layoutIndex: randomLayoutIndex,\n            rows: randomLayout.rows,\n            doors: randomLayout.doors,\n            drawers: randomLayout.drawers,\n            lastRow: randomLayout.lastRow\n        };\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy91dGlsaXRpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDK0I7QUFFa0M7QUFFakUsZUFBZTtBQUNmLGFBQWE7QUFDTixNQUFNRSxrQkFBa0IsS0FBSztBQUM3QixNQUFNQyxZQUFZO0lBQ3ZCQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxXQUFXO0FBQ2IsRUFBRTtBQUNLLE1BQU1DLGFBQWEsS0FBSztBQUN4QixNQUFNQyxZQUFZLEtBQUs7QUFDdkIsTUFBTUMsWUFBWSxLQUFLO0FBQ3ZCLE1BQU1DLFdBQVcsTUFBTTtBQUU5QixTQUFTO0FBQ0YsTUFBTUMsWUFBWSxVQUFVO0FBQzVCLE1BQU1DLGFBQWEsVUFBVTtBQUM3QixNQUFNQyxvQkFBb0IsVUFBVTtBQUNwQyxNQUFNQyx3QkFBd0IsVUFBVTtBQUUvQyxnQkFBZ0I7QUFDaEIsTUFBTUMsbUJBQW1CO0FBQ2xCLE1BQU1DLGtCQUFrQkQsbUJBQW1CLGtCQUFrQjtBQUNwRSxNQUFNRSxrQkFBa0JGLG1CQUFtQjtBQUMzQyxNQUFNRyxtQkFBbUJELGtCQUFrQjtBQUMzQyxNQUFNRSx1QkFBdUJGLGtCQUFrQjtBQUMvQyxNQUFNRywwQkFBMEJILGtCQUFrQjtBQUUzQyxNQUFNSSxrQkFBa0I7SUFDN0JDLE9BQU9KO0lBQ1BLLFdBQVdKO0lBQ1hLLGNBQWNKO0FBQ2hCLEVBQUU7QUFFRix1QkFBdUI7QUFDdkIsTUFBTUssZUFBZVYsbUJBQW1CO0FBQ3hDLE1BQU1XLGtCQUFrQkQsZUFBZTtBQUN2QyxNQUFNRSxzQkFBc0JGLGVBQWU7QUFDM0MsTUFBTUcseUJBQXlCSCxlQUFlO0FBRXZDLE1BQU1JLGlCQUFpQjtJQUM1QlAsT0FBT0k7SUFDUEgsV0FBV0k7SUFDWEgsY0FBY0k7QUFDaEIsRUFBRTs7VUFHVUU7Z0VBQ2VmO0lBQ3pCLDBFQUEwRTt5REFD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O1FBQ3pFLE1BQU1pSSxlQUFlSCxhQUFhLENBQUNFLGtCQUFrQjtRQUVyRCx3Q0FBd0M7UUFDeEMsT0FBTztZQUNMLEdBQUdyRCxNQUFNO1lBQ1RtQyxhQUFha0I7WUFDYnBELE1BQU1xRCxhQUFhckQsSUFBSTtZQUN2Qm1DLE9BQU9rQixhQUFhbEIsS0FBSztZQUN6QkMsU0FBU2lCLGFBQWFqQixPQUFPO1lBQzdCUyxTQUFTUSxhQUFhUixPQUFPO1FBQy9CO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy91dGlsaXRpZXMudHM/MzExZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJQ2FiaW5ldFNpemUsIElDb2x1bW4sIElDb2x1bW5MYXN0Um93LCBJUGFydGl0aW9uIH0gZnJvbSAnQC9zdG9yZS90eXBlcyc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0T3B0aW9uc09mQ29sdW1uIH0gZnJvbSAnLi9jb2x1bW5MYXlvdXRPcHRpb25zJztcblxuLy8tLS0gQ09OU1RBTlRTXG4vLyBEaW1lbnNpb25zXG5leHBvcnQgY29uc3QgUExBVEVfVEhJQ0tORVNTID0gMC4wMjtcbmV4cG9ydCBjb25zdCBDRUxMX1NJWkUgPSB7XG4gIG1heFdpZHRoOiAwLjYwLFxuICBtaW5XaWR0aDogMC4yNSxcbiAgbWF4SGVpZ2h0OiAwLjM1LFxuICBtaW5IZWlnaHQ6IDAuMTUsXG59O1xuZXhwb3J0IGNvbnN0IExFR19IRUlHSFQgPSAwLjE4O1xuZXhwb3J0IGNvbnN0IExFR19XSURUSCA9IDAuMDU7XG5leHBvcnQgY29uc3QgTEVHX0RFUFRIID0gMC4wNTtcbmV4cG9ydCBjb25zdCBFREdFX0dBUCA9IDAuMDA2O1xuXG4vLyBDb2xvcnNcbmV4cG9ydCBjb25zdCB3YWxsQ29sb3IgPSAnI2U3ZTdlNyc7XG5leHBvcnQgY29uc3QgZmxvb3JDb2xvciA9ICcjYjdiN2I3JztcbmV4cG9ydCBjb25zdCBhbWJpZW50TGlnaHRDb2xvciA9ICcjZjBmMGYwJztcbmV4cG9ydCBjb25zdCBkaXJlY3Rpb25hbExpZ2h0Q29sb3IgPSAnI2YwZjBmMCc7XG5cbi8vIFRleHR1cmUgcGF0aHNcbmNvbnN0IHRleHR1cmVzUm9vdFBhdGggPSAnL2Fzc2V0cy90ZXh0dXJlcy8nO1xuZXhwb3J0IGNvbnN0IGVudmlyb25tZW50UGF0aCA9IHRleHR1cmVzUm9vdFBhdGggKyAnZW52aXJvbm1lbnQuaGRyJztcbmNvbnN0IHBseXdvb2RSb290UGF0aCA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZF8xay90ZXh0dXJlcy8nO1xuY29uc3QgcGx5d29vZEFvTWFwUGF0aCA9IHBseXdvb2RSb290UGF0aCArICdwbHl3b29kX2FvXzFrLmpwZyc7XG5jb25zdCBwbHl3b29kTm9ybWFsTWFwUGF0aCA9IHBseXdvb2RSb290UGF0aCArICdwbHl3b29kX25vcl9nbF8xay5qcGcnO1xuY29uc3QgcGx5d29vZFJvdWdobmVzc01hcFBhdGggPSBwbHl3b29kUm9vdFBhdGggKyAncGx5d29vZF9yb3VnaF8xay5qcGcnO1xuXG5leHBvcnQgY29uc3QgcGx5d29vZFRleHR1cmVzID0ge1xuICBhb01hcDogcGx5d29vZEFvTWFwUGF0aCxcbiAgbm9ybWFsTWFwOiBwbHl3b29kTm9ybWFsTWFwUGF0aCxcbiAgcm91Z2huZXNzTWFwOiBwbHl3b29kUm91Z2huZXNzTWFwUGF0aCxcbn07XG5cbi8vIEJhc2UgVGV4dHVyZXMgVmVlbmVyXG5jb25zdCB3b29kUm9vdFBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3dvb2RfMjcvJztcbmNvbnN0IHZlbmVlckFvTWFwUGF0aCA9IHdvb2RSb290UGF0aCArICdhbWJpZW50LW9jY2x1c2lvbi5qcGcnO1xuY29uc3QgdmVuZWVyTm9ybWFsTWFwUGF0aCA9IHdvb2RSb290UGF0aCArICdub3JtYWwuanBnJztcbmNvbnN0IHZlbmVlclJvdWdobmVzc01hcFBhdGggPSB3b29kUm9vdFBhdGggKyAncm91Z2huZXNzLmpwZyc7XG5cbmV4cG9ydCBjb25zdCB2ZW5lZXJUZXh0dXJlcyA9IHtcbiAgYW9NYXA6IHZlbmVlckFvTWFwUGF0aCxcbiAgbm9ybWFsTWFwOiB2ZW5lZXJOb3JtYWxNYXBQYXRoLFxuICByb3VnaG5lc3NNYXA6IHZlbmVlclJvdWdobmVzc01hcFBhdGgsXG59O1xuXG4vLyBWZW5lZXIgVGV4dHVyZXNcbmV4cG9ydCBlbnVtIEVWZW5lZXJUZXh0dXJlcyB7XG4gIEJFSUdFX0dSRVlfTE9SRU5aT19PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9iZWlnZV9ncmV5X2xvcmVuem9fb2FrLmpwZycsXG4gIC8vIEJFSUdFX1RFWFRJTEUgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9iZWlnZV90ZXh0aWxlLmpwZycsXG4gIEJST1dOX0FCQU5PX0FTSCA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2Jyb3duX2FiYW5vX2FzaC5qcGcnLFxuICBCUk9XTl9IQUxJRkFYX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2Jyb3duX2hhbGlmYXhfb2FrLmpwZycsXG4gIEJST1dOX1RPTk5TQkVSR19PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9icm93bl90b25uc2Jlcmdfb2FrLmpwZycsXG4gIEJST1dOX1dBUk1JQV9XQUxMTlVUID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYnJvd25fd2FybWlhX3dhbGxudXQuanBnJyxcbiAgTElHSFRfQkFST05JQV9PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9saWdodF9iYXJvbmlhX29hay5qcGcnLFxuICBMSUdIVF9OQVRVUkFMX0RBVkVOUE9SVF9PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9MaWdodF9OYXR1cmFsX0RhdmVucG9ydF9vYWsuanBnJyxcbiAgTkFUVVJBTF9DQVNFTExBX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL25hdHVyYWxfY2FzZWxsYV9vYWsuanBnJyxcbiAgUEFST05BX1dBTExOVVQgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9wYXJvbmFfd2FsbG51dC5qcGcnLFxuICBTRVZJTExBX0FTSCA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL3NldmlsbGFfYXNoLmpwZycsXG4gIFZJQ0VOWkFfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvdmljZW56YV9vYWsuanBnJyxcbiAgVklDRU5aQV9PQUtfMiA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL3ZpY2VuemFfb2FrMi5qcGcnLFxufVxuXG4vL1BseXdvb2QgVGV4dHVyZXNcbmV4cG9ydCBlbnVtIEVQbHl3b29kVGV4dHVyZXMge1xuICBCUk9OWkVfQlJVU0hFRF9NRVRBTCA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvYnJvbnplX2JydXNoZWRfbWV0YWwuanBnJyxcbiAgQUxNT05EX0JFSUdFID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9hbG1vbmRfYmVpZ2UuanBnJyxcbiAgQ0FSQVRfQkVJR0UgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2NhcmF0X2JlaWdlLmpwZycsXG4gIENBU0hNRVJFX0dSRVkgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2Nhc2htZXJlX2dyZXkuanBnJyxcbiAgQ09SQV9CUk9OWkUgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2NvYnJhX2Jyb256ZS5qcGcnLFxuICBDVUJBTklURV9HUkVZID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9jdWJhbml0ZV9ncmV5LmpwZycsXG4gIEZJUl9HUkVFTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvZmlyX2dyZWVuLmpwZycsXG4gIEZKT1JEX0dSRUVOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9mam9yZF9ncmVlbi5qcGcnLFxuICBHUkFQSElURV9HUkVZID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9ncmFwaGl0ZV9ncmV5LmpwZycsXG4gIElORElHT19CTFVFID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9pbmRpZ29fYmx1ZS5qcGcnLFxuICBSRUVEX0dSRUVOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9yZWVkX2dyZWVuLmpwZycsXG4gIFNBR0VfR1JFRU4gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL3NhZ2VfZ3JlZW4uanBnJyxcbiAgU1RPTkVfR1JFRU4gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL3N0b25lX2dyZWVuLmpwZycsXG4gIFRBVVBFX0dSRVkgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL3RhdXBlX2dyZXkuanBnJyxcbiAgVFJVRkZMRV9CUk9XTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvdHJ1ZmZsZV9icm93bi5qcGcnLFxuICBVOTk5X1BNX0JMQUNLID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9VOTk5X1BNX0JsYWNrLmpwZycsXG59XG5cbi8vIE9jY2x1c2lvbiBUZXh0dXJlc1xuZXhwb3J0IGNvbnN0IGhvcml6b250YWxPY2NsdXNpb25UZXh0dXJlUGF0aCA9IHRleHR1cmVzUm9vdFBhdGggKyAnaG9yaXpvbnRhbC1wYW5lbC5qcGcnO1xuZXhwb3J0IGNvbnN0IHZlcnRpY2FsT2NjbHVzaW9uVGV4dHVyZVBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlcnRpY2FsLXBhbmVsLmpwZyc7XG5leHBvcnQgY29uc3QgYmFja09jY2x1c2lvblRleHR1cmVQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICdiYWNrLXBhbmVsLmpwZyc7XG5cbmV4cG9ydCBlbnVtIEVPY2NsdXNpb25JbWFnZXMge1xuICBIT1JJWk9OVEFMID0gaG9yaXpvbnRhbE9jY2x1c2lvblRleHR1cmVQYXRoLFxuICBCQUNLID0gdmVydGljYWxPY2NsdXNpb25UZXh0dXJlUGF0aCxcbiAgVkVSVElDQUwgPSBiYWNrT2NjbHVzaW9uVGV4dHVyZVBhdGgsXG59XG5cbi8vIExheW91dCBJY29uc1xuY29uc3QgbGF5b3V0SWNvblJvb3RQYXRoID0gJy9hc3NldHMvaWNvbnMvb24tbW9kZWwtZWRpdG9yLyc7XG5cbmV4cG9ydCBjb25zdCBpY29uaWZ5SWNvbnMgPSB7XG4gIGxheW91dEljb25zOiB7XG4gICAgdW5kb0ljb246ICdzb2xhcjp1bmRvLWxlZnQtcm91bmQtb3V0bGluZScsXG4gICAgZGltZW5zaW9uc0ljb246ICdzb2xhcjpydWxlci1saW5lYXInLFxuICAgIGRvb3JzSWNvbjogJ2ZsdWVudDpkb29yLTIwLXJlZ3VsYXInLFxuICAgIGFsaWduQ29sdW1uc0ljb246ICdmbG93Yml0ZTpncmlkLXBsdXMtb3V0bGluZScsXG4gICAgc2hvd0RlY29yYXRpb25zSWNvbjogJ2h1Z2VpY29uczpwYWludC1icnVzaC0wMicsXG4gICAgYXNzZW1ibHlJY29uOiAnY2FyYm9uOjNkLWN1cnNvcicsXG4gIH0sXG4gIG1lbnVJY29uczoge1xuICAgIGFycm93VXA6ICdpd3dhOmFycm93LXVwJyxcbiAgICBhcnJvd0Rvd246ICdpd3dhOmFycm93LWRvd24nLFxuICAgIGluZm9RdWVzdGlvbjogJ3BoOnF1ZXN0aW9uLWJvbGQnLFxuICB9LFxuICBzY2VuZUljb25zOiB7XG4gICAgZWRpdExheW91dDogJ2ljLW91dGxpbmUtY3JlYXRlJyxcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBtZW51SWNvblBhdGhzOiB7XG4gIGxlZ3M6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIGhhbmRsZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHN0eWxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn0gPSB7XG4gIGxlZ3M6IHtcbiAgICBub19sZWc6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvbGVncy9ub19sZWcuc3ZnJyxcbiAgICBsZWdzOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL2xlZ3MvbGVncy5zdmcnLFxuICAgIGZsb2F0aW5nOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL2xlZ3MvZmxvYXRpbmcuc3ZnJyxcbiAgfSxcbiAgaGFuZGxlczoge1xuICAgIGhhbmRsZV9hOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL2hhbmRsZXMvaGFuZGxlX0Euc3ZnJyxcbiAgICBoYW5kbGVfYjogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9oYW5kbGVzL2hhbmRsZV9CLnN2ZycsXG4gICAgcHVzaDogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9oYW5kbGVzL3B1c2guc3ZnJyxcbiAgfSxcbiAgc3R5bGVzOiB7XG4gICAgZnJhbWU6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL2ZyYW1lLnN2ZycsXG4gICAgZ3JhZGllbnQ6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL2dyYWRpZW50LnN2ZycsXG4gICAgZ3JpZDogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9zdHlsZXMvZ3JpZC5zdmcnLFxuICAgIG1vc2FpYzogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9zdHlsZXMvbW9zYWljLnN2ZycsXG4gICAgcGl4ZWw6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL3BpeGVsLnN2ZycsXG4gICAgc2xhbnQ6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL3NsYW50LnN2ZycsXG4gIH0sXG59O1xuXG5jb25zdCBnZW5lcmF0ZUxheW91dEljb25zID0gKGxheW91dEhlaWdodDogbnVtYmVyLCBpY29uQ291bnQ6IG51bWJlcikgPT4ge1xuICBjb25zdCBsYXlvdXRSb290UGF0aCA9IGAke2xheW91dEljb25Sb290UGF0aH0ke2xheW91dEhlaWdodH0vYDtcbiAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGljb25Db3VudCB9LCAoXywgaSkgPT4gYCR7bGF5b3V0Um9vdFBhdGh9JHtpICsgMX0uc3ZnYCk7XG59O1xuXG4vLyBHZW5lcmF0aW5nIGljb24gcGF0aHMgZm9yIGVhY2ggbGF5b3V0XG5jb25zdCBsYXlvdXQ1M0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucyg1MywgMyk7XG5jb25zdCBsYXlvdXQ2M0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucyg2MywgNik7XG5jb25zdCBsYXlvdXQ3M0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucyg3MywgNyk7XG5jb25zdCBsYXlvdXQ5M0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucyg5MywgOCk7XG5jb25zdCBsYXlvdXQxMDNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoMTAzLCA4KTtcbmNvbnN0IGxheW91dDEyM0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucygxMjMsIDgpO1xuY29uc3QgbGF5b3V0MTMzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDEzMywgNik7IC8vIEFkanVzdGVkIGZvciA2IGljb25zIG9ubHlcbmNvbnN0IGxheW91dDE0M0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucygxNDMsIDYpO1xuXG4vLyBNb2RlbCBQYXRoc1xuY29uc3QgbW9kZWxzUm9vdFBhdGggPSAnL2Fzc2V0cy9tb2RlbHMvJztcblxuZXhwb3J0IGNvbnN0IHNoYWRvd01hbk1vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ3NoYWRvd19tYW4uZ2xiJztcbmV4cG9ydCBjb25zdCBoYW5kbGVBTW9kZWxQYXRoID0gbW9kZWxzUm9vdFBhdGggKyAnaGFuZGxlX0EuZ2xiJztcbmV4cG9ydCBjb25zdCBoYW5kbGVCTW9kZWxQYXRoID0gbW9kZWxzUm9vdFBhdGggKyAnaGFuZGxlX0IuZ2xiJztcbmV4cG9ydCBjb25zdCBsZWdzTW9kZWxQYXRoID0gbW9kZWxzUm9vdFBhdGggKyAnbGVncy5nbGInO1xuZXhwb3J0IGNvbnN0IG5vTGVnc01vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ25vX2xlZ3MuZ2xiJztcbmV4cG9ydCBjb25zdCB0dk1vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ3R2LmdsYic7XG5cbi8vIEVudW1zXG5leHBvcnQgZW51bSBFQ2FiaW5ldFN0eWxlIHtcbiAgR1JJRCA9ICdncmlkJyxcbiAgR1JBRElFTlQgPSAnZ3JhZGllbnQnLFxuICBNT1NBSUMgPSAnbW9zYWljJyxcbiAgRlJBTUUgPSAnZnJhbWUnLFxuICBTTEFOVCA9ICdzbGFudCcsXG4gIFBJWEVMID0gJ3BpeGVsJyxcbn1cblxuZXhwb3J0IGVudW0gRUNhYmluZXRMZWdzIHtcbiAgTEVHUyA9ICdMRUdTJyxcbiAgTk9fTEVHID0gJ05PX0xFRycsXG4gIEZMT0FUSU5HID0gJ0ZMT0FUSU5HJyxcbn1cblxuZXhwb3J0IGVudW0gRUNhYmluZXRIYW5kbGVzIHtcbiAgSEFORExFX0EgPSAnSEFORExFX0EnLFxuICBIQU5ETEVfQiA9ICdIQU5ETEVfQicsXG4gIFBVU0ggPSAnUFVTSCcsXG59XG5cbmV4cG9ydCBlbnVtIEVDYWJpbmV0RmluaXNoZXMge1xuICBQTFlXT09EID0gJ1BseXdvb2QnLFxuICBWRU5FRVIgPSAnVmVuZWVyJyxcbn1cblxuLy8gRnVuY3Rpb25zXG5cbi8vIEdldCB0aGUgYXJyYXkgb2YgcmVtYWluaW5nIGNvbHVtbnMgd2lkdGhzXG5leHBvcnQgY29uc3QgZ2V0V2lkdGhBcnJheSA9IChzdHlsZTogRUNhYmluZXRTdHlsZSwgdG90YWxXaWR0aDogbnVtYmVyKSA9PiB7XG4gIGxldCB3aWR0aEFycmF5OiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCB1bml0ID0gMTAwO1xuICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSBFQ2FiaW5ldFN0eWxlLkdSSUQ6XG4gICAgICBpZiAodG90YWxXaWR0aCA8IENFTExfU0laRS5tYXhXaWR0aCAqIHVuaXQpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFt0b3RhbFdpZHRoIC0gMiAqIFBMQVRFX1RISUNLTkVTUyAqIHVuaXRdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMTEyKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBnZXRSZW1haW5pbmdDb2x1bW5zKHRvdGFsV2lkdGggLSAzICogUExBVEVfVEhJQ0tORVNTICogdW5pdCk7XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAxNTQpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NF07XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAxOTcpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzhdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMjQzKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NF07XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAyODIpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzN107XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAzMjcpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzNywgNDNdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMzcyKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NCwgMzcsIDQzLCA0M107XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCA0MTIpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzNywgNDMsIDQzLCAzOF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOCwgNDQsIDM3LCA0MywgNDMsIDM4LCA0NF07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHdpZHRoQXJyYXk7XG59O1xuXG4vLyBHZXQgdGhlIHZlcnRpY2FsIGxheW91dCBvZiBhIGNvbHVtbiBmb3IgYSBnaXZlbiBjYWJpbmV0IGhlaWdodFxuZXhwb3J0IGNvbnN0IGdldENvbHVtblZlcnRpY2FsTGF5b3V0ID0gKHsgY2FiaW5ldEhlaWdodCB9OiB7IGNhYmluZXRIZWlnaHQ6IG51bWJlciB9KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRsYXlvdXQgPSBbXTtcbiAgY29uc3QgbnVtYmVyT2ZSb3dzID0gZ2V0Um93Q291bnQoeyBjYWJpbmV0SGVpZ2h0IH0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mUm93czsgaSsrKSB7XG4gICAgY3VycmVudGxheW91dC5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgaGVpZ2h0OiBnZXRDZWxsSGVpZ2h0KG51bWJlck9mUm93cywgY2FiaW5ldEhlaWdodCksXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRsYXlvdXQ7XG59O1xuXG4vLyBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIFZlY3RvcjNzXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDE6IFZlY3RvcjMsIHAyOiBWZWN0b3IzKSB7XG4gIC8vIHJldHVybiB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB0aGUgZGlmZmVyZW5jZXMgb2YgdGhlIHggYW5kIHogY29vcmRpbmF0ZXNcbiAgcmV0dXJuIE1hdGguc3FydCgocDIueCAtIHAxLngpICoqIDIgKyAocDIueiAtIHAxLnopICoqIDIpO1xufVxuXG4vLyBHZXQgdGhlIGNvdW50IG9mIHJvd3MgZm9yIGEgZ2l2ZW4gY2FiaW5ldCBoZWlnaHRcbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dDb3VudCh7IGNhYmluZXRIZWlnaHQgfTogeyBjYWJpbmV0SGVpZ2h0OiBudW1iZXIgfSkge1xuICAvLyBHZXQgdGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgY2VsbFxuICBjb25zdCBtYXhIZWlnaHQgPSBDRUxMX1NJWkUubWF4SGVpZ2h0O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIHJvd3NcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGNhYmluZXRIZWlnaHQgLSBQTEFURV9USElDS05FU1MpIC8gKG1heEhlaWdodCArIFBMQVRFX1RISUNLTkVTUykpICsgMTtcbn1cblxuLy8gR2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBhbmQgdGhlIHdpZHRoIG9mIGEgY2VsbCBmb3IgYSBnaXZlbiB0b3RhbCB3aWR0aFxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbHVtbkNvdW50KHsgdG90YWxXaWR0aCB9OiB7IHRvdGFsV2lkdGg6IG51bWJlciB9KSB7XG4gIC8vIEdldCB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIGNlbGxcbiAgY29uc3QgbWF4V2lkdGggPSBDRUxMX1NJWkUubWF4V2lkdGg7XG5cbiAgLy8gR2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBhY2NvcmRpbmcgdG8gdGhlIHRvdGFsIHdpZHRoXG4gIGNvbnN0IG51bWJlck9mQ29sdW1ucyA9IE1hdGguZmxvb3IoKHRvdGFsV2lkdGggLSBQTEFURV9USElDS05FU1MpIC8gKG1heFdpZHRoICsgUExBVEVfVEhJQ0tORVNTKSkgKyAxO1xuXG4gIC8vIEdldCB0aGUgdG90YWwgd2lkdGggb2YgY2VsbHMgd2l0aG91dFxuICBjb25zdCBzdW0gPSB0b3RhbFdpZHRoIC0gKG51bWJlck9mQ29sdW1ucyArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuXG4gIC8vIFJvdW5kIHRvIDIgZGVjaW1hbCBwbGFjZXNcbiAgY29uc3Qgd2lkdGhPZkNlbGwgPSBNYXRoLnJvdW5kKChzdW0gLyBudW1iZXJPZkNvbHVtbnMpICogMTAwKSAvIDEwMDtcblxuICByZXR1cm4ge1xuICAgIG51bWJlck9mQ29sdW1ucyxcbiAgICB3aWR0aE9mQ2VsbCxcbiAgfTtcbn1cblxuLy8gR2V0IHRoZSBoZWlnaHQgb2YgYSBjZWxsIGZvciBhIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBhIGNhYmluZXQgaGVpZ2h0XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VsbEhlaWdodChyb3dDb3VudDogbnVtYmVyLCBjYWJpbmV0SGVpZ2h0OiBudW1iZXIpIHtcbiAgLy8gR2V0IHRoZSBoZWlnaHQgb2YgYSBjZWxsXG4gIGNvbnN0IGNlbGxIZWlnaHQgPSAoY2FiaW5ldEhlaWdodCAtIChyb3dDb3VudCAtIDEpICogUExBVEVfVEhJQ0tORVNTKSAvIHJvd0NvdW50O1xuICByZXR1cm4gY2VsbEhlaWdodDtcbn1cblxuLy8gR2V0IHRoZSB3aWR0aCBvZiBhIGNlbGwgZm9yIGEgZ2l2ZW4gbnVtYmVyIG9mIGNvbHVtbnMgYW5kIGEgdG90YWwgd2lkdGhcbmV4cG9ydCBmdW5jdGlvbiBnZXRDZWxsV2lkdGgoY29sdW1uQ291bnQ6IG51bWJlciwgdG90YWxXaWR0aDogbnVtYmVyKSB7XG4gIC8vIEdldCB0aGUgd2lkdGggb2YgYSBjZWxsXG4gIGNvbnN0IGNlbGxXaWR0aCA9ICh0b3RhbFdpZHRoIC0gKGNvbHVtbkNvdW50ICsgMSkgKiBQTEFURV9USElDS05FU1MpIC8gY29sdW1uQ291bnQ7XG4gIHJldHVybiBjZWxsV2lkdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21IZWlnaHQobGVnczogRUNhYmluZXRMZWdzKSB7XG4gIHJldHVybiBsZWdzID09PSBFQ2FiaW5ldExlZ3MuTk9fTEVHID8gMC4wMiA6IExFR19IRUlHSFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJ0aXRvblBsYXRlcyh7IGNvbHVtbnMsIHRvdGFsSGVpZ2h0LCB0b3RhbFdpZHRoLCB0b3RhbERlcHRoLCBsZWdIZWlnaHQgfTogeyBjb2x1bW5zOiBJQ29sdW1uW107IHRvdGFsSGVpZ2h0OiBudW1iZXI7IHRvdGFsV2lkdGg6IG51bWJlcjsgdG90YWxEZXB0aDogbnVtYmVyOyBsZWdIZWlnaHQ6IG51bWJlciB9KSB7XG4gIGNvbnN0IHZlcnRpY2FsczogSVBhcnRpdGlvbltdID0gW107XG4gIGNvbnN0IGhvcml6b250YWxzOiBJUGFydGl0aW9uW10gPSBbXTtcbiAgY29uc3QgYXZhaWxhYmxlU3BhY2VzOiBJUGFydGl0aW9uW10gPSBbXTtcbiAgY29uc3QgYmFja3NpZGVzOiBJUGFydGl0aW9uW10gPSBbXTtcblxuICBjb25zdCBzcGFjZUhlaWdodCA9IHRvdGFsSGVpZ2h0IC0gMiAqIFBMQVRFX1RISUNLTkVTUyAtIGxlZ0hlaWdodDtcblxuICBjb25zdCBwb3NZID0gKHRvdGFsSGVpZ2h0ICsgbGVnSGVpZ2h0KSAvIDI7XG5cbiAgY29uc3Qgc3RhcnRQb3NYID0gLSh0b3RhbFdpZHRoIC0gUExBVEVfVEhJQ0tORVNTKSAvIDI7XG4gIGNvbnN0IGJvdHRvbVBvc1kgPSBsZWdIZWlnaHQgKyBQTEFURV9USElDS05FU1MgLyAyO1xuXG4gIHZlcnRpY2Fscy5wdXNoKHtcbiAgICByb3c6IDAsXG4gICAgY29sOiAtMSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgeDogc3RhcnRQb3NYLFxuICAgICAgeTogcG9zWSxcbiAgICAgIHo6IDAsXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgd2lkdGg6IHNwYWNlSGVpZ2h0LFxuICAgICAgZGVwdGg6IHRvdGFsRGVwdGgsXG4gICAgfSxcbiAgfSk7XG4gIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHVtbnMubGVuZ3RoOyBjb2wrKykge1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbY29sXTtcbiAgICBjb25zdCByb3dzID0gY29sdW1uLnJvd3M7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2wgKyAxOyBpKyspIHtcbiAgICAgIHN1bSArPSBjb2x1bW5zW2ldLndpZHRoO1xuICAgIH1cbiAgICBjb25zdCBwb3NYID0gc3RhcnRQb3NYICsgc3VtICsgKGNvbCArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuICAgIGNvbnN0IHNwYWNlUG9zWCA9IHBvc1ggLSBQTEFURV9USElDS05FU1MgLyAyIC0gY29sdW1uLndpZHRoIC8gMjtcblxuICAgIHZlcnRpY2Fscy5wdXNoKHtcbiAgICAgIHJvdzogMCxcbiAgICAgIGNvbCxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHBvc1gsXG4gICAgICAgIHk6IHBvc1ksXG4gICAgICAgIHo6IDAsXG4gICAgICB9LFxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgd2lkdGg6IHNwYWNlSGVpZ2h0LFxuICAgICAgICBkZXB0aDogdG90YWxEZXB0aCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhdmFpbGFibGVTcGFjZXMucHVzaCh7XG4gICAgICByb3c6IDAsXG4gICAgICBjb2wsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBzcGFjZVBvc1gsXG4gICAgICAgIHk6IHBvc1ksXG4gICAgICAgIHo6IHRvdGFsRGVwdGggLyAyLFxuICAgICAgfSxcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGgsXG4gICAgICAgIGRlcHRoOiBzcGFjZUhlaWdodCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgIGxldCB2ZXJ0aWNhbFN1bSA9IDA7XG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHJvd0luZGV4ICsgMTsgcCsrKSB7XG4gICAgICAgIHZlcnRpY2FsU3VtICs9IHJvd3Nbcm93SW5kZXhdLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWlkZGxlUG9zWSA9IGJvdHRvbVBvc1kgKyB2ZXJ0aWNhbFN1bSArIChyb3dJbmRleCArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuXG4gICAgICBjb25zdCBiYWNrUG9zWSA9IG1pZGRsZVBvc1kgLSBQTEFURV9USElDS05FU1MgLyAyIC0gcm93c1tyb3dJbmRleF0uaGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGJhY2tQb3NaID0gLSh0b3RhbERlcHRoIC0gUExBVEVfVEhJQ0tORVNTKSAvIDI7XG4gICAgICBpZiAocm93SW5kZXggPCByb3dzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaG9yaXpvbnRhbHMucHVzaCh7XG4gICAgICAgICAgcm93OiByb3dJbmRleCxcbiAgICAgICAgICBjb2wsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHNwYWNlUG9zWCxcbiAgICAgICAgICAgIHk6IG1pZGRsZVBvc1ksXG4gICAgICAgICAgICB6OiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGgsXG4gICAgICAgICAgICBkZXB0aDogdG90YWxEZXB0aCAtIEVER0VfR0FQLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBiYWNrc2lkZXMucHVzaCh7XG4gICAgICAgIHJvdzogcm93SW5kZXgsXG4gICAgICAgIGNvbCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBzcGFjZVBvc1gsXG4gICAgICAgICAgeTogYmFja1Bvc1ksXG4gICAgICAgICAgejogYmFja1Bvc1osXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCxcbiAgICAgICAgICBkZXB0aDogcm93c1tyb3dJbmRleF0uaGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbHMsXG4gICAgYXZhaWxhYmxlU3BhY2VzLFxuICAgIGhvcml6b250YWxzLFxuICAgIGJhY2tzaWRlcyxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldENhbGN1bGF0ZWRDb2x1bW5zID0gKHsgXG4gIGN1cnJlbnQsIFxuICBjYWJpbmV0U3R5bGUsIFxuICBjYWJpbmV0U2l6ZSwgXG4gIGxlZ0hlaWdodCwgXG4gIGNvbHVtbkNvdW50IFxufTogVEdldENhbGN1bGF0ZWRDb2x1bW5zUHJvcHMpOiBJQ29sdW1uW10gPT4ge1xuICBjb25zdCB7IHRvdGFsV2lkdGgsIHRvdGFsSGVpZ2h0LCB0b3RhbERlcHRoIH0gPSBjYWJpbmV0U2l6ZTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBhdmFpbGFibGUgd2lkdGggKHRvdGFsIHdpZHRoIG1pbnVzIHNpZGUgcGxhdGVzKVxuICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IHRvdGFsV2lkdGggLSAyICogUExBVEVfVEhJQ0tORVNTO1xuICBcbiAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IGNvbHVtbnMgY2FuIGZpdFxuICBsZXQgbnVtQ29sdW1ucztcbiAgaWYgKGNvbHVtbkNvdW50KSB7XG4gICAgbnVtQ29sdW1ucyA9IGNvbHVtbkNvdW50O1xuICB9IGVsc2Uge1xuICAgIC8vIENhbGN1bGF0ZSBiYXNlZCBvbiBtaW5pbXVtIGNvbHVtbiB3aWR0aFxuICAgIG51bUNvbHVtbnMgPSBNYXRoLmZsb29yKGF2YWlsYWJsZVdpZHRoIC8gKENFTExfU0laRS5taW5XaWR0aCArIFBMQVRFX1RISUNLTkVTUykpO1xuICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBvbmUgY29sdW1uXG4gICAgbnVtQ29sdW1ucyA9IE1hdGgubWF4KDEsIG51bUNvbHVtbnMpO1xuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgY29sdW1uIHdpZHRoXG4gIGNvbnN0IGNvbHVtbldpZHRoID0gKGF2YWlsYWJsZVdpZHRoIC0gKG51bUNvbHVtbnMgLSAxKSAqIFBMQVRFX1RISUNLTkVTUykgLyBudW1Db2x1bW5zO1xuICBcbiAgLy8gQ3JlYXRlIGNvbHVtbnMgYXJyYXlcbiAgY29uc3QgY29sdW1uczogSUNvbHVtbltdID0gW107XG4gIFxuICAvLyBHZW5lcmF0ZSBlYWNoIGNvbHVtblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvbHVtbnM7IGkrKykge1xuICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvblxuICAgIGNvbnN0IHBvc1ggPSAtdG90YWxXaWR0aCAvIDIgKyBQTEFURV9USElDS05FU1MgKyBpICogKGNvbHVtbldpZHRoICsgUExBVEVfVEhJQ0tORVNTKSArIGNvbHVtbldpZHRoIC8gMjtcbiAgICBcbiAgICAvLyBDcmVhdGUgY29sdW1uIHdpdGggYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgY29uc3QgY29sdW1uID0gY3JlYXRlQ29sdW1uV2l0aExheW91dChjb2x1bW5XaWR0aCwgcG9zWCwgdG90YWxIZWlnaHQsIGxlZ0hlaWdodCwgY2FiaW5ldFN0eWxlKTtcbiAgICBcbiAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgfVxuICBcbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW1haW5pbmdDb2x1bW5zKHJlbWFpbmluZ1dpZHRoOiBudW1iZXIpIHtcbiAgY29uc3QgYiA9IHJlbWFpbmluZ1dpZHRoICUgMiA9PT0gMCA/IHJlbWFpbmluZ1dpZHRoIC8gMiA6IChyZW1haW5pbmdXaWR0aCArIDEpIC8gMjtcbiAgY29uc3QgYyA9IHJlbWFpbmluZ1dpZHRoIC0gYjtcblxuICByZXR1cm4gW2IsIGNdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5kaXZpZHVhbENvbHVtbih7XG4gIHRhcmdldEluZGV4LFxuICBjb2x1bW5zLFxuICB0b3RhbFdpZHRoLFxuICB0b3RhbERlcHRoLFxuICBsZWdIZWlnaHQsXG59OiB7XG4gIHRhcmdldEluZGV4OiBudW1iZXI7XG4gIGNvbHVtbnM6IElDb2x1bW5bXTtcbiAgdG90YWxXaWR0aDogbnVtYmVyO1xuICB0b3RhbERlcHRoOiBudW1iZXI7XG4gIGxlZ0hlaWdodDogbnVtYmVyO1xufSkge1xuICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3RhcmdldEluZGV4XTtcblxuICBjb25zdCBzdGFydFBvc1ggPSAtKHRvdGFsV2lkdGggLSBQTEFURV9USElDS05FU1MpIC8gMjtcbiAgY29uc3QgYm90dG9tUG9zWSA9IGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUyAvIDI7XG4gIGNvbnN0IHJvd3NQb3MgPSBbXTtcbiAgY29uc3QgZGVsdGEgPSAwLjAyO1xuICBjb25zdCByb3dzID0gY29sdW1uLnJvd3M7XG5cbiAgbGV0IHN1bSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0SW5kZXggKyAxOyBpKyspIHtcbiAgICBzdW0gKz0gY29sdW1uc1tpXS53aWR0aDtcbiAgfVxuICBjb25zdCBwb3NYID0gc3RhcnRQb3NYICsgc3VtICsgKHRhcmdldEluZGV4ICsgMSkgKiBQTEFURV9USElDS05FU1M7XG4gIGNvbnN0IHNwYWNlUG9zWCA9IHBvc1ggLSBQTEFURV9USElDS05FU1MgLyAyIC0gY29sdW1uLndpZHRoIC8gMjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgdmVydGljYWxTdW0gPSAwO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgaSArIDE7IHArKykge1xuICAgICAgdmVydGljYWxTdW0gKz0gcm93c1twXS5oZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG1pZGRsZVBvc1kgPSBib3R0b21Qb3NZICsgdmVydGljYWxTdW0gKyAoaSArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuICAgIGNvbnN0IGJhY2tQb3NZID0gbWlkZGxlUG9zWSAtIFBMQVRFX1RISUNLTkVTUyAvIDIgLSByb3dzW2ldLmhlaWdodCAvIDI7XG4gICAgcm93c1Bvcy5wdXNoKHtcbiAgICAgIHg6IHNwYWNlUG9zWCAtIGNvbHVtbi53aWR0aCAvIDIsXG4gICAgICB5OiBiYWNrUG9zWSxcbiAgICAgIHo6IHRvdGFsRGVwdGggLyAyICsgZGVsdGEsXG4gICAgICBoZWlnaHQ6IHJvd3NbaV0uaGVpZ2h0LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoc3BhY2VQb3NYLCBsZWdIZWlnaHQgKyBQTEFURV9USElDS05FU1MgKyBkZWx0YSwgdG90YWxEZXB0aCAvIDIgKyBkZWx0YSksXG4gICAgcm93czogcm93c1BvcyxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldExheW91dEltYWdlcyA9ICh7IHRvdGFsSGVpZ2h0IH06IHsgdG90YWxIZWlnaHQ6IG51bWJlciB9KSA9PiB7XG4gIGxldCBpbWdzQXJyYXkgPSBbXTtcbiAgaWYgKHRvdGFsSGVpZ2h0IDwgMC41Mykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQ1M0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDAuNjMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0NjNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAwLjczKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDczSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMC45Mykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQ5M0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDEuMDMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0MTAzSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMS4yMykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQxMjNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAxLjMzKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDEzM0ljb25zXTtcbiAgfSBlbHNlIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0MTQzSWNvbnNdO1xuICB9XG5cbiAgcmV0dXJuIGltZ3NBcnJheTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJZCA9IChpdGVtOiBzdHJpbmcpID0+IGAke2l0ZW19LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzMikuc2xpY2UoLTQpfWA7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb2x1bW5XaXRoTGF5b3V0ID0gKGNvbHVtbldpZHRoOiBudW1iZXIsIHBvc1g6IG51bWJlciwgdG90YWxIZWlnaHQ6IG51bWJlciwgbGVnSGVpZ2h0OiBudW1iZXIsIGNhYmluZXRTdHlsZTogRUNhYmluZXRTdHlsZSk6IElDb2x1bW4gPT4ge1xuICAvLyBDYWxjdWxhdGUgdGhlIGNhYmluZXQgaGVpZ2h0IChleGNsdWRpbmcgbGVncyBhbmQgcGxhdGUgdGhpY2tuZXNzKVxuICBjb25zdCBjYWJpbmV0SGVpZ2h0ID0gdG90YWxIZWlnaHQgLSBsZWdIZWlnaHQgLSAyICogUExBVEVfVEhJQ0tORVNTO1xuICBcbiAgLy8gR2V0IHRoZSBiYXNpYyB2ZXJ0aWNhbCBsYXlvdXQgZm9yIHRoZSBjb2x1bW5cbiAgY29uc3Qgcm93cyA9IGdldENvbHVtblZlcnRpY2FsTGF5b3V0KHsgY2FiaW5ldEhlaWdodCB9KTtcbiAgXG4gIC8vIEdldCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gWSBjb29yZGluYXRlXG4gIGNvbnN0IHN0YXJ0UG9zWSA9IGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUztcbiAgXG4gIC8vIERlZmF1bHQgdG8gYW4gZW1wdHkgbGF5b3V0ICh3aWxsIGJlIHBvcHVsYXRlZCBiYXNlZCBvbiBzdHlsZSlcbiAgbGV0IGxheW91dEluZGV4ID0gMDtcbiAgbGV0IGRvb3JzOiBhbnlbXSA9IFtdO1xuICBsZXQgZHJhd2VyczogYW55W10gPSBbXTtcbiAgXG4gIC8vIEJhc2VkIG9uIGNhYmluZXQgc3R5bGUsIGNob29zZSBhbiBhcHByb3ByaWF0ZSBsYXlvdXRcbiAgc3dpdGNoIChjYWJpbmV0U3R5bGUpIHtcbiAgICBjYXNlIEVDYWJpbmV0U3R5bGUuTW9kZXJuOlxuICAgICAgLy8gRm9yIG1vZGVybiBzdHlsZSwgdXNlIGFsbCBkcmF3ZXJzXG4gICAgICBsYXlvdXRJbmRleCA9IDE7XG4gICAgICAvLyBDcmVhdGUgYSBkcmF3ZXIgZm9yIGVhY2ggcm93XG4gICAgICBkcmF3ZXJzID0gcm93cy5tYXAoKHJvdywgaW5kZXgpID0+ICh7XG4gICAgICAgIGluZGV4LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogcm93LmhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zOiB7XG4gICAgICAgICAgeDogcG9zWCxcbiAgICAgICAgICB5OiBzdGFydFBvc1kgKyAoaW5kZXggKyAwLjUpICogcm93LmhlaWdodCArIGluZGV4ICogUExBVEVfVEhJQ0tORVNTLFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgICBcbiAgICBjYXNlIEVDYWJpbmV0U3R5bGUuQ2xhc3NpYzpcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIGNsYXNzaWMgc3R5bGUsIHVzZSBkb29ycyBmb3IgYWxsIHJvd3NcbiAgICAgIGxheW91dEluZGV4ID0gMDtcbiAgICAgIC8vIENyZWF0ZSBhIGRvb3IgZm9yIHRoZSBmdWxsIGhlaWdodFxuICAgICAgZG9vcnMgPSBbe1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNhYmluZXRIZWlnaHQsXG4gICAgICAgIH0sXG4gICAgICAgIHBvczoge1xuICAgICAgICAgIHg6IHBvc1gsXG4gICAgICAgICAgeTogc3RhcnRQb3NZICsgY2FiaW5ldEhlaWdodCAvIDIsXG4gICAgICAgIH0sXG4gICAgICAgIG9wZW5pbmc6IDEsIC8vIERlZmF1bHQgb3BlbmluZyBkaXJlY3Rpb25cbiAgICAgIH1dO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHRoZSBjb2x1bW4gb2JqZWN0XG4gIHJldHVybiB7XG4gICAgaW5kZXg6IDAsIC8vIFdpbGwgYmUgdXBkYXRlZCB3aGVuIGFsbCBjb2x1bW5zIGFyZSBjcmVhdGVkXG4gICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgIHBvc1g6IHBvc1gsXG4gICAgcm93czogcm93cyxcbiAgICBkb29yczogZG9vcnMsXG4gICAgZHJhd2VyczogZHJhd2VycyxcbiAgICBkaXZpZGVyczogW10sXG4gICAgbGF5b3V0SW5kZXg6IGxheW91dEluZGV4LFxuICAgIGlzRGl2aWRlOiBmYWxzZSxcbiAgICBsYXN0Um93OiBkcmF3ZXJzLmxlbmd0aCA+IDAgPyAnZHJhd2VyJyA6ICdkb29yJyxcbiAgfTtcbn07XG5cbi8vIFVwZGF0ZSB0aGUgY2FiaW5ldCBzaXplIGNvbnN0cmFpbnRzXG5leHBvcnQgY29uc3QgQ0FCSU5FVF9TSVpFX0NPTlNUUkFJTlRTID0ge1xuICBtaW5XaWR0aDogMC40LCAvLyA0MGNtIGluIG1ldGVyc1xuICBtYXhXaWR0aDogMi41LCAvLyAyNTBjbSBpbiBtZXRlcnMgKGNoYW5nZWQgZnJvbSA0LjVtLzQ1MGNtKVxuICBtaW5IZWlnaHQ6IDAuNCwgLy8gNDBjbSBpbiBtZXRlcnNcbiAgbWF4SGVpZ2h0OiAyLjQsIC8vIDI0MGNtIGluIG1ldGVyc1xuICBtaW5EZXB0aDogMC4zLCAvLyAzMGNtIGluIG1ldGVyc1xuICBtYXhEZXB0aDogMC44LCAvLyA4MGNtIGluIG1ldGVyc1xufTtcblxuZXhwb3J0IGNvbnN0IGFwcGx5UmFuZG9tTGF5b3V0c1RvQ29sdW1ucyA9IChjb2x1bW5zOiBJQ29sdW1uW10sIHRvdGFsSGVpZ2h0OiBudW1iZXIsIGxlZ0hlaWdodDogbnVtYmVyKTogSUNvbHVtbltdID0+IHtcbiAgY29uc3Qgc3RhcnRQb3NZID0gbGVnSGVpZ2h0ICsgUExBVEVfVEhJQ0tORVNTO1xuICBcbiAgcmV0dXJuIGNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XG4gICAgLy8gR2V0IGFsbCBhdmFpbGFibGUgbGF5b3V0IG9wdGlvbnMgZm9yIHRoaXMgY29sdW1uXG4gICAgY29uc3QgbGF5b3V0T3B0aW9ucyA9IGdldExheW91dE9wdGlvbnNPZkNvbHVtbih7IFxuICAgICAgdG90YWxIZWlnaHQsIFxuICAgICAgbGVnSGVpZ2h0LCBcbiAgICAgIGNvbHVtbldpZHRoOiBjb2x1bW4ud2lkdGgsIFxuICAgICAgcG9zWDogY29sdW1uLnBvc1gsIFxuICAgICAgc3RhcnRQb3NZLFxuICAgICAgZG9vckRpcjogMSAvLyBEZWZhdWx0IGRvb3Igb3BlbmluZyBkaXJlY3Rpb25cbiAgICB9KTtcbiAgICBcbiAgICAvLyBTZWxlY3QgYSByYW5kb20gbGF5b3V0IG9wdGlvblxuICAgIGNvbnN0IHJhbmRvbUxheW91dEluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGF5b3V0T3B0aW9ucy5sZW5ndGgpO1xuICAgIGNvbnN0IHJhbmRvbUxheW91dCA9IGxheW91dE9wdGlvbnNbcmFuZG9tTGF5b3V0SW5kZXhdO1xuICAgIFxuICAgIC8vIEFwcGx5IHRoZSByYW5kb20gbGF5b3V0IHRvIHRoZSBjb2x1bW5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29sdW1uLFxuICAgICAgbGF5b3V0SW5kZXg6IHJhbmRvbUxheW91dEluZGV4LFxuICAgICAgcm93czogcmFuZG9tTGF5b3V0LnJvd3MsXG4gICAgICBkb29yczogcmFuZG9tTGF5b3V0LmRvb3JzLFxuICAgICAgZHJhd2VyczogcmFuZG9tTGF5b3V0LmRyYXdlcnMsXG4gICAgICBsYXN0Um93OiByYW5kb21MYXlvdXQubGFzdFJvd1xuICAgIH07XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJUSFJFRSIsImdldExheW91dE9wdGlvbnNPZkNvbHVtbiIsIlBMQVRFX1RISUNLTkVTUyIsIkNFTExfU0laRSIsIm1heFdpZHRoIiwibWluV2lkdGgiLCJtYXhIZWlnaHQiLCJtaW5IZWlnaHQiLCJMRUdfSEVJR0hUIiwiTEVHX1dJRFRIIiwiTEVHX0RFUFRIIiwiRURHRV9HQVAiLCJ3YWxsQ29sb3IiLCJmbG9vckNvbG9yIiwiYW1iaWVudExpZ2h0Q29sb3IiLCJkaXJlY3Rpb25hbExpZ2h0Q29sb3IiLCJ0ZXh0dXJlc1Jvb3RQYXRoIiwiZW52aXJvbm1lbnRQYXRoIiwicGx5d29vZFJvb3RQYXRoIiwicGx5d29vZEFvTWFwUGF0aCIsInBseXdvb2ROb3JtYWxNYXBQYXRoIiwicGx5d29vZFJvdWdobmVzc01hcFBhdGgiLCJwbHl3b29kVGV4dHVyZXMiLCJhb01hcCIsIm5vcm1hbE1hcCIsInJvdWdobmVzc01hcCIsIndvb2RSb290UGF0aCIsInZlbmVlckFvTWFwUGF0aCIsInZlbmVlck5vcm1hbE1hcFBhdGgiLCJ2ZW5lZXJSb3VnaG5lc3NNYXBQYXRoIiwidmVuZWVyVGV4dHVyZXMiLCJFVmVuZWVyVGV4dHVyZXMiLCJFUGx5d29vZFRleHR1cmVzIiwiaG9yaXpvbnRhbE9jY2x1c2lvblRleHR1cmVQYXRoIiwidmVydGljYWxPY2NsdXNpb25UZXh0dXJlUGF0aCIsImJhY2tPY2NsdXNpb25UZXh0dXJlUGF0aCIsIkVPY2NsdXNpb25JbWFnZXMiLCJsYXlvdXRJY29uUm9vdFBhdGgiLCJpY29uaWZ5SWNvbnMiLCJsYXlvdXRJY29ucyIsInVuZG9JY29uIiwiZGltZW5zaW9uc0ljb24iLCJkb29yc0ljb24iLCJhbGlnbkNvbHVtbnNJY29uIiwic2hvd0RlY29yYXRpb25zSWNvbiIsImFzc2VtYmx5SWNvbiIsIm1lbnVJY29ucyIsImFycm93VXAiLCJhcnJvd0Rvd24iLCJpbmZvUXVlc3Rpb24iLCJzY2VuZUljb25zIiwiZWRpdExheW91dCIsIm1lbnVJY29uUGF0aHMiLCJsZWdzIiwibm9fbGVnIiwiZmxvYXRpbmciLCJoYW5kbGVzIiwiaGFuZGxlX2EiLCJoYW5kbGVfYiIsInB1c2giLCJzdHlsZXMiLCJmcmFtZSIsImdyYWRpZW50IiwiZ3JpZCIsIm1vc2FpYyIsInBpeGVsIiwic2xhbnQiLCJnZW5lcmF0ZUxheW91dEljb25zIiwibGF5b3V0SGVpZ2h0IiwiaWNvbkNvdW50IiwibGF5b3V0Um9vdFBhdGgiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImxheW91dDUzSWNvbnMiLCJsYXlvdXQ2M0ljb25zIiwibGF5b3V0NzNJY29ucyIsImxheW91dDkzSWNvbnMiLCJsYXlvdXQxMDNJY29ucyIsImxheW91dDEyM0ljb25zIiwibGF5b3V0MTMzSWNvbnMiLCJsYXlvdXQxNDNJY29ucyIsIm1vZGVsc1Jvb3RQYXRoIiwic2hhZG93TWFuTW9kZWxQYXRoIiwiaGFuZGxlQU1vZGVsUGF0aCIsImhhbmRsZUJNb2RlbFBhdGgiLCJsZWdzTW9kZWxQYXRoIiwibm9MZWdzTW9kZWxQYXRoIiwidHZNb2RlbFBhdGgiLCJFQ2FiaW5ldFN0eWxlIiwiRUNhYmluZXRMZWdzIiwiRUNhYmluZXRIYW5kbGVzIiwiRUNhYmluZXRGaW5pc2hlcyIsImdldFdpZHRoQXJyYXkiLCJzdHlsZSIsInRvdGFsV2lkdGgiLCJ3aWR0aEFycmF5IiwidW5pdCIsImdldFJlbWFpbmluZ0NvbHVtbnMiLCJnZXRDb2x1bW5WZXJ0aWNhbExheW91dCIsImNhYmluZXRIZWlnaHQiLCJjdXJyZW50bGF5b3V0IiwibnVtYmVyT2ZSb3dzIiwiZ2V0Um93Q291bnQiLCJpbmRleCIsImhlaWdodCIsImdldENlbGxIZWlnaHQiLCJnZXREaXN0YW5jZSIsInAxIiwicDIiLCJNYXRoIiwic3FydCIsIngiLCJ6IiwiZmxvb3IiLCJnZXRDb2x1bW5Db3VudCIsIm51bWJlck9mQ29sdW1ucyIsInN1bSIsIndpZHRoT2ZDZWxsIiwicm91bmQiLCJyb3dDb3VudCIsImNlbGxIZWlnaHQiLCJnZXRDZWxsV2lkdGgiLCJjb2x1bW5Db3VudCIsImNlbGxXaWR0aCIsImdldEJvdHRvbUhlaWdodCIsImdldFBhcnRpdG9uUGxhdGVzIiwiY29sdW1ucyIsInRvdGFsSGVpZ2h0IiwidG90YWxEZXB0aCIsImxlZ0hlaWdodCIsInZlcnRpY2FscyIsImhvcml6b250YWxzIiwiYXZhaWxhYmxlU3BhY2VzIiwiYmFja3NpZGVzIiwic3BhY2VIZWlnaHQiLCJwb3NZIiwic3RhcnRQb3NYIiwiYm90dG9tUG9zWSIsInJvdyIsImNvbCIsInBvc2l0aW9uIiwieSIsInNjYWxlIiwid2lkdGgiLCJkZXB0aCIsImNvbHVtbiIsInJvd3MiLCJwb3NYIiwic3BhY2VQb3NYIiwicm93SW5kZXgiLCJ2ZXJ0aWNhbFN1bSIsInAiLCJtaWRkbGVQb3NZIiwiYmFja1Bvc1kiLCJiYWNrUG9zWiIsImdldENhbGN1bGF0ZWRDb2x1bW5zIiwiY3VycmVudCIsImNhYmluZXRTdHlsZSIsImNhYmluZXRTaXplIiwiYXZhaWxhYmxlV2lkdGgiLCJudW1Db2x1bW5zIiwibWF4IiwiY29sdW1uV2lkdGgiLCJjcmVhdGVDb2x1bW5XaXRoTGF5b3V0IiwicmVtYWluaW5nV2lkdGgiLCJiIiwiYyIsImdldEluZGl2aWR1YWxDb2x1bW4iLCJ0YXJnZXRJbmRleCIsInJvd3NQb3MiLCJkZWx0YSIsIlZlY3RvcjMiLCJnZXRMYXlvdXRJbWFnZXMiLCJpbWdzQXJyYXkiLCJnZXRJZCIsIml0ZW0iLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwic3RhcnRQb3NZIiwibGF5b3V0SW5kZXgiLCJkb29ycyIsImRyYXdlcnMiLCJNb2Rlcm4iLCJtYXAiLCJzaXplIiwicG9zIiwiQ2xhc3NpYyIsIm9wZW5pbmciLCJkaXZpZGVycyIsImlzRGl2aWRlIiwibGFzdFJvdyIsIkNBQklORVRfU0laRV9DT05TVFJBSU5UUyIsIm1pbkRlcHRoIiwibWF4RGVwdGgiLCJhcHBseVJhbmRvbUxheW91dHNUb0NvbHVtbnMiLCJsYXlvdXRPcHRpb25zIiwiZG9vckRpciIsInJhbmRvbUxheW91dEluZGV4IiwicmFuZG9tTGF5b3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/utilities.ts\n"));

/***/ })

});