"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/utilities.ts":
/*!********************************!*\
  !*** ./src/utils/utilities.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CABINET_SIZE_CONSTRAINTS: function() { return /* binding */ CABINET_SIZE_CONSTRAINTS; },\n/* harmony export */   CELL_SIZE: function() { return /* binding */ CELL_SIZE; },\n/* harmony export */   ECabinetFinishes: function() { return /* binding */ ECabinetFinishes; },\n/* harmony export */   ECabinetHandles: function() { return /* binding */ ECabinetHandles; },\n/* harmony export */   ECabinetLegs: function() { return /* binding */ ECabinetLegs; },\n/* harmony export */   ECabinetStyle: function() { return /* binding */ ECabinetStyle; },\n/* harmony export */   EDGE_GAP: function() { return /* binding */ EDGE_GAP; },\n/* harmony export */   EOcclusionImages: function() { return /* binding */ EOcclusionImages; },\n/* harmony export */   EPlywoodTextures: function() { return /* binding */ EPlywoodTextures; },\n/* harmony export */   EVeneerTextures: function() { return /* binding */ EVeneerTextures; },\n/* harmony export */   LEG_DEPTH: function() { return /* binding */ LEG_DEPTH; },\n/* harmony export */   LEG_HEIGHT: function() { return /* binding */ LEG_HEIGHT; },\n/* harmony export */   LEG_WIDTH: function() { return /* binding */ LEG_WIDTH; },\n/* harmony export */   PLATE_THICKNESS: function() { return /* binding */ PLATE_THICKNESS; },\n/* harmony export */   ambientLightColor: function() { return /* binding */ ambientLightColor; },\n/* harmony export */   applyRandomLayoutsToColumns: function() { return /* binding */ applyRandomLayoutsToColumns; },\n/* harmony export */   backOcclusionTexturePath: function() { return /* binding */ backOcclusionTexturePath; },\n/* harmony export */   createColumnWithLayout: function() { return /* binding */ createColumnWithLayout; },\n/* harmony export */   directionalLightColor: function() { return /* binding */ directionalLightColor; },\n/* harmony export */   environmentPath: function() { return /* binding */ environmentPath; },\n/* harmony export */   floorColor: function() { return /* binding */ floorColor; },\n/* harmony export */   getBottomHeight: function() { return /* binding */ getBottomHeight; },\n/* harmony export */   getCalculatedColumns: function() { return /* binding */ getCalculatedColumns; },\n/* harmony export */   getCellHeight: function() { return /* binding */ getCellHeight; },\n/* harmony export */   getCellWidth: function() { return /* binding */ getCellWidth; },\n/* harmony export */   getColumnCount: function() { return /* binding */ getColumnCount; },\n/* harmony export */   getColumnVerticalLayout: function() { return /* binding */ getColumnVerticalLayout; },\n/* harmony export */   getDistance: function() { return /* binding */ getDistance; },\n/* harmony export */   getId: function() { return /* binding */ getId; },\n/* harmony export */   getIndividualColumn: function() { return /* binding */ getIndividualColumn; },\n/* harmony export */   getLayoutImages: function() { return /* binding */ getLayoutImages; },\n/* harmony export */   getPartitonPlates: function() { return /* binding */ getPartitonPlates; },\n/* harmony export */   getRemainingColumns: function() { return /* binding */ getRemainingColumns; },\n/* harmony export */   getRowCount: function() { return /* binding */ getRowCount; },\n/* harmony export */   getWidthArray: function() { return /* binding */ getWidthArray; },\n/* harmony export */   handleAModelPath: function() { return /* binding */ handleAModelPath; },\n/* harmony export */   handleBModelPath: function() { return /* binding */ handleBModelPath; },\n/* harmony export */   horizontalOcclusionTexturePath: function() { return /* binding */ horizontalOcclusionTexturePath; },\n/* harmony export */   iconifyIcons: function() { return /* binding */ iconifyIcons; },\n/* harmony export */   legsModelPath: function() { return /* binding */ legsModelPath; },\n/* harmony export */   menuIconPaths: function() { return /* binding */ menuIconPaths; },\n/* harmony export */   noLegsModelPath: function() { return /* binding */ noLegsModelPath; },\n/* harmony export */   plywoodTextures: function() { return /* binding */ plywoodTextures; },\n/* harmony export */   shadowManModelPath: function() { return /* binding */ shadowManModelPath; },\n/* harmony export */   tvModelPath: function() { return /* binding */ tvModelPath; },\n/* harmony export */   veneerTextures: function() { return /* binding */ veneerTextures; },\n/* harmony export */   verticalOcclusionTexturePath: function() { return /* binding */ verticalOcclusionTexturePath; },\n/* harmony export */   wallColor: function() { return /* binding */ wallColor; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./columnLayoutOptions */ \"(app-pages-browser)/./src/utils/columnLayoutOptions.ts\");\n\n\n//--- CONSTANTS\n// Dimensions\nconst PLATE_THICKNESS = 0.02;\nconst CELL_SIZE = {\n    maxWidth: 0.60,\n    minWidth: 0.25,\n    maxHeight: 0.35,\n    minHeight: 0.15\n};\nconst LEG_HEIGHT = 0.18;\nconst LEG_WIDTH = 0.05;\nconst LEG_DEPTH = 0.05;\nconst EDGE_GAP = 0.006;\n// Colors\nconst wallColor = \"#e7e7e7\";\nconst floorColor = \"#b7b7b7\";\nconst ambientLightColor = \"#f0f0f0\";\nconst directionalLightColor = \"#f0f0f0\";\n// Texture paths\nconst texturesRootPath = \"/assets/textures/\";\nconst environmentPath = texturesRootPath + \"environment.hdr\";\nconst plywoodRootPath = texturesRootPath + \"plywood_1k/textures/\";\nconst plywoodAoMapPath = plywoodRootPath + \"plywood_ao_1k.jpg\";\nconst plywoodNormalMapPath = plywoodRootPath + \"plywood_nor_gl_1k.jpg\";\nconst plywoodRoughnessMapPath = plywoodRootPath + \"plywood_rough_1k.jpg\";\nconst plywoodTextures = {\n    aoMap: plywoodAoMapPath,\n    normalMap: plywoodNormalMapPath,\n    roughnessMap: plywoodRoughnessMapPath\n};\n// Base Textures Veener\nconst woodRootPath = texturesRootPath + \"wood_27/\";\nconst veneerAoMapPath = woodRootPath + \"ambient-occlusion.jpg\";\nconst veneerNormalMapPath = woodRootPath + \"normal.jpg\";\nconst veneerRoughnessMapPath = woodRootPath + \"roughness.jpg\";\nconst veneerTextures = {\n    aoMap: veneerAoMapPath,\n    normalMap: veneerNormalMapPath,\n    roughnessMap: veneerRoughnessMapPath\n};\nvar EVeneerTextures;\n(function(EVeneerTextures) {\n    EVeneerTextures[EVeneerTextures[\"BEIGE_GREY_LORENZO_OAK\"] = texturesRootPath + \"veneer-oak-wood/beige_grey_lorenzo_oak.jpg\"] = \"BEIGE_GREY_LORENZO_OAK\";\n    // BEIGE_TEXTILE = texturesRootPath + 'veneer-oak-wood/beige_textile.jpg',\n    EVeneerTextures[EVeneerTextures[\"BROWN_ABANO_ASH\"] = texturesRootPath + \"veneer-oak-wood/brown_abano_ash.jpg\"] = \"BROWN_ABANO_ASH\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_HALIFAX_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_halifax_oak.jpg\"] = \"BROWN_HALIFAX_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_TONNSBERG_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_tonnsberg_oak.jpg\"] = \"BROWN_TONNSBERG_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_WARMIA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/brown_warmia_wallnut.jpg\"] = \"BROWN_WARMIA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_BARONIA_OAK\"] = texturesRootPath + \"veneer-oak-wood/light_baronia_oak.jpg\"] = \"LIGHT_BARONIA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_NATURAL_DAVENPORT_OAK\"] = texturesRootPath + \"veneer-oak-wood/Light_Natural_Davenport_oak.jpg\"] = \"LIGHT_NATURAL_DAVENPORT_OAK\";\n    EVeneerTextures[EVeneerTextures[\"NATURAL_CASELLA_OAK\"] = texturesRootPath + \"veneer-oak-wood/natural_casella_oak.jpg\"] = \"NATURAL_CASELLA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"PARONA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/parona_wallnut.jpg\"] = \"PARONA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"SEVILLA_ASH\"] = texturesRootPath + \"veneer-oak-wood/sevilla_ash.jpg\"] = \"SEVILLA_ASH\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak.jpg\"] = \"VICENZA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK_2\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak2.jpg\"] = \"VICENZA_OAK_2\";\n})(EVeneerTextures || (EVeneerTextures = {}));\nvar EPlywoodTextures;\n(function(EPlywoodTextures) {\n    EPlywoodTextures[EPlywoodTextures[\"BRONZE_BRUSHED_METAL\"] = texturesRootPath + \"plywood-colors/bronze_brushed_metal.jpg\"] = \"BRONZE_BRUSHED_METAL\";\n    EPlywoodTextures[EPlywoodTextures[\"ALMOND_BEIGE\"] = texturesRootPath + \"plywood-colors/almond_beige.jpg\"] = \"ALMOND_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CARAT_BEIGE\"] = texturesRootPath + \"plywood-colors/carat_beige.jpg\"] = \"CARAT_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CASHMERE_GREY\"] = texturesRootPath + \"plywood-colors/cashmere_grey.jpg\"] = \"CASHMERE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"CORA_BRONZE\"] = texturesRootPath + \"plywood-colors/cobra_bronze.jpg\"] = \"CORA_BRONZE\";\n    EPlywoodTextures[EPlywoodTextures[\"CUBANITE_GREY\"] = texturesRootPath + \"plywood-colors/cubanite_grey.jpg\"] = \"CUBANITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"FIR_GREEN\"] = texturesRootPath + \"plywood-colors/fir_green.jpg\"] = \"FIR_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"FJORD_GREEN\"] = texturesRootPath + \"plywood-colors/fjord_green.jpg\"] = \"FJORD_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"GRAPHITE_GREY\"] = texturesRootPath + \"plywood-colors/graphite_grey.jpg\"] = \"GRAPHITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"INDIGO_BLUE\"] = texturesRootPath + \"plywood-colors/indigo_blue.jpg\"] = \"INDIGO_BLUE\";\n    EPlywoodTextures[EPlywoodTextures[\"REED_GREEN\"] = texturesRootPath + \"plywood-colors/reed_green.jpg\"] = \"REED_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"SAGE_GREEN\"] = texturesRootPath + \"plywood-colors/sage_green.jpg\"] = \"SAGE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"STONE_GREEN\"] = texturesRootPath + \"plywood-colors/stone_green.jpg\"] = \"STONE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"TAUPE_GREY\"] = texturesRootPath + \"plywood-colors/taupe_grey.jpg\"] = \"TAUPE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"TRUFFLE_BROWN\"] = texturesRootPath + \"plywood-colors/truffle_brown.jpg\"] = \"TRUFFLE_BROWN\";\n    EPlywoodTextures[EPlywoodTextures[\"U999_PM_BLACK\"] = texturesRootPath + \"plywood-colors/U999_PM_Black.jpg\"] = \"U999_PM_BLACK\";\n})(EPlywoodTextures || (EPlywoodTextures = {}));\n// Occlusion Textures\nconst horizontalOcclusionTexturePath = texturesRootPath + \"horizontal-panel.jpg\";\nconst verticalOcclusionTexturePath = texturesRootPath + \"vertical-panel.jpg\";\nconst backOcclusionTexturePath = texturesRootPath + \"back-panel.jpg\";\nvar EOcclusionImages;\n(function(EOcclusionImages) {\n    EOcclusionImages[EOcclusionImages[\"HORIZONTAL\"] = horizontalOcclusionTexturePath] = \"HORIZONTAL\";\n    EOcclusionImages[EOcclusionImages[\"BACK\"] = verticalOcclusionTexturePath] = \"BACK\";\n    EOcclusionImages[EOcclusionImages[\"VERTICAL\"] = backOcclusionTexturePath] = \"VERTICAL\";\n})(EOcclusionImages || (EOcclusionImages = {}));\n// Layout Icons\nconst layoutIconRootPath = \"/assets/icons/on-model-editor/\";\nconst iconifyIcons = {\n    layoutIcons: {\n        undoIcon: \"solar:undo-left-round-outline\",\n        dimensionsIcon: \"solar:ruler-linear\",\n        doorsIcon: \"fluent:door-20-regular\",\n        alignColumnsIcon: \"flowbite:grid-plus-outline\",\n        showDecorationsIcon: \"hugeicons:paint-brush-02\",\n        assemblyIcon: \"carbon:3d-cursor\"\n    },\n    menuIcons: {\n        arrowUp: \"iwwa:arrow-up\",\n        arrowDown: \"iwwa:arrow-down\",\n        infoQuestion: \"ph:question-bold\"\n    },\n    sceneIcons: {\n        editLayout: \"ic-outline-create\"\n    }\n};\nconst menuIconPaths = {\n    legs: {\n        no_leg: \"/assets/icons/menu-icons/legs/no_leg.svg\",\n        legs: \"/assets/icons/menu-icons/legs/legs.svg\",\n        floating: \"/assets/icons/menu-icons/legs/floating.svg\"\n    },\n    handles: {\n        handle_a: \"/assets/icons/menu-icons/handles/handle_A.svg\",\n        handle_b: \"/assets/icons/menu-icons/handles/handle_B.svg\",\n        push: \"/assets/icons/menu-icons/handles/push.svg\"\n    },\n    styles: {\n        frame: \"/assets/icons/menu-icons/styles/frame.svg\",\n        gradient: \"/assets/icons/menu-icons/styles/gradient.svg\",\n        grid: \"/assets/icons/menu-icons/styles/grid.svg\",\n        mosaic: \"/assets/icons/menu-icons/styles/mosaic.svg\",\n        pixel: \"/assets/icons/menu-icons/styles/pixel.svg\",\n        slant: \"/assets/icons/menu-icons/styles/slant.svg\"\n    }\n};\nconst generateLayoutIcons = (layoutHeight, iconCount)=>{\n    const layoutRootPath = \"\".concat(layoutIconRootPath).concat(layoutHeight, \"/\");\n    return Array.from({\n        length: iconCount\n    }, (_, i)=>\"\".concat(layoutRootPath).concat(i + 1, \".svg\"));\n};\n// Generating icon paths for each layout\nconst layout53Icons = generateLayoutIcons(53, 3);\nconst layout63Icons = generateLayoutIcons(63, 6);\nconst layout73Icons = generateLayoutIcons(73, 7);\nconst layout93Icons = generateLayoutIcons(93, 8);\nconst layout103Icons = generateLayoutIcons(103, 8);\nconst layout123Icons = generateLayoutIcons(123, 8);\nconst layout133Icons = generateLayoutIcons(133, 6); // Adjusted for 6 icons only\nconst layout143Icons = generateLayoutIcons(143, 6);\n// Model Paths\nconst modelsRootPath = \"/assets/models/\";\nconst shadowManModelPath = modelsRootPath + \"shadow_man.glb\";\nconst handleAModelPath = modelsRootPath + \"handle_A.glb\";\nconst handleBModelPath = modelsRootPath + \"handle_B.glb\";\nconst legsModelPath = modelsRootPath + \"legs.glb\";\nconst noLegsModelPath = modelsRootPath + \"no_legs.glb\";\nconst tvModelPath = modelsRootPath + \"tv.glb\";\nvar ECabinetStyle;\n(function(ECabinetStyle) {\n    ECabinetStyle[\"GRID\"] = \"grid\";\n    ECabinetStyle[\"GRADIENT\"] = \"gradient\";\n    ECabinetStyle[\"MOSAIC\"] = \"mosaic\";\n    ECabinetStyle[\"FRAME\"] = \"frame\";\n    ECabinetStyle[\"SLANT\"] = \"slant\";\n    ECabinetStyle[\"PIXEL\"] = \"pixel\";\n    ECabinetStyle[\"MODERN\"] = \"modern\";\n    ECabinetStyle[\"CLASSIC\"] = \"classic\";\n})(ECabinetStyle || (ECabinetStyle = {}));\nvar ECabinetLegs;\n(function(ECabinetLegs) {\n    ECabinetLegs[\"LEGS\"] = \"LEGS\";\n    ECabinetLegs[\"NO_LEG\"] = \"NO_LEG\";\n    ECabinetLegs[\"FLOATING\"] = \"FLOATING\";\n})(ECabinetLegs || (ECabinetLegs = {}));\nvar ECabinetHandles;\n(function(ECabinetHandles) {\n    ECabinetHandles[\"HANDLE_A\"] = \"HANDLE_A\";\n    ECabinetHandles[\"HANDLE_B\"] = \"HANDLE_B\";\n    ECabinetHandles[\"PUSH\"] = \"PUSH\";\n})(ECabinetHandles || (ECabinetHandles = {}));\nvar ECabinetFinishes;\n(function(ECabinetFinishes) {\n    ECabinetFinishes[\"PLYWOOD\"] = \"Plywood\";\n    ECabinetFinishes[\"VENEER\"] = \"Veneer\";\n})(ECabinetFinishes || (ECabinetFinishes = {}));\n// Functions\n// Get the array of remaining columns widths\nconst getWidthArray = (style, totalWidth)=>{\n    let widthArray = [];\n    const unit = 100;\n    switch(style){\n        case \"grid\":\n            if (totalWidth < CELL_SIZE.maxWidth * unit) {\n                widthArray = [\n                    totalWidth - 2 * PLATE_THICKNESS * unit\n                ];\n            } else if (totalWidth < 112) {\n                widthArray = getRemainingColumns(totalWidth - 3 * PLATE_THICKNESS * unit);\n            } else if (totalWidth < 154) {\n                widthArray = [\n                    44\n                ];\n            } else if (totalWidth < 197) {\n                widthArray = [\n                    44,\n                    38\n                ];\n            } else if (totalWidth < 243) {\n                widthArray = [\n                    44,\n                    38,\n                    44\n                ];\n            } else if (totalWidth < 282) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37\n                ];\n            } else if (totalWidth < 327) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43\n                ];\n            } else if (totalWidth < 372) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43\n                ];\n            } else if (totalWidth < 412) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38\n                ];\n            } else {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38,\n                    44\n                ];\n            }\n            break;\n        default:\n            break;\n    }\n    return widthArray;\n};\n// Get the vertical layout of a column for a given cabinet height\nconst getColumnVerticalLayout = (param)=>{\n    let { cabinetHeight } = param;\n    const currentlayout = [];\n    const numberOfRows = getRowCount({\n        cabinetHeight\n    });\n    for(let i = 0; i < numberOfRows; i++){\n        currentlayout.push({\n            index: i,\n            height: getCellHeight(numberOfRows, cabinetHeight)\n        });\n    }\n    return currentlayout;\n};\n// Get the distance between two Vector3s\nfunction getDistance(p1, p2) {\n    // return the square root of the sum of the squares of the differences of the x and z coordinates\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.z - p1.z) ** 2);\n}\n// Get the count of rows for a given cabinet height\nfunction getRowCount(param) {\n    let { cabinetHeight } = param;\n    // Get the maximum height of a cell\n    const maxHeight = CELL_SIZE.maxHeight;\n    // Return the number of rows\n    return Math.floor((cabinetHeight - PLATE_THICKNESS) / (maxHeight + PLATE_THICKNESS)) + 1;\n}\n// Get the number of columns and the width of a cell for a given total width\nfunction getColumnCount(param) {\n    let { totalWidth } = param;\n    // Get the maximum width of a cell\n    const maxWidth = CELL_SIZE.maxWidth;\n    // Get the number of columns according to the total width\n    const numberOfColumns = Math.floor((totalWidth - PLATE_THICKNESS) / (maxWidth + PLATE_THICKNESS)) + 1;\n    // Get the total width of cells without\n    const sum = totalWidth - (numberOfColumns + 1) * PLATE_THICKNESS;\n    // Round to 2 decimal places\n    const widthOfCell = Math.round(sum / numberOfColumns * 100) / 100;\n    return {\n        numberOfColumns,\n        widthOfCell\n    };\n}\n// Get the height of a cell for a given number of rows and a cabinet height\nfunction getCellHeight(rowCount, cabinetHeight) {\n    // Get the height of a cell\n    const cellHeight = (cabinetHeight - (rowCount - 1) * PLATE_THICKNESS) / rowCount;\n    return cellHeight;\n}\n// Get the width of a cell for a given number of columns and a total width\nfunction getCellWidth(columnCount, totalWidth) {\n    // Get the width of a cell\n    const cellWidth = (totalWidth - (columnCount + 1) * PLATE_THICKNESS) / columnCount;\n    return cellWidth;\n}\nfunction getBottomHeight(legs) {\n    return legs === \"NO_LEG\" ? 0.02 : LEG_HEIGHT;\n}\nfunction getPartitonPlates(param) {\n    let { columns, totalHeight, totalWidth, totalDepth, legHeight } = param;\n    const verticals = [];\n    const horizontals = [];\n    const availableSpaces = [];\n    const backsides = [];\n    const spaceHeight = totalHeight - 2 * PLATE_THICKNESS - legHeight;\n    const posY = (totalHeight + legHeight) / 2;\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    verticals.push({\n        row: 0,\n        col: -1,\n        position: {\n            x: startPosX,\n            y: posY,\n            z: 0\n        },\n        scale: {\n            width: spaceHeight,\n            depth: totalDepth\n        }\n    });\n    for(let col = 0; col < columns.length; col++){\n        const column = columns[col];\n        const rows = column.rows;\n        let sum = 0;\n        for(let i = 0; i < col + 1; i++){\n            sum += columns[i].width;\n        }\n        const posX = startPosX + sum + (col + 1) * PLATE_THICKNESS;\n        const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n        verticals.push({\n            row: 0,\n            col,\n            position: {\n                x: posX,\n                y: posY,\n                z: 0\n            },\n            scale: {\n                width: spaceHeight,\n                depth: totalDepth\n            }\n        });\n        availableSpaces.push({\n            row: 0,\n            col,\n            position: {\n                x: spacePosX,\n                y: posY,\n                z: totalDepth / 2\n            },\n            scale: {\n                width: column.width,\n                depth: spaceHeight\n            }\n        });\n        for(let rowIndex = 0; rowIndex < rows.length; rowIndex++){\n            let verticalSum = 0;\n            for(let p = 0; p < rowIndex + 1; p++){\n                verticalSum += rows[rowIndex].height;\n            }\n            const middlePosY = bottomPosY + verticalSum + (rowIndex + 1) * PLATE_THICKNESS;\n            const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[rowIndex].height / 2;\n            const backPosZ = -(totalDepth - PLATE_THICKNESS) / 2;\n            if (rowIndex < rows.length - 1) {\n                horizontals.push({\n                    row: rowIndex,\n                    col,\n                    position: {\n                        x: spacePosX,\n                        y: middlePosY,\n                        z: 0\n                    },\n                    scale: {\n                        width: column.width,\n                        depth: totalDepth - EDGE_GAP\n                    }\n                });\n            }\n            backsides.push({\n                row: rowIndex,\n                col,\n                position: {\n                    x: spacePosX,\n                    y: backPosY,\n                    z: backPosZ\n                },\n                scale: {\n                    width: column.width,\n                    depth: rows[rowIndex].height\n                }\n            });\n        }\n    }\n    return {\n        verticals,\n        availableSpaces,\n        horizontals,\n        backsides\n    };\n}\n// Fix the function signature\nconst getCalculatedColumns = (param)=>{\n    let { current, cabinetSize, cabinetStyle, legHeight, columnCount } = param;\n    const { totalWidth, totalHeight } = cabinetSize;\n    // Calculate available width (total width minus side plates)\n    const availableWidth = totalWidth - 2 * PLATE_THICKNESS;\n    // Determine how many columns can fit\n    let numColumns;\n    if (columnCount) {\n        numColumns = columnCount;\n    } else {\n        // Calculate based on minimum column width\n        numColumns = Math.floor(availableWidth / (CELL_SIZE.minWidth + PLATE_THICKNESS));\n        // Ensure at least one column\n        numColumns = Math.max(1, numColumns);\n    }\n    // Calculate column width\n    const columnWidth = (availableWidth - (numColumns - 1) * PLATE_THICKNESS) / numColumns;\n    // Create columns array\n    const columns = [];\n    // Generate each column\n    for(let i = 0; i < numColumns; i++){\n        // Calculate position\n        const posX = -totalWidth / 2 + PLATE_THICKNESS + i * (columnWidth + PLATE_THICKNESS) + columnWidth / 2;\n        // Create column with appropriate layout\n        const column = createColumnWithLayout(columnWidth, posX, totalHeight, legHeight, cabinetStyle);\n        columns.push(column);\n    }\n    return columns;\n};\nfunction getRemainingColumns(remainingWidth) {\n    const b = remainingWidth % 2 === 0 ? remainingWidth / 2 : (remainingWidth + 1) / 2;\n    const c = remainingWidth - b;\n    return [\n        b,\n        c\n    ];\n}\nfunction getIndividualColumn(param) {\n    let { targetIndex, columns, totalWidth, totalDepth, legHeight } = param;\n    const column = columns[targetIndex];\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    const rowsPos = [];\n    const delta = 0.02;\n    const rows = column.rows;\n    let sum = 0;\n    for(let i = 0; i < targetIndex + 1; i++){\n        sum += columns[i].width;\n    }\n    const posX = startPosX + sum + (targetIndex + 1) * PLATE_THICKNESS;\n    const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n    for(let i = 0; i < rows.length; i++){\n        let verticalSum = 0;\n        for(let p = 0; p < i + 1; p++){\n            verticalSum += rows[p].height;\n        }\n        const middlePosY = bottomPosY + verticalSum + (i + 1) * PLATE_THICKNESS;\n        const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[i].height / 2;\n        rowsPos.push({\n            x: spacePosX - column.width / 2,\n            y: backPosY,\n            z: totalDepth / 2 + delta,\n            height: rows[i].height\n        });\n    }\n    return {\n        position: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(spacePosX, legHeight + PLATE_THICKNESS + delta, totalDepth / 2 + delta),\n        rows: rowsPos\n    };\n}\nconst getLayoutImages = (param)=>{\n    let { totalHeight } = param;\n    let imgsArray = [];\n    if (totalHeight < 0.53) {\n        imgsArray = [\n            ...layout53Icons\n        ];\n    } else if (totalHeight < 0.63) {\n        imgsArray = [\n            ...layout63Icons\n        ];\n    } else if (totalHeight < 0.73) {\n        imgsArray = [\n            ...layout73Icons\n        ];\n    } else if (totalHeight < 0.93) {\n        imgsArray = [\n            ...layout93Icons\n        ];\n    } else if (totalHeight < 1.03) {\n        imgsArray = [\n            ...layout103Icons\n        ];\n    } else if (totalHeight < 1.23) {\n        imgsArray = [\n            ...layout123Icons\n        ];\n    } else if (totalHeight < 1.33) {\n        imgsArray = [\n            ...layout133Icons\n        ];\n    } else {\n        imgsArray = [\n            ...layout143Icons\n        ];\n    }\n    return imgsArray;\n};\nconst getId = (item)=>\"\".concat(item, \"-\").concat(Math.random().toString(32).slice(-4));\nconst createColumnWithLayout = (columnWidth, posX, totalHeight, legHeight, cabinetStyle)=>{\n    // Calculate the cabinet height (excluding legs and plate thickness)\n    const cabinetHeight = totalHeight - legHeight - 2 * PLATE_THICKNESS;\n    // Get the basic vertical layout for the column\n    const rows = getColumnVerticalLayout({\n        cabinetHeight\n    });\n    // Get the starting position Y coordinate\n    const startPosY = legHeight + PLATE_THICKNESS;\n    // Default to an empty layout (will be populated based on style)\n    let layoutIndex = 0;\n    let doors = [];\n    let drawers = [];\n    // Based on cabinet style, choose an appropriate layout\n    switch(cabinetStyle){\n        case \"modern\":\n            // For modern style, use all drawers\n            layoutIndex = 1;\n            // Create a drawer for each row\n            drawers = rows.map((row, index)=>({\n                    index,\n                    size: {\n                        width: columnWidth,\n                        height: row.height\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + (index + 0.5) * row.height + index * PLATE_THICKNESS\n                    }\n                }));\n            break;\n        case \"classic\":\n        default:\n            // For classic style, use doors for all rows\n            layoutIndex = 0;\n            // Create a door for the full height\n            doors = [\n                {\n                    index: 0,\n                    size: {\n                        width: columnWidth,\n                        height: cabinetHeight\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + cabinetHeight / 2\n                    },\n                    opening: 1\n                }\n            ];\n            break;\n    }\n    // Create and return the column object\n    return {\n        id: Math.random().toString(36).substr(2, 9),\n        index: 0,\n        width: columnWidth,\n        posX: posX,\n        rows: rows,\n        doors: doors,\n        drawers: drawers,\n        dividers: [],\n        layoutIndex: layoutIndex,\n        isDivide: false,\n        lastRow: drawers.length > 0 ? \"drawer\" : \"door\"\n    };\n};\n// Update the cabinet size constraints\nconst CABINET_SIZE_CONSTRAINTS = {\n    minWidth: 0.4,\n    maxWidth: 2.5,\n    minHeight: 0.4,\n    maxHeight: 2.4,\n    minDepth: 0.3,\n    maxDepth: 0.8\n};\nconst applyRandomLayoutsToColumns = (columns, totalHeight, legHeight)=>{\n    const startPosY = legHeight + PLATE_THICKNESS;\n    return columns.map((column)=>{\n        // Get all available layout options for this column\n        const layoutOptions = (0,_columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__.getLayoutOptionsOfColumn)({\n            totalHeight,\n            legHeight,\n            columnWidth: column.width,\n            posX: column.posX,\n            startPosY,\n            doorDir: 1 // Default door opening direction\n        });\n        // Select a random layout option\n        const randomLayoutIndex = Math.floor(Math.random() * layoutOptions.length);\n        const randomLayout = layoutOptions[randomLayoutIndex];\n        // Apply the random layout to the column\n        return {\n            ...column,\n            layoutIndex: randomLayoutIndex,\n            rows: randomLayout.rows,\n            doors: randomLayout.doors,\n            drawers: randomLayout.drawers,\n            lastRow: randomLayout.lastRow\n        };\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy91dGlsaXRpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDK0I7QUFFa0M7QUFFakUsZUFBZTtBQUNmLGFBQWE7QUFDTixNQUFNRSxrQkFBa0IsS0FBSztBQUM3QixNQUFNQyxZQUFZO0lBQ3ZCQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxXQUFXO0FBQ2IsRUFBRTtBQUNLLE1BQU1DLGFBQWEsS0FBSztBQUN4QixNQUFNQyxZQUFZLEtBQUs7QUFDdkIsTUFBTUMsWUFBWSxLQUFLO0FBQ3ZCLE1BQU1DLFdBQVcsTUFBTTtBQUU5QixTQUFTO0FBQ0YsTUFBTUMsWUFBWSxVQUFVO0FBQzVCLE1BQU1DLGFBQWEsVUFBVTtBQUM3QixNQUFNQyxvQkFBb0IsVUFBVTtBQUNwQyxNQUFNQyx3QkFBd0IsVUFBVTtBQUUvQyxnQkFBZ0I7QUFDaEIsTUFBTUMsbUJBQW1CO0FBQ2xCLE1BQU1DLGtCQUFrQkQsbUJBQW1CLGtCQUFrQjtBQUNwRSxNQUFNRSxrQkFBa0JGLG1CQUFtQjtBQUMzQyxNQUFNRyxtQkFBbUJELGtCQUFrQjtBQUMzQyxNQUFNRSx1QkFBdUJGLGtCQUFrQjtBQUMvQyxNQUFNRywwQkFBMEJILGtCQUFrQjtBQUUzQyxNQUFNSSxrQkFBa0I7SUFDN0JDLE9BQU9KO0lBQ1BLLFdBQVdKO0lBQ1hLLGNBQWNKO0FBQ2hCLEVBQUU7QUFFRix1QkFBdUI7QUFDdkIsTUFBTUssZUFBZVYsbUJBQW1CO0FBQ3hDLE1BQU1XLGtCQUFrQkQsZUFBZTtBQUN2QyxNQUFNRSxzQkFBc0JGLGVBQWU7QUFDM0MsTUFBTUcseUJBQXlCSCxlQUFlO0FBRXZDLE1BQU1JLGlCQUFpQjtJQUM1QlAsT0FBT0k7SUFDUEgsV0FBV0k7SUFDWEgsY0FBY0k7QUFDaEIsRUFBRTs7VUFHVUU7Z0VBQ2VmO0lBQ3pCLDBFQUEwRTt5REFD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QUFLbUUsTUFBTSxLQUFLb0IsY0FBYzlILE1BQU07UUFDekUsTUFBTWlJLGVBQWVILGFBQWEsQ0FBQ0Usa0JBQWtCO1FBRXJELHdDQUF3QztRQUN4QyxPQUFPO1lBQ0wsR0FBR3JELE1BQU07WUFDVG1DLGFBQWFrQjtZQUNicEQsTUFBTXFELGFBQWFyRCxJQUFJO1lBQ3ZCbUMsT0FBT2tCLGFBQWFsQixLQUFLO1lBQ3pCQyxTQUFTaUIsYUFBYWpCLE9BQU87WUFDN0JTLFNBQVNRLGFBQWFSLE9BQU87UUFDL0I7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3V0aWxpdGllcy50cz8zMTFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElDYWJpbmV0U2l6ZSwgSUNvbHVtbiwgSVBhcnRpdGlvbiB9IGZyb20gJ0Avc3RvcmUvdHlwZXMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGdldExheW91dE9wdGlvbnNPZkNvbHVtbiB9IGZyb20gJy4vY29sdW1uTGF5b3V0T3B0aW9ucyc7XG5cbi8vLS0tIENPTlNUQU5UU1xuLy8gRGltZW5zaW9uc1xuZXhwb3J0IGNvbnN0IFBMQVRFX1RISUNLTkVTUyA9IDAuMDI7XG5leHBvcnQgY29uc3QgQ0VMTF9TSVpFID0ge1xuICBtYXhXaWR0aDogMC42MCxcbiAgbWluV2lkdGg6IDAuMjUsXG4gIG1heEhlaWdodDogMC4zNSxcbiAgbWluSGVpZ2h0OiAwLjE1LFxufTtcbmV4cG9ydCBjb25zdCBMRUdfSEVJR0hUID0gMC4xODtcbmV4cG9ydCBjb25zdCBMRUdfV0lEVEggPSAwLjA1O1xuZXhwb3J0IGNvbnN0IExFR19ERVBUSCA9IDAuMDU7XG5leHBvcnQgY29uc3QgRURHRV9HQVAgPSAwLjAwNjtcblxuLy8gQ29sb3JzXG5leHBvcnQgY29uc3Qgd2FsbENvbG9yID0gJyNlN2U3ZTcnO1xuZXhwb3J0IGNvbnN0IGZsb29yQ29sb3IgPSAnI2I3YjdiNyc7XG5leHBvcnQgY29uc3QgYW1iaWVudExpZ2h0Q29sb3IgPSAnI2YwZjBmMCc7XG5leHBvcnQgY29uc3QgZGlyZWN0aW9uYWxMaWdodENvbG9yID0gJyNmMGYwZjAnO1xuXG4vLyBUZXh0dXJlIHBhdGhzXG5jb25zdCB0ZXh0dXJlc1Jvb3RQYXRoID0gJy9hc3NldHMvdGV4dHVyZXMvJztcbmV4cG9ydCBjb25zdCBlbnZpcm9ubWVudFBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ2Vudmlyb25tZW50Lmhkcic7XG5jb25zdCBwbHl3b29kUm9vdFBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2RfMWsvdGV4dHVyZXMvJztcbmNvbnN0IHBseXdvb2RBb01hcFBhdGggPSBwbHl3b29kUm9vdFBhdGggKyAncGx5d29vZF9hb18xay5qcGcnO1xuY29uc3QgcGx5d29vZE5vcm1hbE1hcFBhdGggPSBwbHl3b29kUm9vdFBhdGggKyAncGx5d29vZF9ub3JfZ2xfMWsuanBnJztcbmNvbnN0IHBseXdvb2RSb3VnaG5lc3NNYXBQYXRoID0gcGx5d29vZFJvb3RQYXRoICsgJ3BseXdvb2Rfcm91Z2hfMWsuanBnJztcblxuZXhwb3J0IGNvbnN0IHBseXdvb2RUZXh0dXJlcyA9IHtcbiAgYW9NYXA6IHBseXdvb2RBb01hcFBhdGgsXG4gIG5vcm1hbE1hcDogcGx5d29vZE5vcm1hbE1hcFBhdGgsXG4gIHJvdWdobmVzc01hcDogcGx5d29vZFJvdWdobmVzc01hcFBhdGgsXG59O1xuXG4vLyBCYXNlIFRleHR1cmVzIFZlZW5lclxuY29uc3Qgd29vZFJvb3RQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICd3b29kXzI3Lyc7XG5jb25zdCB2ZW5lZXJBb01hcFBhdGggPSB3b29kUm9vdFBhdGggKyAnYW1iaWVudC1vY2NsdXNpb24uanBnJztcbmNvbnN0IHZlbmVlck5vcm1hbE1hcFBhdGggPSB3b29kUm9vdFBhdGggKyAnbm9ybWFsLmpwZyc7XG5jb25zdCB2ZW5lZXJSb3VnaG5lc3NNYXBQYXRoID0gd29vZFJvb3RQYXRoICsgJ3JvdWdobmVzcy5qcGcnO1xuXG5leHBvcnQgY29uc3QgdmVuZWVyVGV4dHVyZXMgPSB7XG4gIGFvTWFwOiB2ZW5lZXJBb01hcFBhdGgsXG4gIG5vcm1hbE1hcDogdmVuZWVyTm9ybWFsTWFwUGF0aCxcbiAgcm91Z2huZXNzTWFwOiB2ZW5lZXJSb3VnaG5lc3NNYXBQYXRoLFxufTtcblxuLy8gVmVuZWVyIFRleHR1cmVzXG5leHBvcnQgZW51bSBFVmVuZWVyVGV4dHVyZXMge1xuICBCRUlHRV9HUkVZX0xPUkVOWk9fT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYmVpZ2VfZ3JleV9sb3JlbnpvX29hay5qcGcnLFxuICAvLyBCRUlHRV9URVhUSUxFID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYmVpZ2VfdGV4dGlsZS5qcGcnLFxuICBCUk9XTl9BQkFOT19BU0ggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9icm93bl9hYmFub19hc2guanBnJyxcbiAgQlJPV05fSEFMSUZBWF9PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9icm93bl9oYWxpZmF4X29hay5qcGcnLFxuICBCUk9XTl9UT05OU0JFUkdfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYnJvd25fdG9ubnNiZXJnX29hay5qcGcnLFxuICBCUk9XTl9XQVJNSUFfV0FMTE5VVCA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2Jyb3duX3dhcm1pYV93YWxsbnV0LmpwZycsXG4gIExJR0hUX0JBUk9OSUFfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvbGlnaHRfYmFyb25pYV9vYWsuanBnJyxcbiAgTElHSFRfTkFUVVJBTF9EQVZFTlBPUlRfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvTGlnaHRfTmF0dXJhbF9EYXZlbnBvcnRfb2FrLmpwZycsXG4gIE5BVFVSQUxfQ0FTRUxMQV9PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9uYXR1cmFsX2Nhc2VsbGFfb2FrLmpwZycsXG4gIFBBUk9OQV9XQUxMTlVUID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvcGFyb25hX3dhbGxudXQuanBnJyxcbiAgU0VWSUxMQV9BU0ggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9zZXZpbGxhX2FzaC5qcGcnLFxuICBWSUNFTlpBX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL3ZpY2VuemFfb2FrLmpwZycsXG4gIFZJQ0VOWkFfT0FLXzIgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC92aWNlbnphX29hazIuanBnJyxcbn1cblxuLy9QbHl3b29kIFRleHR1cmVzXG5leHBvcnQgZW51bSBFUGx5d29vZFRleHR1cmVzIHtcbiAgQlJPTlpFX0JSVVNIRURfTUVUQUwgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2Jyb256ZV9icnVzaGVkX21ldGFsLmpwZycsXG4gIEFMTU9ORF9CRUlHRSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvYWxtb25kX2JlaWdlLmpwZycsXG4gIENBUkFUX0JFSUdFID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9jYXJhdF9iZWlnZS5qcGcnLFxuICBDQVNITUVSRV9HUkVZID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9jYXNobWVyZV9ncmV5LmpwZycsXG4gIENPUkFfQlJPTlpFID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9jb2JyYV9icm9uemUuanBnJyxcbiAgQ1VCQU5JVEVfR1JFWSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvY3ViYW5pdGVfZ3JleS5qcGcnLFxuICBGSVJfR1JFRU4gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2Zpcl9ncmVlbi5qcGcnLFxuICBGSk9SRF9HUkVFTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvZmpvcmRfZ3JlZW4uanBnJyxcbiAgR1JBUEhJVEVfR1JFWSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvZ3JhcGhpdGVfZ3JleS5qcGcnLFxuICBJTkRJR09fQkxVRSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvaW5kaWdvX2JsdWUuanBnJyxcbiAgUkVFRF9HUkVFTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvcmVlZF9ncmVlbi5qcGcnLFxuICBTQUdFX0dSRUVOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9zYWdlX2dyZWVuLmpwZycsXG4gIFNUT05FX0dSRUVOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9zdG9uZV9ncmVlbi5qcGcnLFxuICBUQVVQRV9HUkVZID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy90YXVwZV9ncmV5LmpwZycsXG4gIFRSVUZGTEVfQlJPV04gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL3RydWZmbGVfYnJvd24uanBnJyxcbiAgVTk5OV9QTV9CTEFDSyA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvVTk5OV9QTV9CbGFjay5qcGcnLFxufVxuXG4vLyBPY2NsdXNpb24gVGV4dHVyZXNcbmV4cG9ydCBjb25zdCBob3Jpem9udGFsT2NjbHVzaW9uVGV4dHVyZVBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ2hvcml6b250YWwtcGFuZWwuanBnJztcbmV4cG9ydCBjb25zdCB2ZXJ0aWNhbE9jY2x1c2lvblRleHR1cmVQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICd2ZXJ0aWNhbC1wYW5lbC5qcGcnO1xuZXhwb3J0IGNvbnN0IGJhY2tPY2NsdXNpb25UZXh0dXJlUGF0aCA9IHRleHR1cmVzUm9vdFBhdGggKyAnYmFjay1wYW5lbC5qcGcnO1xuXG5leHBvcnQgZW51bSBFT2NjbHVzaW9uSW1hZ2VzIHtcbiAgSE9SSVpPTlRBTCA9IGhvcml6b250YWxPY2NsdXNpb25UZXh0dXJlUGF0aCxcbiAgQkFDSyA9IHZlcnRpY2FsT2NjbHVzaW9uVGV4dHVyZVBhdGgsXG4gIFZFUlRJQ0FMID0gYmFja09jY2x1c2lvblRleHR1cmVQYXRoLFxufVxuXG4vLyBMYXlvdXQgSWNvbnNcbmNvbnN0IGxheW91dEljb25Sb290UGF0aCA9ICcvYXNzZXRzL2ljb25zL29uLW1vZGVsLWVkaXRvci8nO1xuXG5leHBvcnQgY29uc3QgaWNvbmlmeUljb25zID0ge1xuICBsYXlvdXRJY29uczoge1xuICAgIHVuZG9JY29uOiAnc29sYXI6dW5kby1sZWZ0LXJvdW5kLW91dGxpbmUnLFxuICAgIGRpbWVuc2lvbnNJY29uOiAnc29sYXI6cnVsZXItbGluZWFyJyxcbiAgICBkb29yc0ljb246ICdmbHVlbnQ6ZG9vci0yMC1yZWd1bGFyJyxcbiAgICBhbGlnbkNvbHVtbnNJY29uOiAnZmxvd2JpdGU6Z3JpZC1wbHVzLW91dGxpbmUnLFxuICAgIHNob3dEZWNvcmF0aW9uc0ljb246ICdodWdlaWNvbnM6cGFpbnQtYnJ1c2gtMDInLFxuICAgIGFzc2VtYmx5SWNvbjogJ2NhcmJvbjozZC1jdXJzb3InLFxuICB9LFxuICBtZW51SWNvbnM6IHtcbiAgICBhcnJvd1VwOiAnaXd3YTphcnJvdy11cCcsXG4gICAgYXJyb3dEb3duOiAnaXd3YTphcnJvdy1kb3duJyxcbiAgICBpbmZvUXVlc3Rpb246ICdwaDpxdWVzdGlvbi1ib2xkJyxcbiAgfSxcbiAgc2NlbmVJY29uczoge1xuICAgIGVkaXRMYXlvdXQ6ICdpYy1vdXRsaW5lLWNyZWF0ZScsXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgbWVudUljb25QYXRoczoge1xuICBsZWdzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBoYW5kbGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBzdHlsZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59ID0ge1xuICBsZWdzOiB7XG4gICAgbm9fbGVnOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL2xlZ3Mvbm9fbGVnLnN2ZycsXG4gICAgbGVnczogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9sZWdzL2xlZ3Muc3ZnJyxcbiAgICBmbG9hdGluZzogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9sZWdzL2Zsb2F0aW5nLnN2ZycsXG4gIH0sXG4gIGhhbmRsZXM6IHtcbiAgICBoYW5kbGVfYTogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9oYW5kbGVzL2hhbmRsZV9BLnN2ZycsXG4gICAgaGFuZGxlX2I6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvaGFuZGxlcy9oYW5kbGVfQi5zdmcnLFxuICAgIHB1c2g6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvaGFuZGxlcy9wdXNoLnN2ZycsXG4gIH0sXG4gIHN0eWxlczoge1xuICAgIGZyYW1lOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9mcmFtZS5zdmcnLFxuICAgIGdyYWRpZW50OiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9ncmFkaWVudC5zdmcnLFxuICAgIGdyaWQ6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL2dyaWQuc3ZnJyxcbiAgICBtb3NhaWM6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvc3R5bGVzL21vc2FpYy5zdmcnLFxuICAgIHBpeGVsOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9waXhlbC5zdmcnLFxuICAgIHNsYW50OiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9zbGFudC5zdmcnLFxuICB9LFxufTtcblxuY29uc3QgZ2VuZXJhdGVMYXlvdXRJY29ucyA9IChsYXlvdXRIZWlnaHQ6IG51bWJlciwgaWNvbkNvdW50OiBudW1iZXIpID0+IHtcbiAgY29uc3QgbGF5b3V0Um9vdFBhdGggPSBgJHtsYXlvdXRJY29uUm9vdFBhdGh9JHtsYXlvdXRIZWlnaHR9L2A7XG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpY29uQ291bnQgfSwgKF8sIGkpID0+IGAke2xheW91dFJvb3RQYXRofSR7aSArIDF9LnN2Z2ApO1xufTtcblxuLy8gR2VuZXJhdGluZyBpY29uIHBhdGhzIGZvciBlYWNoIGxheW91dFxuY29uc3QgbGF5b3V0NTNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoNTMsIDMpO1xuY29uc3QgbGF5b3V0NjNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoNjMsIDYpO1xuY29uc3QgbGF5b3V0NzNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoNzMsIDcpO1xuY29uc3QgbGF5b3V0OTNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoOTMsIDgpO1xuY29uc3QgbGF5b3V0MTAzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDEwMywgOCk7XG5jb25zdCBsYXlvdXQxMjNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoMTIzLCA4KTtcbmNvbnN0IGxheW91dDEzM0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucygxMzMsIDYpOyAvLyBBZGp1c3RlZCBmb3IgNiBpY29ucyBvbmx5XG5jb25zdCBsYXlvdXQxNDNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoMTQzLCA2KTtcblxuLy8gTW9kZWwgUGF0aHNcbmNvbnN0IG1vZGVsc1Jvb3RQYXRoID0gJy9hc3NldHMvbW9kZWxzLyc7XG5cbmV4cG9ydCBjb25zdCBzaGFkb3dNYW5Nb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICdzaGFkb3dfbWFuLmdsYic7XG5leHBvcnQgY29uc3QgaGFuZGxlQU1vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ2hhbmRsZV9BLmdsYic7XG5leHBvcnQgY29uc3QgaGFuZGxlQk1vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ2hhbmRsZV9CLmdsYic7XG5leHBvcnQgY29uc3QgbGVnc01vZGVsUGF0aCA9IG1vZGVsc1Jvb3RQYXRoICsgJ2xlZ3MuZ2xiJztcbmV4cG9ydCBjb25zdCBub0xlZ3NNb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICdub19sZWdzLmdsYic7XG5leHBvcnQgY29uc3QgdHZNb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICd0di5nbGInO1xuXG4vLyBFbnVtc1xuZXhwb3J0IGVudW0gRUNhYmluZXRTdHlsZSB7XG4gIEdSSUQgPSAnZ3JpZCcsXG4gIEdSQURJRU5UID0gJ2dyYWRpZW50JyxcbiAgTU9TQUlDID0gJ21vc2FpYycsXG4gIEZSQU1FID0gJ2ZyYW1lJyxcbiAgU0xBTlQgPSAnc2xhbnQnLFxuICBQSVhFTCA9ICdwaXhlbCcsXG4gIE1PREVSTiA9ICdtb2Rlcm4nLFxuICBDTEFTU0lDID0gJ2NsYXNzaWMnLFxufVxuXG5leHBvcnQgZW51bSBFQ2FiaW5ldExlZ3Mge1xuICBMRUdTID0gJ0xFR1MnLFxuICBOT19MRUcgPSAnTk9fTEVHJyxcbiAgRkxPQVRJTkcgPSAnRkxPQVRJTkcnLFxufVxuXG5leHBvcnQgZW51bSBFQ2FiaW5ldEhhbmRsZXMge1xuICBIQU5ETEVfQSA9ICdIQU5ETEVfQScsXG4gIEhBTkRMRV9CID0gJ0hBTkRMRV9CJyxcbiAgUFVTSCA9ICdQVVNIJyxcbn1cblxuZXhwb3J0IGVudW0gRUNhYmluZXRGaW5pc2hlcyB7XG4gIFBMWVdPT0QgPSAnUGx5d29vZCcsXG4gIFZFTkVFUiA9ICdWZW5lZXInLFxufVxuXG4vLyBGdW5jdGlvbnNcblxuLy8gR2V0IHRoZSBhcnJheSBvZiByZW1haW5pbmcgY29sdW1ucyB3aWR0aHNcbmV4cG9ydCBjb25zdCBnZXRXaWR0aEFycmF5ID0gKHN0eWxlOiBFQ2FiaW5ldFN0eWxlLCB0b3RhbFdpZHRoOiBudW1iZXIpID0+IHtcbiAgbGV0IHdpZHRoQXJyYXk6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHVuaXQgPSAxMDA7XG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgICBjYXNlIEVDYWJpbmV0U3R5bGUuR1JJRDpcbiAgICAgIGlmICh0b3RhbFdpZHRoIDwgQ0VMTF9TSVpFLm1heFdpZHRoICogdW5pdCkge1xuICAgICAgICB3aWR0aEFycmF5ID0gW3RvdGFsV2lkdGggLSAyICogUExBVEVfVEhJQ0tORVNTICogdW5pdF07XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAxMTIpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IGdldFJlbWFpbmluZ0NvbHVtbnModG90YWxXaWR0aCAtIDMgKiBQTEFURV9USElDS05FU1MgKiB1bml0KTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDE1NCkge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0XTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDE5Nykge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOF07XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAyNDMpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0XTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDI4Mikge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOCwgNDQsIDM3XTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDMyNykge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOCwgNDQsIDM3LCA0M107XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAzNzIpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzNywgNDMsIDQzXTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxXaWR0aCA8IDQxMikge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOCwgNDQsIDM3LCA0MywgNDMsIDM4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NCwgMzcsIDQzLCA0MywgMzgsIDQ0XTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gd2lkdGhBcnJheTtcbn07XG5cbi8vIEdldCB0aGUgdmVydGljYWwgbGF5b3V0IG9mIGEgY29sdW1uIGZvciBhIGdpdmVuIGNhYmluZXQgaGVpZ2h0XG5leHBvcnQgY29uc3QgZ2V0Q29sdW1uVmVydGljYWxMYXlvdXQgPSAoeyBjYWJpbmV0SGVpZ2h0IH06IHsgY2FiaW5ldEhlaWdodDogbnVtYmVyIH0pID0+IHtcbiAgY29uc3QgY3VycmVudGxheW91dCA9IFtdO1xuICBjb25zdCBudW1iZXJPZlJvd3MgPSBnZXRSb3dDb3VudCh7IGNhYmluZXRIZWlnaHQgfSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZSb3dzOyBpKyspIHtcbiAgICBjdXJyZW50bGF5b3V0LnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBoZWlnaHQ6IGdldENlbGxIZWlnaHQobnVtYmVyT2ZSb3dzLCBjYWJpbmV0SGVpZ2h0KSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY3VycmVudGxheW91dDtcbn07XG5cbi8vIEdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gVmVjdG9yM3NcbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZShwMTogVmVjdG9yMywgcDI6IFZlY3RvcjMpIHtcbiAgLy8gcmV0dXJuIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHRoZSBkaWZmZXJlbmNlcyBvZiB0aGUgeCBhbmQgeiBjb29yZGluYXRlc1xuICByZXR1cm4gTWF0aC5zcXJ0KChwMi54IC0gcDEueCkgKiogMiArIChwMi56IC0gcDEueikgKiogMik7XG59XG5cbi8vIEdldCB0aGUgY291bnQgb2Ygcm93cyBmb3IgYSBnaXZlbiBjYWJpbmV0IGhlaWdodFxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvd0NvdW50KHsgY2FiaW5ldEhlaWdodCB9OiB7IGNhYmluZXRIZWlnaHQ6IG51bWJlciB9KSB7XG4gIC8vIEdldCB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYSBjZWxsXG4gIGNvbnN0IG1heEhlaWdodCA9IENFTExfU0laRS5tYXhIZWlnaHQ7XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2Ygcm93c1xuICByZXR1cm4gTWF0aC5mbG9vcigoY2FiaW5ldEhlaWdodCAtIFBMQVRFX1RISUNLTkVTUykgLyAobWF4SGVpZ2h0ICsgUExBVEVfVEhJQ0tORVNTKSkgKyAxO1xufVxuXG4vLyBHZXQgdGhlIG51bWJlciBvZiBjb2x1bW5zIGFuZCB0aGUgd2lkdGggb2YgYSBjZWxsIGZvciBhIGdpdmVuIHRvdGFsIHdpZHRoXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sdW1uQ291bnQoeyB0b3RhbFdpZHRoIH06IHsgdG90YWxXaWR0aDogbnVtYmVyIH0pIHtcbiAgLy8gR2V0IHRoZSBtYXhpbXVtIHdpZHRoIG9mIGEgY2VsbFxuICBjb25zdCBtYXhXaWR0aCA9IENFTExfU0laRS5tYXhXaWR0aDtcblxuICAvLyBHZXQgdGhlIG51bWJlciBvZiBjb2x1bW5zIGFjY29yZGluZyB0byB0aGUgdG90YWwgd2lkdGhcbiAgY29uc3QgbnVtYmVyT2ZDb2x1bW5zID0gTWF0aC5mbG9vcigodG90YWxXaWR0aCAtIFBMQVRFX1RISUNLTkVTUykgLyAobWF4V2lkdGggKyBQTEFURV9USElDS05FU1MpKSArIDE7XG5cbiAgLy8gR2V0IHRoZSB0b3RhbCB3aWR0aCBvZiBjZWxscyB3aXRob3V0XG4gIGNvbnN0IHN1bSA9IHRvdGFsV2lkdGggLSAobnVtYmVyT2ZDb2x1bW5zICsgMSkgKiBQTEFURV9USElDS05FU1M7XG5cbiAgLy8gUm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlc1xuICBjb25zdCB3aWR0aE9mQ2VsbCA9IE1hdGgucm91bmQoKHN1bSAvIG51bWJlck9mQ29sdW1ucykgKiAxMDApIC8gMTAwO1xuXG4gIHJldHVybiB7XG4gICAgbnVtYmVyT2ZDb2x1bW5zLFxuICAgIHdpZHRoT2ZDZWxsLFxuICB9O1xufVxuXG4vLyBHZXQgdGhlIGhlaWdodCBvZiBhIGNlbGwgZm9yIGEgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGEgY2FiaW5ldCBoZWlnaHRcbmV4cG9ydCBmdW5jdGlvbiBnZXRDZWxsSGVpZ2h0KHJvd0NvdW50OiBudW1iZXIsIGNhYmluZXRIZWlnaHQ6IG51bWJlcikge1xuICAvLyBHZXQgdGhlIGhlaWdodCBvZiBhIGNlbGxcbiAgY29uc3QgY2VsbEhlaWdodCA9IChjYWJpbmV0SGVpZ2h0IC0gKHJvd0NvdW50IC0gMSkgKiBQTEFURV9USElDS05FU1MpIC8gcm93Q291bnQ7XG4gIHJldHVybiBjZWxsSGVpZ2h0O1xufVxuXG4vLyBHZXQgdGhlIHdpZHRoIG9mIGEgY2VsbCBmb3IgYSBnaXZlbiBudW1iZXIgb2YgY29sdW1ucyBhbmQgYSB0b3RhbCB3aWR0aFxuZXhwb3J0IGZ1bmN0aW9uIGdldENlbGxXaWR0aChjb2x1bW5Db3VudDogbnVtYmVyLCB0b3RhbFdpZHRoOiBudW1iZXIpIHtcbiAgLy8gR2V0IHRoZSB3aWR0aCBvZiBhIGNlbGxcbiAgY29uc3QgY2VsbFdpZHRoID0gKHRvdGFsV2lkdGggLSAoY29sdW1uQ291bnQgKyAxKSAqIFBMQVRFX1RISUNLTkVTUykgLyBjb2x1bW5Db3VudDtcbiAgcmV0dXJuIGNlbGxXaWR0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbUhlaWdodChsZWdzOiBFQ2FiaW5ldExlZ3MpIHtcbiAgcmV0dXJuIGxlZ3MgPT09IEVDYWJpbmV0TGVncy5OT19MRUcgPyAwLjAyIDogTEVHX0hFSUdIVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcnRpdG9uUGxhdGVzKHsgY29sdW1ucywgdG90YWxIZWlnaHQsIHRvdGFsV2lkdGgsIHRvdGFsRGVwdGgsIGxlZ0hlaWdodCB9OiB7IGNvbHVtbnM6IElDb2x1bW5bXTsgdG90YWxIZWlnaHQ6IG51bWJlcjsgdG90YWxXaWR0aDogbnVtYmVyOyB0b3RhbERlcHRoOiBudW1iZXI7IGxlZ0hlaWdodDogbnVtYmVyIH0pIHtcbiAgY29uc3QgdmVydGljYWxzOiBJUGFydGl0aW9uW10gPSBbXTtcbiAgY29uc3QgaG9yaXpvbnRhbHM6IElQYXJ0aXRpb25bXSA9IFtdO1xuICBjb25zdCBhdmFpbGFibGVTcGFjZXM6IElQYXJ0aXRpb25bXSA9IFtdO1xuICBjb25zdCBiYWNrc2lkZXM6IElQYXJ0aXRpb25bXSA9IFtdO1xuXG4gIGNvbnN0IHNwYWNlSGVpZ2h0ID0gdG90YWxIZWlnaHQgLSAyICogUExBVEVfVEhJQ0tORVNTIC0gbGVnSGVpZ2h0O1xuXG4gIGNvbnN0IHBvc1kgPSAodG90YWxIZWlnaHQgKyBsZWdIZWlnaHQpIC8gMjtcblxuICBjb25zdCBzdGFydFBvc1ggPSAtKHRvdGFsV2lkdGggLSBQTEFURV9USElDS05FU1MpIC8gMjtcbiAgY29uc3QgYm90dG9tUG9zWSA9IGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUyAvIDI7XG5cbiAgdmVydGljYWxzLnB1c2goe1xuICAgIHJvdzogMCxcbiAgICBjb2w6IC0xLFxuICAgIHBvc2l0aW9uOiB7XG4gICAgICB4OiBzdGFydFBvc1gsXG4gICAgICB5OiBwb3NZLFxuICAgICAgejogMCxcbiAgICB9LFxuICAgIHNjYWxlOiB7XG4gICAgICB3aWR0aDogc3BhY2VIZWlnaHQsXG4gICAgICBkZXB0aDogdG90YWxEZXB0aCxcbiAgICB9LFxuICB9KTtcbiAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sdW1ucy5sZW5ndGg7IGNvbCsrKSB7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tjb2xdO1xuICAgIGNvbnN0IHJvd3MgPSBjb2x1bW4ucm93cztcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbCArIDE7IGkrKykge1xuICAgICAgc3VtICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IHBvc1ggPSBzdGFydFBvc1ggKyBzdW0gKyAoY29sICsgMSkgKiBQTEFURV9USElDS05FU1M7XG4gICAgY29uc3Qgc3BhY2VQb3NYID0gcG9zWCAtIFBMQVRFX1RISUNLTkVTUyAvIDIgLSBjb2x1bW4ud2lkdGggLyAyO1xuXG4gICAgdmVydGljYWxzLnB1c2goe1xuICAgICAgcm93OiAwLFxuICAgICAgY29sLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogcG9zWCxcbiAgICAgICAgeTogcG9zWSxcbiAgICAgICAgejogMCxcbiAgICAgIH0sXG4gICAgICBzY2FsZToge1xuICAgICAgICB3aWR0aDogc3BhY2VIZWlnaHQsXG4gICAgICAgIGRlcHRoOiB0b3RhbERlcHRoLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGF2YWlsYWJsZVNwYWNlcy5wdXNoKHtcbiAgICAgIHJvdzogMCxcbiAgICAgIGNvbCxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHNwYWNlUG9zWCxcbiAgICAgICAgeTogcG9zWSxcbiAgICAgICAgejogdG90YWxEZXB0aCAvIDIsXG4gICAgICB9LFxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCxcbiAgICAgICAgZGVwdGg6IHNwYWNlSGVpZ2h0LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByb3dzLmxlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgbGV0IHZlcnRpY2FsU3VtID0gMDtcbiAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcm93SW5kZXggKyAxOyBwKyspIHtcbiAgICAgICAgdmVydGljYWxTdW0gKz0gcm93c1tyb3dJbmRleF0uaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtaWRkbGVQb3NZID0gYm90dG9tUG9zWSArIHZlcnRpY2FsU3VtICsgKHJvd0luZGV4ICsgMSkgKiBQTEFURV9USElDS05FU1M7XG5cbiAgICAgIGNvbnN0IGJhY2tQb3NZID0gbWlkZGxlUG9zWSAtIFBMQVRFX1RISUNLTkVTUyAvIDIgLSByb3dzW3Jvd0luZGV4XS5oZWlnaHQgLyAyO1xuICAgICAgY29uc3QgYmFja1Bvc1ogPSAtKHRvdGFsRGVwdGggLSBQTEFURV9USElDS05FU1MpIC8gMjtcbiAgICAgIGlmIChyb3dJbmRleCA8IHJvd3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBob3Jpem9udGFscy5wdXNoKHtcbiAgICAgICAgICByb3c6IHJvd0luZGV4LFxuICAgICAgICAgIGNvbCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogc3BhY2VQb3NYLFxuICAgICAgICAgICAgeTogbWlkZGxlUG9zWSxcbiAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCxcbiAgICAgICAgICAgIGRlcHRoOiB0b3RhbERlcHRoIC0gRURHRV9HQVAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGJhY2tzaWRlcy5wdXNoKHtcbiAgICAgICAgcm93OiByb3dJbmRleCxcbiAgICAgICAgY29sLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHNwYWNlUG9zWCxcbiAgICAgICAgICB5OiBiYWNrUG9zWSxcbiAgICAgICAgICB6OiBiYWNrUG9zWixcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uLndpZHRoLFxuICAgICAgICAgIGRlcHRoOiByb3dzW3Jvd0luZGV4XS5oZWlnaHQsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZlcnRpY2FscyxcbiAgICBhdmFpbGFibGVTcGFjZXMsXG4gICAgaG9yaXpvbnRhbHMsXG4gICAgYmFja3NpZGVzLFxuICB9O1xufVxuXG4vLyBVcGRhdGUgdGhlIHR5cGUgZGVmaW5pdGlvbiB0byBpbmNsdWRlIGNvbHVtbkNvdW50XG50eXBlIFRHZXRDYWxjdWxhdGVkQ29sdW1uc1Byb3BzID0ge1xuICBjdXJyZW50OiBJQ29sdW1uW107XG4gIGNhYmluZXRTaXplOiBJQ2FiaW5ldFNpemU7XG4gIGNhYmluZXRTdHlsZTogRUNhYmluZXRTdHlsZTtcbiAgbGVnSGVpZ2h0OiBudW1iZXI7XG4gIGNvbHVtbkNvdW50PzogbnVtYmVyO1xufTtcblxuLy8gRml4IHRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbmV4cG9ydCBjb25zdCBnZXRDYWxjdWxhdGVkQ29sdW1ucyA9ICh7XG4gIGN1cnJlbnQsXG4gIGNhYmluZXRTaXplLFxuICBjYWJpbmV0U3R5bGUsXG4gIGxlZ0hlaWdodCxcbiAgY29sdW1uQ291bnQsXG59OiBUR2V0Q2FsY3VsYXRlZENvbHVtbnNQcm9wcyk6IElDb2x1bW5bXSA9PiB7XG4gIGNvbnN0IHsgdG90YWxXaWR0aCwgdG90YWxIZWlnaHQgfSA9IGNhYmluZXRTaXplO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGF2YWlsYWJsZSB3aWR0aCAodG90YWwgd2lkdGggbWludXMgc2lkZSBwbGF0ZXMpXG4gIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gdG90YWxXaWR0aCAtIDIgKiBQTEFURV9USElDS05FU1M7XG4gIFxuICAvLyBEZXRlcm1pbmUgaG93IG1hbnkgY29sdW1ucyBjYW4gZml0XG4gIGxldCBudW1Db2x1bW5zO1xuICBpZiAoY29sdW1uQ291bnQpIHtcbiAgICBudW1Db2x1bW5zID0gY29sdW1uQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FsY3VsYXRlIGJhc2VkIG9uIG1pbmltdW0gY29sdW1uIHdpZHRoXG4gICAgbnVtQ29sdW1ucyA9IE1hdGguZmxvb3IoYXZhaWxhYmxlV2lkdGggLyAoQ0VMTF9TSVpFLm1pbldpZHRoICsgUExBVEVfVEhJQ0tORVNTKSk7XG4gICAgLy8gRW5zdXJlIGF0IGxlYXN0IG9uZSBjb2x1bW5cbiAgICBudW1Db2x1bW5zID0gTWF0aC5tYXgoMSwgbnVtQ29sdW1ucyk7XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBjb2x1bW4gd2lkdGhcbiAgY29uc3QgY29sdW1uV2lkdGggPSAoYXZhaWxhYmxlV2lkdGggLSAobnVtQ29sdW1ucyAtIDEpICogUExBVEVfVEhJQ0tORVNTKSAvIG51bUNvbHVtbnM7XG4gIFxuICAvLyBDcmVhdGUgY29sdW1ucyBhcnJheVxuICBjb25zdCBjb2x1bW5zOiBJQ29sdW1uW10gPSBbXTtcbiAgXG4gIC8vIEdlbmVyYXRlIGVhY2ggY29sdW1uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29sdW1uczsgaSsrKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uXG4gICAgY29uc3QgcG9zWCA9IC10b3RhbFdpZHRoIC8gMiArIFBMQVRFX1RISUNLTkVTUyArIGkgKiAoY29sdW1uV2lkdGggKyBQTEFURV9USElDS05FU1MpICsgY29sdW1uV2lkdGggLyAyO1xuICAgIFxuICAgIC8vIENyZWF0ZSBjb2x1bW4gd2l0aCBhcHByb3ByaWF0ZSBsYXlvdXRcbiAgICBjb25zdCBjb2x1bW4gPSBjcmVhdGVDb2x1bW5XaXRoTGF5b3V0KGNvbHVtbldpZHRoLCBwb3NYLCB0b3RhbEhlaWdodCwgbGVnSGVpZ2h0LCBjYWJpbmV0U3R5bGUpO1xuICAgIFxuICAgIGNvbHVtbnMucHVzaChjb2x1bW4pO1xuICB9XG4gIFxuICByZXR1cm4gY29sdW1ucztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW1haW5pbmdDb2x1bW5zKHJlbWFpbmluZ1dpZHRoOiBudW1iZXIpIHtcbiAgY29uc3QgYiA9IHJlbWFpbmluZ1dpZHRoICUgMiA9PT0gMCA/IHJlbWFpbmluZ1dpZHRoIC8gMiA6IChyZW1haW5pbmdXaWR0aCArIDEpIC8gMjtcbiAgY29uc3QgYyA9IHJlbWFpbmluZ1dpZHRoIC0gYjtcblxuICByZXR1cm4gW2IsIGNdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5kaXZpZHVhbENvbHVtbih7XG4gIHRhcmdldEluZGV4LFxuICBjb2x1bW5zLFxuICB0b3RhbFdpZHRoLFxuICB0b3RhbERlcHRoLFxuICBsZWdIZWlnaHQsXG59OiB7XG4gIHRhcmdldEluZGV4OiBudW1iZXI7XG4gIGNvbHVtbnM6IElDb2x1bW5bXTtcbiAgdG90YWxXaWR0aDogbnVtYmVyO1xuICB0b3RhbERlcHRoOiBudW1iZXI7XG4gIGxlZ0hlaWdodDogbnVtYmVyO1xufSkge1xuICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3RhcmdldEluZGV4XTtcblxuICBjb25zdCBzdGFydFBvc1ggPSAtKHRvdGFsV2lkdGggLSBQTEFURV9USElDS05FU1MpIC8gMjtcbiAgY29uc3QgYm90dG9tUG9zWSA9IGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUyAvIDI7XG4gIGNvbnN0IHJvd3NQb3MgPSBbXTtcbiAgY29uc3QgZGVsdGEgPSAwLjAyO1xuICBjb25zdCByb3dzID0gY29sdW1uLnJvd3M7XG5cbiAgbGV0IHN1bSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0SW5kZXggKyAxOyBpKyspIHtcbiAgICBzdW0gKz0gY29sdW1uc1tpXS53aWR0aDtcbiAgfVxuICBjb25zdCBwb3NYID0gc3RhcnRQb3NYICsgc3VtICsgKHRhcmdldEluZGV4ICsgMSkgKiBQTEFURV9USElDS05FU1M7XG4gIGNvbnN0IHNwYWNlUG9zWCA9IHBvc1ggLSBQTEFURV9USElDS05FU1MgLyAyIC0gY29sdW1uLndpZHRoIC8gMjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgdmVydGljYWxTdW0gPSAwO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgaSArIDE7IHArKykge1xuICAgICAgdmVydGljYWxTdW0gKz0gcm93c1twXS5oZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG1pZGRsZVBvc1kgPSBib3R0b21Qb3NZICsgdmVydGljYWxTdW0gKyAoaSArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuICAgIGNvbnN0IGJhY2tQb3NZID0gbWlkZGxlUG9zWSAtIFBMQVRFX1RISUNLTkVTUyAvIDIgLSByb3dzW2ldLmhlaWdodCAvIDI7XG4gICAgcm93c1Bvcy5wdXNoKHtcbiAgICAgIHg6IHNwYWNlUG9zWCAtIGNvbHVtbi53aWR0aCAvIDIsXG4gICAgICB5OiBiYWNrUG9zWSxcbiAgICAgIHo6IHRvdGFsRGVwdGggLyAyICsgZGVsdGEsXG4gICAgICBoZWlnaHQ6IHJvd3NbaV0uaGVpZ2h0LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoc3BhY2VQb3NYLCBsZWdIZWlnaHQgKyBQTEFURV9USElDS05FU1MgKyBkZWx0YSwgdG90YWxEZXB0aCAvIDIgKyBkZWx0YSksXG4gICAgcm93czogcm93c1BvcyxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldExheW91dEltYWdlcyA9ICh7IHRvdGFsSGVpZ2h0IH06IHsgdG90YWxIZWlnaHQ6IG51bWJlciB9KSA9PiB7XG4gIGxldCBpbWdzQXJyYXkgPSBbXTtcbiAgaWYgKHRvdGFsSGVpZ2h0IDwgMC41Mykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQ1M0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDAuNjMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0NjNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAwLjczKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDczSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMC45Mykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQ5M0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDEuMDMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0MTAzSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMS4yMykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQxMjNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAxLjMzKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDEzM0ljb25zXTtcbiAgfSBlbHNlIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0MTQzSWNvbnNdO1xuICB9XG5cbiAgcmV0dXJuIGltZ3NBcnJheTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJZCA9IChpdGVtOiBzdHJpbmcpID0+IGAke2l0ZW19LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzMikuc2xpY2UoLTQpfWA7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb2x1bW5XaXRoTGF5b3V0ID0gKGNvbHVtbldpZHRoOiBudW1iZXIsIHBvc1g6IG51bWJlciwgdG90YWxIZWlnaHQ6IG51bWJlciwgbGVnSGVpZ2h0OiBudW1iZXIsIGNhYmluZXRTdHlsZTogRUNhYmluZXRTdHlsZSk6IElDb2x1bW4gPT4ge1xuICAvLyBDYWxjdWxhdGUgdGhlIGNhYmluZXQgaGVpZ2h0IChleGNsdWRpbmcgbGVncyBhbmQgcGxhdGUgdGhpY2tuZXNzKVxuICBjb25zdCBjYWJpbmV0SGVpZ2h0ID0gdG90YWxIZWlnaHQgLSBsZWdIZWlnaHQgLSAyICogUExBVEVfVEhJQ0tORVNTO1xuICBcbiAgLy8gR2V0IHRoZSBiYXNpYyB2ZXJ0aWNhbCBsYXlvdXQgZm9yIHRoZSBjb2x1bW5cbiAgY29uc3Qgcm93cyA9IGdldENvbHVtblZlcnRpY2FsTGF5b3V0KHsgY2FiaW5ldEhlaWdodCB9KTtcbiAgXG4gIC8vIEdldCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gWSBjb29yZGluYXRlXG4gIGNvbnN0IHN0YXJ0UG9zWSA9IGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUztcbiAgXG4gIC8vIERlZmF1bHQgdG8gYW4gZW1wdHkgbGF5b3V0ICh3aWxsIGJlIHBvcHVsYXRlZCBiYXNlZCBvbiBzdHlsZSlcbiAgbGV0IGxheW91dEluZGV4ID0gMDtcbiAgbGV0IGRvb3JzOiBhbnlbXSA9IFtdO1xuICBsZXQgZHJhd2VyczogYW55W10gPSBbXTtcbiAgXG4gIC8vIEJhc2VkIG9uIGNhYmluZXQgc3R5bGUsIGNob29zZSBhbiBhcHByb3ByaWF0ZSBsYXlvdXRcbiAgc3dpdGNoIChjYWJpbmV0U3R5bGUpIHtcbiAgICBjYXNlIEVDYWJpbmV0U3R5bGUuTU9ERVJOOlxuICAgICAgLy8gRm9yIG1vZGVybiBzdHlsZSwgdXNlIGFsbCBkcmF3ZXJzXG4gICAgICBsYXlvdXRJbmRleCA9IDE7XG4gICAgICAvLyBDcmVhdGUgYSBkcmF3ZXIgZm9yIGVhY2ggcm93XG4gICAgICBkcmF3ZXJzID0gcm93cy5tYXAoKHJvdywgaW5kZXgpID0+ICh7XG4gICAgICAgIGluZGV4LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogcm93LmhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zOiB7XG4gICAgICAgICAgeDogcG9zWCxcbiAgICAgICAgICB5OiBzdGFydFBvc1kgKyAoaW5kZXggKyAwLjUpICogcm93LmhlaWdodCArIGluZGV4ICogUExBVEVfVEhJQ0tORVNTLFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgICBcbiAgICBjYXNlIEVDYWJpbmV0U3R5bGUuQ0xBU1NJQzpcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIGNsYXNzaWMgc3R5bGUsIHVzZSBkb29ycyBmb3IgYWxsIHJvd3NcbiAgICAgIGxheW91dEluZGV4ID0gMDtcbiAgICAgIC8vIENyZWF0ZSBhIGRvb3IgZm9yIHRoZSBmdWxsIGhlaWdodFxuICAgICAgZG9vcnMgPSBbe1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNhYmluZXRIZWlnaHQsXG4gICAgICAgIH0sXG4gICAgICAgIHBvczoge1xuICAgICAgICAgIHg6IHBvc1gsXG4gICAgICAgICAgeTogc3RhcnRQb3NZICsgY2FiaW5ldEhlaWdodCAvIDIsXG4gICAgICAgIH0sXG4gICAgICAgIG9wZW5pbmc6IDEsIC8vIERlZmF1bHQgb3BlbmluZyBkaXJlY3Rpb25cbiAgICAgIH1dO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHRoZSBjb2x1bW4gb2JqZWN0XG4gIHJldHVybiB7XG4gICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcbiAgICBpbmRleDogMCxcbiAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgcG9zWDogcG9zWCxcbiAgICByb3dzOiByb3dzLFxuICAgIGRvb3JzOiBkb29ycyxcbiAgICBkcmF3ZXJzOiBkcmF3ZXJzLFxuICAgIGRpdmlkZXJzOiBbXSxcbiAgICBsYXlvdXRJbmRleDogbGF5b3V0SW5kZXgsXG4gICAgaXNEaXZpZGU6IGZhbHNlLFxuICAgIGxhc3RSb3c6IGRyYXdlcnMubGVuZ3RoID4gMCA/ICdkcmF3ZXInIDogJ2Rvb3InLFxuICB9O1xufTtcblxuLy8gVXBkYXRlIHRoZSBjYWJpbmV0IHNpemUgY29uc3RyYWludHNcbmV4cG9ydCBjb25zdCBDQUJJTkVUX1NJWkVfQ09OU1RSQUlOVFMgPSB7XG4gIG1pbldpZHRoOiAwLjQsIC8vIDQwY20gaW4gbWV0ZXJzXG4gIG1heFdpZHRoOiAyLjUsIC8vIDI1MGNtIGluIG1ldGVycyAoY2hhbmdlZCBmcm9tIDQuNW0vNDUwY20pXG4gIG1pbkhlaWdodDogMC40LCAvLyA0MGNtIGluIG1ldGVyc1xuICBtYXhIZWlnaHQ6IDIuNCwgLy8gMjQwY20gaW4gbWV0ZXJzXG4gIG1pbkRlcHRoOiAwLjMsIC8vIDMwY20gaW4gbWV0ZXJzXG4gIG1heERlcHRoOiAwLjgsIC8vIDgwY20gaW4gbWV0ZXJzXG59O1xuXG5leHBvcnQgY29uc3QgYXBwbHlSYW5kb21MYXlvdXRzVG9Db2x1bW5zID0gKGNvbHVtbnM6IElDb2x1bW5bXSwgdG90YWxIZWlnaHQ6IG51bWJlciwgbGVnSGVpZ2h0OiBudW1iZXIpOiBJQ29sdW1uW10gPT4ge1xuICBjb25zdCBzdGFydFBvc1kgPSBsZWdIZWlnaHQgKyBQTEFURV9USElDS05FU1M7XG4gIFxuICByZXR1cm4gY29sdW1ucy5tYXAoY29sdW1uID0+IHtcbiAgICAvLyBHZXQgYWxsIGF2YWlsYWJsZSBsYXlvdXQgb3B0aW9ucyBmb3IgdGhpcyBjb2x1bW5cbiAgICBjb25zdCBsYXlvdXRPcHRpb25zID0gZ2V0TGF5b3V0T3B0aW9uc09mQ29sdW1uKHsgXG4gICAgICB0b3RhbEhlaWdodCwgXG4gICAgICBsZWdIZWlnaHQsIFxuICAgICAgY29sdW1uV2lkdGg6IGNvbHVtbi53aWR0aCwgXG4gICAgICBwb3NYOiBjb2x1bW4ucG9zWCwgXG4gICAgICBzdGFydFBvc1ksXG4gICAgICBkb29yRGlyOiAxIC8vIERlZmF1bHQgZG9vciBvcGVuaW5nIGRpcmVjdGlvblxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNlbGVjdCBhIHJhbmRvbSBsYXlvdXQgb3B0aW9uXG4gICAgY29uc3QgcmFuZG9tTGF5b3V0SW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsYXlvdXRPcHRpb25zLmxlbmd0aCk7XG4gICAgY29uc3QgcmFuZG9tTGF5b3V0ID0gbGF5b3V0T3B0aW9uc1tyYW5kb21MYXlvdXRJbmRleF07XG4gICAgXG4gICAgLy8gQXBwbHkgdGhlIHJhbmRvbSBsYXlvdXQgdG8gdGhlIGNvbHVtblxuICAgIHJldHVybiB7XG4gICAgICAuLi5jb2x1bW4sXG4gICAgICBsYXlvdXRJbmRleDogcmFuZG9tTGF5b3V0SW5kZXgsXG4gICAgICByb3dzOiByYW5kb21MYXlvdXQucm93cyxcbiAgICAgIGRvb3JzOiByYW5kb21MYXlvdXQuZG9vcnMsXG4gICAgICBkcmF3ZXJzOiByYW5kb21MYXlvdXQuZHJhd2VycyxcbiAgICAgIGxhc3RSb3c6IHJhbmRvbUxheW91dC5sYXN0Um93XG4gICAgfTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbIlRIUkVFIiwiZ2V0TGF5b3V0T3B0aW9uc09mQ29sdW1uIiwiUExBVEVfVEhJQ0tORVNTIiwiQ0VMTF9TSVpFIiwibWF4V2lkdGgiLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsIm1pbkhlaWdodCIsIkxFR19IRUlHSFQiLCJMRUdfV0lEVEgiLCJMRUdfREVQVEgiLCJFREdFX0dBUCIsIndhbGxDb2xvciIsImZsb29yQ29sb3IiLCJhbWJpZW50TGlnaHRDb2xvciIsImRpcmVjdGlvbmFsTGlnaHRDb2xvciIsInRleHR1cmVzUm9vdFBhdGgiLCJlbnZpcm9ubWVudFBhdGgiLCJwbHl3b29kUm9vdFBhdGgiLCJwbHl3b29kQW9NYXBQYXRoIiwicGx5d29vZE5vcm1hbE1hcFBhdGgiLCJwbHl3b29kUm91Z2huZXNzTWFwUGF0aCIsInBseXdvb2RUZXh0dXJlcyIsImFvTWFwIiwibm9ybWFsTWFwIiwicm91Z2huZXNzTWFwIiwid29vZFJvb3RQYXRoIiwidmVuZWVyQW9NYXBQYXRoIiwidmVuZWVyTm9ybWFsTWFwUGF0aCIsInZlbmVlclJvdWdobmVzc01hcFBhdGgiLCJ2ZW5lZXJUZXh0dXJlcyIsIkVWZW5lZXJUZXh0dXJlcyIsIkVQbHl3b29kVGV4dHVyZXMiLCJob3Jpem9udGFsT2NjbHVzaW9uVGV4dHVyZVBhdGgiLCJ2ZXJ0aWNhbE9jY2x1c2lvblRleHR1cmVQYXRoIiwiYmFja09jY2x1c2lvblRleHR1cmVQYXRoIiwiRU9jY2x1c2lvbkltYWdlcyIsImxheW91dEljb25Sb290UGF0aCIsImljb25pZnlJY29ucyIsImxheW91dEljb25zIiwidW5kb0ljb24iLCJkaW1lbnNpb25zSWNvbiIsImRvb3JzSWNvbiIsImFsaWduQ29sdW1uc0ljb24iLCJzaG93RGVjb3JhdGlvbnNJY29uIiwiYXNzZW1ibHlJY29uIiwibWVudUljb25zIiwiYXJyb3dVcCIsImFycm93RG93biIsImluZm9RdWVzdGlvbiIsInNjZW5lSWNvbnMiLCJlZGl0TGF5b3V0IiwibWVudUljb25QYXRocyIsImxlZ3MiLCJub19sZWciLCJmbG9hdGluZyIsImhhbmRsZXMiLCJoYW5kbGVfYSIsImhhbmRsZV9iIiwicHVzaCIsInN0eWxlcyIsImZyYW1lIiwiZ3JhZGllbnQiLCJncmlkIiwibW9zYWljIiwicGl4ZWwiLCJzbGFudCIsImdlbmVyYXRlTGF5b3V0SWNvbnMiLCJsYXlvdXRIZWlnaHQiLCJpY29uQ291bnQiLCJsYXlvdXRSb290UGF0aCIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwibGF5b3V0NTNJY29ucyIsImxheW91dDYzSWNvbnMiLCJsYXlvdXQ3M0ljb25zIiwibGF5b3V0OTNJY29ucyIsImxheW91dDEwM0ljb25zIiwibGF5b3V0MTIzSWNvbnMiLCJsYXlvdXQxMzNJY29ucyIsImxheW91dDE0M0ljb25zIiwibW9kZWxzUm9vdFBhdGgiLCJzaGFkb3dNYW5Nb2RlbFBhdGgiLCJoYW5kbGVBTW9kZWxQYXRoIiwiaGFuZGxlQk1vZGVsUGF0aCIsImxlZ3NNb2RlbFBhdGgiLCJub0xlZ3NNb2RlbFBhdGgiLCJ0dk1vZGVsUGF0aCIsIkVDYWJpbmV0U3R5bGUiLCJFQ2FiaW5ldExlZ3MiLCJFQ2FiaW5ldEhhbmRsZXMiLCJFQ2FiaW5ldEZpbmlzaGVzIiwiZ2V0V2lkdGhBcnJheSIsInN0eWxlIiwidG90YWxXaWR0aCIsIndpZHRoQXJyYXkiLCJ1bml0IiwiZ2V0UmVtYWluaW5nQ29sdW1ucyIsImdldENvbHVtblZlcnRpY2FsTGF5b3V0IiwiY2FiaW5ldEhlaWdodCIsImN1cnJlbnRsYXlvdXQiLCJudW1iZXJPZlJvd3MiLCJnZXRSb3dDb3VudCIsImluZGV4IiwiaGVpZ2h0IiwiZ2V0Q2VsbEhlaWdodCIsImdldERpc3RhbmNlIiwicDEiLCJwMiIsIk1hdGgiLCJzcXJ0IiwieCIsInoiLCJmbG9vciIsImdldENvbHVtbkNvdW50IiwibnVtYmVyT2ZDb2x1bW5zIiwic3VtIiwid2lkdGhPZkNlbGwiLCJyb3VuZCIsInJvd0NvdW50IiwiY2VsbEhlaWdodCIsImdldENlbGxXaWR0aCIsImNvbHVtbkNvdW50IiwiY2VsbFdpZHRoIiwiZ2V0Qm90dG9tSGVpZ2h0IiwiZ2V0UGFydGl0b25QbGF0ZXMiLCJjb2x1bW5zIiwidG90YWxIZWlnaHQiLCJ0b3RhbERlcHRoIiwibGVnSGVpZ2h0IiwidmVydGljYWxzIiwiaG9yaXpvbnRhbHMiLCJhdmFpbGFibGVTcGFjZXMiLCJiYWNrc2lkZXMiLCJzcGFjZUhlaWdodCIsInBvc1kiLCJzdGFydFBvc1giLCJib3R0b21Qb3NZIiwicm93IiwiY29sIiwicG9zaXRpb24iLCJ5Iiwic2NhbGUiLCJ3aWR0aCIsImRlcHRoIiwiY29sdW1uIiwicm93cyIsInBvc1giLCJzcGFjZVBvc1giLCJyb3dJbmRleCIsInZlcnRpY2FsU3VtIiwicCIsIm1pZGRsZVBvc1kiLCJiYWNrUG9zWSIsImJhY2tQb3NaIiwiZ2V0Q2FsY3VsYXRlZENvbHVtbnMiLCJjdXJyZW50IiwiY2FiaW5ldFNpemUiLCJjYWJpbmV0U3R5bGUiLCJhdmFpbGFibGVXaWR0aCIsIm51bUNvbHVtbnMiLCJtYXgiLCJjb2x1bW5XaWR0aCIsImNyZWF0ZUNvbHVtbldpdGhMYXlvdXQiLCJyZW1haW5pbmdXaWR0aCIsImIiLCJjIiwiZ2V0SW5kaXZpZHVhbENvbHVtbiIsInRhcmdldEluZGV4Iiwicm93c1BvcyIsImRlbHRhIiwiVmVjdG9yMyIsImdldExheW91dEltYWdlcyIsImltZ3NBcnJheSIsImdldElkIiwiaXRlbSIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJzdGFydFBvc1kiLCJsYXlvdXRJbmRleCIsImRvb3JzIiwiZHJhd2VycyIsIm1hcCIsInNpemUiLCJwb3MiLCJvcGVuaW5nIiwiaWQiLCJzdWJzdHIiLCJkaXZpZGVycyIsImlzRGl2aWRlIiwibGFzdFJvdyIsIkNBQklORVRfU0laRV9DT05TVFJBSU5UUyIsIm1pbkRlcHRoIiwibWF4RGVwdGgiLCJhcHBseVJhbmRvbUxheW91dHNUb0NvbHVtbnMiLCJsYXlvdXRPcHRpb25zIiwiZG9vckRpciIsInJhbmRvbUxheW91dEluZGV4IiwicmFuZG9tTGF5b3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/utilities.ts\n"));

/***/ })

});