"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/utilities.ts":
/*!********************************!*\
  !*** ./src/utils/utilities.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CABINET_SIZE_CONSTRAINTS: function() { return /* binding */ CABINET_SIZE_CONSTRAINTS; },\n/* harmony export */   CELL_SIZE: function() { return /* binding */ CELL_SIZE; },\n/* harmony export */   ECabinetFinishes: function() { return /* binding */ ECabinetFinishes; },\n/* harmony export */   ECabinetHandles: function() { return /* binding */ ECabinetHandles; },\n/* harmony export */   ECabinetLegs: function() { return /* binding */ ECabinetLegs; },\n/* harmony export */   ECabinetStyle: function() { return /* binding */ ECabinetStyle; },\n/* harmony export */   EDGE_GAP: function() { return /* binding */ EDGE_GAP; },\n/* harmony export */   EOcclusionImages: function() { return /* binding */ EOcclusionImages; },\n/* harmony export */   EPlywoodTextures: function() { return /* binding */ EPlywoodTextures; },\n/* harmony export */   EVeneerTextures: function() { return /* binding */ EVeneerTextures; },\n/* harmony export */   LEG_DEPTH: function() { return /* binding */ LEG_DEPTH; },\n/* harmony export */   LEG_HEIGHT: function() { return /* binding */ LEG_HEIGHT; },\n/* harmony export */   LEG_WIDTH: function() { return /* binding */ LEG_WIDTH; },\n/* harmony export */   PLATE_THICKNESS: function() { return /* binding */ PLATE_THICKNESS; },\n/* harmony export */   ambientLightColor: function() { return /* binding */ ambientLightColor; },\n/* harmony export */   applyRandomLayoutsToColumns: function() { return /* binding */ applyRandomLayoutsToColumns; },\n/* harmony export */   backOcclusionTexturePath: function() { return /* binding */ backOcclusionTexturePath; },\n/* harmony export */   createColumnWithLayout: function() { return /* binding */ createColumnWithLayout; },\n/* harmony export */   directionalLightColor: function() { return /* binding */ directionalLightColor; },\n/* harmony export */   environmentPath: function() { return /* binding */ environmentPath; },\n/* harmony export */   floorColor: function() { return /* binding */ floorColor; },\n/* harmony export */   getBottomHeight: function() { return /* binding */ getBottomHeight; },\n/* harmony export */   getCalculatedColumns: function() { return /* binding */ getCalculatedColumns; },\n/* harmony export */   getCellHeight: function() { return /* binding */ getCellHeight; },\n/* harmony export */   getCellWidth: function() { return /* binding */ getCellWidth; },\n/* harmony export */   getColumnCount: function() { return /* binding */ getColumnCount; },\n/* harmony export */   getColumnVerticalLayout: function() { return /* binding */ getColumnVerticalLayout; },\n/* harmony export */   getDistance: function() { return /* binding */ getDistance; },\n/* harmony export */   getId: function() { return /* binding */ getId; },\n/* harmony export */   getIndividualColumn: function() { return /* binding */ getIndividualColumn; },\n/* harmony export */   getLayoutImages: function() { return /* binding */ getLayoutImages; },\n/* harmony export */   getPartitonPlates: function() { return /* binding */ getPartitonPlates; },\n/* harmony export */   getRemainingColumns: function() { return /* binding */ getRemainingColumns; },\n/* harmony export */   getRowCount: function() { return /* binding */ getRowCount; },\n/* harmony export */   getWidthArray: function() { return /* binding */ getWidthArray; },\n/* harmony export */   handleAModelPath: function() { return /* binding */ handleAModelPath; },\n/* harmony export */   handleBModelPath: function() { return /* binding */ handleBModelPath; },\n/* harmony export */   horizontalOcclusionTexturePath: function() { return /* binding */ horizontalOcclusionTexturePath; },\n/* harmony export */   iconifyIcons: function() { return /* binding */ iconifyIcons; },\n/* harmony export */   legsModelPath: function() { return /* binding */ legsModelPath; },\n/* harmony export */   menuIconPaths: function() { return /* binding */ menuIconPaths; },\n/* harmony export */   noLegsModelPath: function() { return /* binding */ noLegsModelPath; },\n/* harmony export */   plywoodTextures: function() { return /* binding */ plywoodTextures; },\n/* harmony export */   shadowManModelPath: function() { return /* binding */ shadowManModelPath; },\n/* harmony export */   tvModelPath: function() { return /* binding */ tvModelPath; },\n/* harmony export */   veneerTextures: function() { return /* binding */ veneerTextures; },\n/* harmony export */   verticalOcclusionTexturePath: function() { return /* binding */ verticalOcclusionTexturePath; },\n/* harmony export */   wallColor: function() { return /* binding */ wallColor; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./columnLayoutOptions */ \"(app-pages-browser)/./src/utils/columnLayoutOptions.ts\");\n\n\n//--- CONSTANTS\n// Dimensions\nconst PLATE_THICKNESS = 0.02;\nconst CELL_SIZE = {\n    maxWidth: 0.60,\n    minWidth: 0.25,\n    maxHeight: 0.35,\n    minHeight: 0.15\n};\nconst LEG_HEIGHT = 0.18;\nconst LEG_WIDTH = 0.05;\nconst LEG_DEPTH = 0.05;\nconst EDGE_GAP = 0.006;\n// Colors\nconst wallColor = \"#e7e7e7\";\nconst floorColor = \"#b7b7b7\";\nconst ambientLightColor = \"#f0f0f0\";\nconst directionalLightColor = \"#f0f0f0\";\n// Texture paths\nconst texturesRootPath = \"/assets/textures/\";\nconst environmentPath = texturesRootPath + \"environment.hdr\";\nconst plywoodRootPath = texturesRootPath + \"plywood_1k/textures/\";\nconst plywoodAoMapPath = plywoodRootPath + \"plywood_ao_1k.jpg\";\nconst plywoodNormalMapPath = plywoodRootPath + \"plywood_nor_gl_1k.jpg\";\nconst plywoodRoughnessMapPath = plywoodRootPath + \"plywood_rough_1k.jpg\";\nconst plywoodTextures = {\n    aoMap: plywoodAoMapPath,\n    normalMap: plywoodNormalMapPath,\n    roughnessMap: plywoodRoughnessMapPath\n};\n// Base Textures Veener\nconst woodRootPath = texturesRootPath + \"wood_27/\";\nconst veneerAoMapPath = woodRootPath + \"ambient-occlusion.jpg\";\nconst veneerNormalMapPath = woodRootPath + \"normal.jpg\";\nconst veneerRoughnessMapPath = woodRootPath + \"roughness.jpg\";\nconst veneerTextures = {\n    aoMap: veneerAoMapPath,\n    normalMap: veneerNormalMapPath,\n    roughnessMap: veneerRoughnessMapPath\n};\nvar EVeneerTextures;\n(function(EVeneerTextures) {\n    EVeneerTextures[EVeneerTextures[\"BEIGE_GREY_LORENZO_OAK\"] = texturesRootPath + \"veneer-oak-wood/beige_grey_lorenzo_oak.jpg\"] = \"BEIGE_GREY_LORENZO_OAK\";\n    // BEIGE_TEXTILE = texturesRootPath + 'veneer-oak-wood/beige_textile.jpg',\n    EVeneerTextures[EVeneerTextures[\"BROWN_ABANO_ASH\"] = texturesRootPath + \"veneer-oak-wood/brown_abano_ash.jpg\"] = \"BROWN_ABANO_ASH\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_HALIFAX_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_halifax_oak.jpg\"] = \"BROWN_HALIFAX_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_TONNSBERG_OAK\"] = texturesRootPath + \"veneer-oak-wood/brown_tonnsberg_oak.jpg\"] = \"BROWN_TONNSBERG_OAK\";\n    EVeneerTextures[EVeneerTextures[\"BROWN_WARMIA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/brown_warmia_wallnut.jpg\"] = \"BROWN_WARMIA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_BARONIA_OAK\"] = texturesRootPath + \"veneer-oak-wood/light_baronia_oak.jpg\"] = \"LIGHT_BARONIA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"LIGHT_NATURAL_DAVENPORT_OAK\"] = texturesRootPath + \"veneer-oak-wood/Light_Natural_Davenport_oak.jpg\"] = \"LIGHT_NATURAL_DAVENPORT_OAK\";\n    EVeneerTextures[EVeneerTextures[\"NATURAL_CASELLA_OAK\"] = texturesRootPath + \"veneer-oak-wood/natural_casella_oak.jpg\"] = \"NATURAL_CASELLA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"PARONA_WALLNUT\"] = texturesRootPath + \"veneer-oak-wood/parona_wallnut.jpg\"] = \"PARONA_WALLNUT\";\n    EVeneerTextures[EVeneerTextures[\"SEVILLA_ASH\"] = texturesRootPath + \"veneer-oak-wood/sevilla_ash.jpg\"] = \"SEVILLA_ASH\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak.jpg\"] = \"VICENZA_OAK\";\n    EVeneerTextures[EVeneerTextures[\"VICENZA_OAK_2\"] = texturesRootPath + \"veneer-oak-wood/vicenza_oak2.jpg\"] = \"VICENZA_OAK_2\";\n})(EVeneerTextures || (EVeneerTextures = {}));\nvar EPlywoodTextures;\n(function(EPlywoodTextures) {\n    EPlywoodTextures[EPlywoodTextures[\"BRONZE_BRUSHED_METAL\"] = texturesRootPath + \"plywood-colors/bronze_brushed_metal.jpg\"] = \"BRONZE_BRUSHED_METAL\";\n    EPlywoodTextures[EPlywoodTextures[\"ALMOND_BEIGE\"] = texturesRootPath + \"plywood-colors/almond_beige.jpg\"] = \"ALMOND_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CARAT_BEIGE\"] = texturesRootPath + \"plywood-colors/carat_beige.jpg\"] = \"CARAT_BEIGE\";\n    EPlywoodTextures[EPlywoodTextures[\"CASHMERE_GREY\"] = texturesRootPath + \"plywood-colors/cashmere_grey.jpg\"] = \"CASHMERE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"CORA_BRONZE\"] = texturesRootPath + \"plywood-colors/cobra_bronze.jpg\"] = \"CORA_BRONZE\";\n    EPlywoodTextures[EPlywoodTextures[\"CUBANITE_GREY\"] = texturesRootPath + \"plywood-colors/cubanite_grey.jpg\"] = \"CUBANITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"FIR_GREEN\"] = texturesRootPath + \"plywood-colors/fir_green.jpg\"] = \"FIR_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"FJORD_GREEN\"] = texturesRootPath + \"plywood-colors/fjord_green.jpg\"] = \"FJORD_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"GRAPHITE_GREY\"] = texturesRootPath + \"plywood-colors/graphite_grey.jpg\"] = \"GRAPHITE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"INDIGO_BLUE\"] = texturesRootPath + \"plywood-colors/indigo_blue.jpg\"] = \"INDIGO_BLUE\";\n    EPlywoodTextures[EPlywoodTextures[\"REED_GREEN\"] = texturesRootPath + \"plywood-colors/reed_green.jpg\"] = \"REED_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"SAGE_GREEN\"] = texturesRootPath + \"plywood-colors/sage_green.jpg\"] = \"SAGE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"STONE_GREEN\"] = texturesRootPath + \"plywood-colors/stone_green.jpg\"] = \"STONE_GREEN\";\n    EPlywoodTextures[EPlywoodTextures[\"TAUPE_GREY\"] = texturesRootPath + \"plywood-colors/taupe_grey.jpg\"] = \"TAUPE_GREY\";\n    EPlywoodTextures[EPlywoodTextures[\"TRUFFLE_BROWN\"] = texturesRootPath + \"plywood-colors/truffle_brown.jpg\"] = \"TRUFFLE_BROWN\";\n    EPlywoodTextures[EPlywoodTextures[\"U999_PM_BLACK\"] = texturesRootPath + \"plywood-colors/U999_PM_Black.jpg\"] = \"U999_PM_BLACK\";\n})(EPlywoodTextures || (EPlywoodTextures = {}));\n// Occlusion Textures\nconst horizontalOcclusionTexturePath = texturesRootPath + \"horizontal-panel.jpg\";\nconst verticalOcclusionTexturePath = texturesRootPath + \"vertical-panel.jpg\";\nconst backOcclusionTexturePath = texturesRootPath + \"back-panel.jpg\";\nvar EOcclusionImages;\n(function(EOcclusionImages) {\n    EOcclusionImages[EOcclusionImages[\"HORIZONTAL\"] = horizontalOcclusionTexturePath] = \"HORIZONTAL\";\n    EOcclusionImages[EOcclusionImages[\"BACK\"] = verticalOcclusionTexturePath] = \"BACK\";\n    EOcclusionImages[EOcclusionImages[\"VERTICAL\"] = backOcclusionTexturePath] = \"VERTICAL\";\n})(EOcclusionImages || (EOcclusionImages = {}));\n// Layout Icons\nconst layoutIconRootPath = \"/assets/icons/on-model-editor/\";\nconst iconifyIcons = {\n    layoutIcons: {\n        undoIcon: \"solar:undo-left-round-outline\",\n        dimensionsIcon: \"solar:ruler-linear\",\n        doorsIcon: \"fluent:door-20-regular\",\n        alignColumnsIcon: \"flowbite:grid-plus-outline\",\n        showDecorationsIcon: \"hugeicons:paint-brush-02\",\n        assemblyIcon: \"carbon:3d-cursor\"\n    },\n    menuIcons: {\n        arrowUp: \"iwwa:arrow-up\",\n        arrowDown: \"iwwa:arrow-down\",\n        infoQuestion: \"ph:question-bold\"\n    },\n    sceneIcons: {\n        editLayout: \"ic-outline-create\"\n    }\n};\nconst menuIconPaths = {\n    legs: {\n        no_leg: \"/assets/icons/menu-icons/legs/no_leg.svg\",\n        legs: \"/assets/icons/menu-icons/legs/legs.svg\",\n        floating: \"/assets/icons/menu-icons/legs/floating.svg\"\n    },\n    handles: {\n        handle_a: \"/assets/icons/menu-icons/handles/handle_A.svg\",\n        handle_b: \"/assets/icons/menu-icons/handles/handle_B.svg\",\n        push: \"/assets/icons/menu-icons/handles/push.svg\"\n    },\n    styles: {\n        frame: \"/assets/icons/menu-icons/styles/frame.svg\",\n        gradient: \"/assets/icons/menu-icons/styles/gradient.svg\",\n        grid: \"/assets/icons/menu-icons/styles/grid.svg\",\n        mosaic: \"/assets/icons/menu-icons/styles/mosaic.svg\",\n        pixel: \"/assets/icons/menu-icons/styles/pixel.svg\",\n        slant: \"/assets/icons/menu-icons/styles/slant.svg\"\n    }\n};\nconst generateLayoutIcons = (layoutHeight, iconCount)=>{\n    const layoutRootPath = \"\".concat(layoutIconRootPath).concat(layoutHeight, \"/\");\n    return Array.from({\n        length: iconCount\n    }, (_, i)=>\"\".concat(layoutRootPath).concat(i + 1, \".svg\"));\n};\n// Generating icon paths for each layout\nconst layout53Icons = generateLayoutIcons(53, 3);\nconst layout63Icons = generateLayoutIcons(63, 6);\nconst layout73Icons = generateLayoutIcons(73, 7);\nconst layout93Icons = generateLayoutIcons(93, 8);\nconst layout103Icons = generateLayoutIcons(103, 8);\nconst layout123Icons = generateLayoutIcons(123, 8);\nconst layout133Icons = generateLayoutIcons(133, 6); // Adjusted for 6 icons only\nconst layout143Icons = generateLayoutIcons(143, 6);\n// Model Paths\nconst modelsRootPath = \"/assets/models/\";\nconst shadowManModelPath = modelsRootPath + \"shadow_man.glb\";\nconst handleAModelPath = modelsRootPath + \"handle_A.glb\";\nconst handleBModelPath = modelsRootPath + \"handle_B.glb\";\nconst legsModelPath = modelsRootPath + \"legs.glb\";\nconst noLegsModelPath = modelsRootPath + \"no_legs.glb\";\nconst tvModelPath = modelsRootPath + \"tv.glb\";\nvar ECabinetStyle;\n(function(ECabinetStyle) {\n    ECabinetStyle[\"GRID\"] = \"grid\";\n    ECabinetStyle[\"GRADIENT\"] = \"gradient\";\n    ECabinetStyle[\"MOSAIC\"] = \"mosaic\";\n    ECabinetStyle[\"FRAME\"] = \"frame\";\n    ECabinetStyle[\"SLANT\"] = \"slant\";\n    ECabinetStyle[\"PIXEL\"] = \"pixel\";\n    ECabinetStyle[\"MODERN\"] = \"modern\";\n    ECabinetStyle[\"CLASSIC\"] = \"classic\";\n})(ECabinetStyle || (ECabinetStyle = {}));\nvar ECabinetLegs;\n(function(ECabinetLegs) {\n    ECabinetLegs[\"LEGS\"] = \"LEGS\";\n    ECabinetLegs[\"NO_LEG\"] = \"NO_LEG\";\n    ECabinetLegs[\"FLOATING\"] = \"FLOATING\";\n})(ECabinetLegs || (ECabinetLegs = {}));\nvar ECabinetHandles;\n(function(ECabinetHandles) {\n    ECabinetHandles[\"HANDLE_A\"] = \"HANDLE_A\";\n    ECabinetHandles[\"HANDLE_B\"] = \"HANDLE_B\";\n    ECabinetHandles[\"PUSH\"] = \"PUSH\";\n})(ECabinetHandles || (ECabinetHandles = {}));\nvar ECabinetFinishes;\n(function(ECabinetFinishes) {\n    ECabinetFinishes[\"PLYWOOD\"] = \"Plywood\";\n    ECabinetFinishes[\"VENEER\"] = \"Veneer\";\n})(ECabinetFinishes || (ECabinetFinishes = {}));\n// Functions\n// Get the array of remaining columns widths\nconst getWidthArray = (style, totalWidth)=>{\n    let widthArray = [];\n    const unit = 100;\n    switch(style){\n        case \"grid\":\n            if (totalWidth < CELL_SIZE.maxWidth * unit) {\n                widthArray = [\n                    totalWidth - 2 * PLATE_THICKNESS * unit\n                ];\n            } else if (totalWidth < 112) {\n                widthArray = getRemainingColumns(totalWidth - 3 * PLATE_THICKNESS * unit);\n            } else if (totalWidth < 154) {\n                widthArray = [\n                    44\n                ];\n            } else if (totalWidth < 197) {\n                widthArray = [\n                    44,\n                    38\n                ];\n            } else if (totalWidth < 243) {\n                widthArray = [\n                    44,\n                    38,\n                    44\n                ];\n            } else if (totalWidth < 282) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37\n                ];\n            } else if (totalWidth < 327) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43\n                ];\n            } else if (totalWidth < 372) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43\n                ];\n            } else if (totalWidth < 412) {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38\n                ];\n            } else {\n                widthArray = [\n                    44,\n                    38,\n                    44,\n                    37,\n                    43,\n                    43,\n                    38,\n                    44\n                ];\n            }\n            break;\n        default:\n            break;\n    }\n    return widthArray;\n};\n// Get the vertical layout of a column for a given cabinet height\nconst getColumnVerticalLayout = (param)=>{\n    let { cabinetHeight } = param;\n    const currentlayout = [];\n    const numberOfRows = getRowCount({\n        cabinetHeight\n    });\n    for(let i = 0; i < numberOfRows; i++){\n        currentlayout.push({\n            index: i,\n            height: getCellHeight(numberOfRows, cabinetHeight)\n        });\n    }\n    return currentlayout;\n};\n// Get the distance between two Vector3s\nfunction getDistance(p1, p2) {\n    // return the square root of the sum of the squares of the differences of the x and z coordinates\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.z - p1.z) ** 2);\n}\n// Get the count of rows for a given cabinet height\nfunction getRowCount(param) {\n    let { cabinetHeight } = param;\n    // Get the maximum height of a cell\n    const maxHeight = CELL_SIZE.maxHeight;\n    // Return the number of rows\n    return Math.floor((cabinetHeight - PLATE_THICKNESS) / (maxHeight + PLATE_THICKNESS)) + 1;\n}\n// Get the number of columns and the width of a cell for a given total width\nfunction getColumnCount(param) {\n    let { totalWidth } = param;\n    // Get the maximum width of a cell\n    const maxWidth = CELL_SIZE.maxWidth;\n    // Get the number of columns according to the total width\n    const numberOfColumns = Math.floor((totalWidth - PLATE_THICKNESS) / (maxWidth + PLATE_THICKNESS)) + 1;\n    // Get the total width of cells without\n    const sum = totalWidth - (numberOfColumns + 1) * PLATE_THICKNESS;\n    // Round to 2 decimal places\n    const widthOfCell = Math.round(sum / numberOfColumns * 100) / 100;\n    return {\n        numberOfColumns,\n        widthOfCell\n    };\n}\n// Get the height of a cell for a given number of rows and a cabinet height\nfunction getCellHeight(rowCount, cabinetHeight) {\n    // Get the height of a cell\n    const cellHeight = (cabinetHeight - (rowCount - 1) * PLATE_THICKNESS) / rowCount;\n    return cellHeight;\n}\n// Get the width of a cell for a given number of columns and a total width\nfunction getCellWidth(columnCount, totalWidth) {\n    // Get the width of a cell\n    const cellWidth = (totalWidth - (columnCount + 1) * PLATE_THICKNESS) / columnCount;\n    return cellWidth;\n}\nfunction getBottomHeight(legs) {\n    return legs === \"NO_LEG\" ? 0.02 : LEG_HEIGHT;\n}\nfunction getPartitonPlates(param) {\n    let { columns, totalHeight, totalWidth, totalDepth, legHeight } = param;\n    const verticals = [];\n    const horizontals = [];\n    const availableSpaces = [];\n    const backsides = [];\n    const spaceHeight = totalHeight - 2 * PLATE_THICKNESS - legHeight;\n    const posY = (totalHeight + legHeight) / 2;\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    verticals.push({\n        row: 0,\n        col: -1,\n        position: {\n            x: startPosX,\n            y: posY,\n            z: 0\n        },\n        scale: {\n            width: spaceHeight,\n            depth: totalDepth\n        }\n    });\n    for(let col = 0; col < columns.length; col++){\n        const column = columns[col];\n        const rows = column.rows;\n        let sum = 0;\n        for(let i = 0; i < col + 1; i++){\n            sum += columns[i].width;\n        }\n        const posX = startPosX + sum + (col + 1) * PLATE_THICKNESS;\n        const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n        verticals.push({\n            row: 0,\n            col,\n            position: {\n                x: posX,\n                y: posY,\n                z: 0\n            },\n            scale: {\n                width: spaceHeight,\n                depth: totalDepth\n            }\n        });\n        availableSpaces.push({\n            row: 0,\n            col,\n            position: {\n                x: spacePosX,\n                y: posY,\n                z: totalDepth / 2\n            },\n            scale: {\n                width: column.width,\n                depth: spaceHeight\n            }\n        });\n        for(let rowIndex = 0; rowIndex < rows.length; rowIndex++){\n            let verticalSum = 0;\n            for(let p = 0; p < rowIndex + 1; p++){\n                verticalSum += rows[rowIndex].height;\n            }\n            const middlePosY = bottomPosY + verticalSum + (rowIndex + 1) * PLATE_THICKNESS;\n            const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[rowIndex].height / 2;\n            const backPosZ = -(totalDepth - PLATE_THICKNESS) / 2;\n            if (rowIndex < rows.length - 1) {\n                horizontals.push({\n                    row: rowIndex,\n                    col,\n                    position: {\n                        x: spacePosX,\n                        y: middlePosY,\n                        z: 0\n                    },\n                    scale: {\n                        width: column.width,\n                        depth: totalDepth - EDGE_GAP\n                    }\n                });\n            }\n            backsides.push({\n                row: rowIndex,\n                col,\n                position: {\n                    x: spacePosX,\n                    y: backPosY,\n                    z: backPosZ\n                },\n                scale: {\n                    width: column.width,\n                    depth: rows[rowIndex].height\n                }\n            });\n        }\n    }\n    return {\n        verticals,\n        availableSpaces,\n        horizontals,\n        backsides\n    };\n}\n// Fix the function signature\nconst getCalculatedColumns = (param)=>{\n    let { current: _current, cabinetSize, cabinetStyle, legHeight, columnCount } = param;\n    const { totalWidth, totalHeight } = cabinetSize;\n    // Calculate available width (total width minus side plates)\n    const availableWidth = totalWidth - 2 * PLATE_THICKNESS;\n    // Determine how many columns can fit\n    let numColumns;\n    if (columnCount) {\n        numColumns = columnCount;\n    } else {\n        // Calculate based on minimum column width\n        numColumns = Math.floor(availableWidth / (CELL_SIZE.minWidth + PLATE_THICKNESS));\n        // Ensure at least one column\n        numColumns = Math.max(1, numColumns);\n    }\n    // Calculate column width\n    const columnWidth = (availableWidth - (numColumns - 1) * PLATE_THICKNESS) / numColumns;\n    // Create columns array\n    const columns = [];\n    // Generate each column\n    for(let i = 0; i < numColumns; i++){\n        // Calculate position\n        const posX = -totalWidth / 2 + PLATE_THICKNESS + i * (columnWidth + PLATE_THICKNESS) + columnWidth / 2;\n        // Create column with appropriate layout\n        const column = createColumnWithLayout(columnWidth, posX, totalHeight, legHeight, cabinetStyle);\n        columns.push(column);\n    }\n    return columns;\n};\nfunction getRemainingColumns(remainingWidth) {\n    const b = remainingWidth % 2 === 0 ? remainingWidth / 2 : (remainingWidth + 1) / 2;\n    const c = remainingWidth - b;\n    return [\n        b,\n        c\n    ];\n}\nfunction getIndividualColumn(param) {\n    let { targetIndex, columns, totalWidth, totalDepth, legHeight } = param;\n    const column = columns[targetIndex];\n    const startPosX = -(totalWidth - PLATE_THICKNESS) / 2;\n    const bottomPosY = legHeight + PLATE_THICKNESS / 2;\n    const rowsPos = [];\n    const delta = 0.02;\n    const rows = column.rows;\n    let sum = 0;\n    for(let i = 0; i < targetIndex + 1; i++){\n        sum += columns[i].width;\n    }\n    const posX = startPosX + sum + (targetIndex + 1) * PLATE_THICKNESS;\n    const spacePosX = posX - PLATE_THICKNESS / 2 - column.width / 2;\n    for(let i = 0; i < rows.length; i++){\n        let verticalSum = 0;\n        for(let p = 0; p < i + 1; p++){\n            verticalSum += rows[p].height;\n        }\n        const middlePosY = bottomPosY + verticalSum + (i + 1) * PLATE_THICKNESS;\n        const backPosY = middlePosY - PLATE_THICKNESS / 2 - rows[i].height / 2;\n        rowsPos.push({\n            x: spacePosX - column.width / 2,\n            y: backPosY,\n            z: totalDepth / 2 + delta,\n            height: rows[i].height\n        });\n    }\n    return {\n        position: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(spacePosX, legHeight + PLATE_THICKNESS + delta, totalDepth / 2 + delta),\n        rows: rowsPos\n    };\n}\nconst getLayoutImages = (param)=>{\n    let { totalHeight } = param;\n    let imgsArray = [];\n    if (totalHeight < 0.53) {\n        imgsArray = [\n            ...layout53Icons\n        ];\n    } else if (totalHeight < 0.63) {\n        imgsArray = [\n            ...layout63Icons\n        ];\n    } else if (totalHeight < 0.73) {\n        imgsArray = [\n            ...layout73Icons\n        ];\n    } else if (totalHeight < 0.93) {\n        imgsArray = [\n            ...layout93Icons\n        ];\n    } else if (totalHeight < 1.03) {\n        imgsArray = [\n            ...layout103Icons\n        ];\n    } else if (totalHeight < 1.23) {\n        imgsArray = [\n            ...layout123Icons\n        ];\n    } else if (totalHeight < 1.33) {\n        imgsArray = [\n            ...layout133Icons\n        ];\n    } else {\n        imgsArray = [\n            ...layout143Icons\n        ];\n    }\n    return imgsArray;\n};\nconst getId = (item)=>\"\".concat(item, \"-\").concat(Math.random().toString(32).slice(-4));\nconst createColumnWithLayout = (columnWidth, posX, totalHeight, legHeight, cabinetStyle)=>{\n    // Calculate the cabinet height (excluding legs and plate thickness)\n    const cabinetHeight = totalHeight - legHeight - 2 * PLATE_THICKNESS;\n    // Get the basic vertical layout for the column\n    const rows = getColumnVerticalLayout({\n        cabinetHeight\n    });\n    // Get the starting position Y coordinate\n    const startPosY = legHeight + PLATE_THICKNESS;\n    // Default to an empty layout (will be populated based on style)\n    let layoutIndex = 0;\n    let doors = [];\n    let drawers = [];\n    // Based on cabinet style, choose an appropriate layout\n    switch(cabinetStyle){\n        case \"modern\":\n            // For modern style, use all drawers\n            layoutIndex = 1;\n            // Create a drawer for each row\n            drawers = rows.map((row, index)=>({\n                    index,\n                    size: {\n                        width: columnWidth,\n                        height: row.height\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + (index + 0.5) * row.height + index * PLATE_THICKNESS\n                    }\n                }));\n            break;\n        case \"classic\":\n        default:\n            // For classic style, use doors for all rows\n            layoutIndex = 0;\n            // Create a door for the full height\n            doors = [\n                {\n                    index: 0,\n                    size: {\n                        width: columnWidth,\n                        height: cabinetHeight\n                    },\n                    pos: {\n                        x: posX,\n                        y: startPosY + cabinetHeight / 2\n                    },\n                    opening: 1\n                }\n            ];\n            break;\n    }\n    // Create and return the column object\n    return {\n        id: Math.random().toString(36).substr(2, 9),\n        index: 0,\n        width: columnWidth,\n        posX: posX,\n        rows: rows,\n        doors: doors,\n        drawers: drawers,\n        dividers: [],\n        layoutIndex: layoutIndex,\n        isDivide: false,\n        lastRow: drawers.length > 0 ? \"drawer\" : \"door\"\n    };\n};\n// Update the cabinet size constraints\nconst CABINET_SIZE_CONSTRAINTS = {\n    minWidth: 0.4,\n    maxWidth: 2.5,\n    minHeight: 0.4,\n    maxHeight: 2.4,\n    minDepth: 0.3,\n    maxDepth: 0.8\n};\nconst applyRandomLayoutsToColumns = (columns, totalHeight, legHeight)=>{\n    const startPosY = legHeight + PLATE_THICKNESS;\n    return columns.map((column)=>{\n        // Get all available layout options for this column\n        const layoutOptions = (0,_columnLayoutOptions__WEBPACK_IMPORTED_MODULE_0__.getLayoutOptionsOfColumn)({\n            totalHeight,\n            legHeight,\n            columnWidth: column.width,\n            posX: column.posX,\n            startPosY,\n            doorDir: 1 // Default door opening direction\n        });\n        // Select a random layout option\n        const randomLayoutIndex = Math.floor(Math.random() * layoutOptions.length);\n        const randomLayout = layoutOptions[randomLayoutIndex];\n        // Apply the random layout to the column\n        return {\n            ...column,\n            layoutIndex: randomLayoutIndex,\n            rows: randomLayout.rows,\n            doors: randomLayout.doors,\n            drawers: randomLayout.drawers,\n            lastRow: randomLayout.lastRow\n        };\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy91dGlsaXRpZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDK0I7QUFFa0M7QUFFakUsZUFBZTtBQUNmLGFBQWE7QUFDTixNQUFNRSxrQkFBa0IsS0FBSztBQUM3QixNQUFNQyxZQUFZO0lBQ3ZCQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxXQUFXO0FBQ2IsRUFBRTtBQUNLLE1BQU1DLGFBQWEsS0FBSztBQUN4QixNQUFNQyxZQUFZLEtBQUs7QUFDdkIsTUFBTUMsWUFBWSxLQUFLO0FBQ3ZCLE1BQU1DLFdBQVcsTUFBTTtBQUU5QixTQUFTO0FBQ0YsTUFBTUMsWUFBWSxVQUFVO0FBQzVCLE1BQU1DLGFBQWEsVUFBVTtBQUM3QixNQUFNQyxvQkFBb0IsVUFBVTtBQUNwQyxNQUFNQyx3QkFBd0IsVUFBVTtBQUUvQyxnQkFBZ0I7QUFDaEIsTUFBTUMsbUJBQW1CO0FBQ2xCLE1BQU1DLGtCQUFrQkQsbUJBQW1CLGtCQUFrQjtBQUNwRSxNQUFNRSxrQkFBa0JGLG1CQUFtQjtBQUMzQyxNQUFNRyxtQkFBbUJELGtCQUFrQjtBQUMzQyxNQUFNRSx1QkFBdUJGLGtCQUFrQjtBQUMvQyxNQUFNRywwQkFBMEJILGtCQUFrQjtBQUUzQyxNQUFNSSxrQkFBa0I7SUFDN0JDLE9BQU9KO0lBQ1BLLFdBQVdKO0lBQ1hLLGNBQWNKO0FBQ2hCLEVBQUU7QUFFRix1QkFBdUI7QUFDdkIsTUFBTUssZUFBZVYsbUJBQW1CO0FBQ3hDLE1BQU1XLGtCQUFrQkQsZUFBZTtBQUN2QyxNQUFNRSxzQkFBc0JGLGVBQWU7QUFDM0MsTUFBTUcseUJBQXlCSCxlQUFlO0FBRXZDLE1BQU1JLGlCQUFpQjtJQUM1QlAsT0FBT0k7SUFDUEgsV0FBV0k7SUFDWEgsY0FBY0k7QUFDaEIsRUFBRTs7VUFHVUU7Z0VBQ2VmO0lBQ3pCLDBFQUEwRTt5REFD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QUssQ0FBQ0osS0FBS29FLE1BQU0sS0FBS29CLGNBQWMvSCxNQUFNO1FBQ3pFLE1BQU1rSSxlQUFlSCxhQUFhLENBQUNFLGtCQUFrQjtRQUVyRCx3Q0FBd0M7UUFDeEMsT0FBTztZQUNMLEdBQUd0RCxNQUFNO1lBQ1RvQyxhQUFha0I7WUFDYnJELE1BQU1zRCxhQUFhdEQsSUFBSTtZQUN2Qm9DLE9BQU9rQixhQUFhbEIsS0FBSztZQUN6QkMsU0FBU2lCLGFBQWFqQixPQUFPO1lBQzdCUyxTQUFTUSxhQUFhUixPQUFPO1FBQy9CO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy91dGlsaXRpZXMudHM/MzExZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJQ2FiaW5ldFNpemUsIElDb2x1bW4sIElQYXJ0aXRpb24gfSBmcm9tICdAL3N0b3JlL3R5cGVzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBnZXRMYXlvdXRPcHRpb25zT2ZDb2x1bW4gfSBmcm9tICcuL2NvbHVtbkxheW91dE9wdGlvbnMnO1xuXG4vLy0tLSBDT05TVEFOVFNcbi8vIERpbWVuc2lvbnNcbmV4cG9ydCBjb25zdCBQTEFURV9USElDS05FU1MgPSAwLjAyO1xuZXhwb3J0IGNvbnN0IENFTExfU0laRSA9IHtcbiAgbWF4V2lkdGg6IDAuNjAsXG4gIG1pbldpZHRoOiAwLjI1LFxuICBtYXhIZWlnaHQ6IDAuMzUsXG4gIG1pbkhlaWdodDogMC4xNSxcbn07XG5leHBvcnQgY29uc3QgTEVHX0hFSUdIVCA9IDAuMTg7XG5leHBvcnQgY29uc3QgTEVHX1dJRFRIID0gMC4wNTtcbmV4cG9ydCBjb25zdCBMRUdfREVQVEggPSAwLjA1O1xuZXhwb3J0IGNvbnN0IEVER0VfR0FQID0gMC4wMDY7XG5cbi8vIENvbG9yc1xuZXhwb3J0IGNvbnN0IHdhbGxDb2xvciA9ICcjZTdlN2U3JztcbmV4cG9ydCBjb25zdCBmbG9vckNvbG9yID0gJyNiN2I3YjcnO1xuZXhwb3J0IGNvbnN0IGFtYmllbnRMaWdodENvbG9yID0gJyNmMGYwZjAnO1xuZXhwb3J0IGNvbnN0IGRpcmVjdGlvbmFsTGlnaHRDb2xvciA9ICcjZjBmMGYwJztcblxuLy8gVGV4dHVyZSBwYXRoc1xuY29uc3QgdGV4dHVyZXNSb290UGF0aCA9ICcvYXNzZXRzL3RleHR1cmVzLyc7XG5leHBvcnQgY29uc3QgZW52aXJvbm1lbnRQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICdlbnZpcm9ubWVudC5oZHInO1xuY29uc3QgcGx5d29vZFJvb3RQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kXzFrL3RleHR1cmVzLyc7XG5jb25zdCBwbHl3b29kQW9NYXBQYXRoID0gcGx5d29vZFJvb3RQYXRoICsgJ3BseXdvb2RfYW9fMWsuanBnJztcbmNvbnN0IHBseXdvb2ROb3JtYWxNYXBQYXRoID0gcGx5d29vZFJvb3RQYXRoICsgJ3BseXdvb2Rfbm9yX2dsXzFrLmpwZyc7XG5jb25zdCBwbHl3b29kUm91Z2huZXNzTWFwUGF0aCA9IHBseXdvb2RSb290UGF0aCArICdwbHl3b29kX3JvdWdoXzFrLmpwZyc7XG5cbmV4cG9ydCBjb25zdCBwbHl3b29kVGV4dHVyZXMgPSB7XG4gIGFvTWFwOiBwbHl3b29kQW9NYXBQYXRoLFxuICBub3JtYWxNYXA6IHBseXdvb2ROb3JtYWxNYXBQYXRoLFxuICByb3VnaG5lc3NNYXA6IHBseXdvb2RSb3VnaG5lc3NNYXBQYXRoLFxufTtcblxuLy8gQmFzZSBUZXh0dXJlcyBWZWVuZXJcbmNvbnN0IHdvb2RSb290UGF0aCA9IHRleHR1cmVzUm9vdFBhdGggKyAnd29vZF8yNy8nO1xuY29uc3QgdmVuZWVyQW9NYXBQYXRoID0gd29vZFJvb3RQYXRoICsgJ2FtYmllbnQtb2NjbHVzaW9uLmpwZyc7XG5jb25zdCB2ZW5lZXJOb3JtYWxNYXBQYXRoID0gd29vZFJvb3RQYXRoICsgJ25vcm1hbC5qcGcnO1xuY29uc3QgdmVuZWVyUm91Z2huZXNzTWFwUGF0aCA9IHdvb2RSb290UGF0aCArICdyb3VnaG5lc3MuanBnJztcblxuZXhwb3J0IGNvbnN0IHZlbmVlclRleHR1cmVzID0ge1xuICBhb01hcDogdmVuZWVyQW9NYXBQYXRoLFxuICBub3JtYWxNYXA6IHZlbmVlck5vcm1hbE1hcFBhdGgsXG4gIHJvdWdobmVzc01hcDogdmVuZWVyUm91Z2huZXNzTWFwUGF0aCxcbn07XG5cbi8vIFZlbmVlciBUZXh0dXJlc1xuZXhwb3J0IGVudW0gRVZlbmVlclRleHR1cmVzIHtcbiAgQkVJR0VfR1JFWV9MT1JFTlpPX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2JlaWdlX2dyZXlfbG9yZW56b19vYWsuanBnJyxcbiAgLy8gQkVJR0VfVEVYVElMRSA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2JlaWdlX3RleHRpbGUuanBnJyxcbiAgQlJPV05fQUJBTk9fQVNIID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYnJvd25fYWJhbm9fYXNoLmpwZycsXG4gIEJST1dOX0hBTElGQVhfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvYnJvd25faGFsaWZheF9vYWsuanBnJyxcbiAgQlJPV05fVE9OTlNCRVJHX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2Jyb3duX3Rvbm5zYmVyZ19vYWsuanBnJyxcbiAgQlJPV05fV0FSTUlBX1dBTExOVVQgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC9icm93bl93YXJtaWFfd2FsbG51dC5qcGcnLFxuICBMSUdIVF9CQVJPTklBX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL2xpZ2h0X2Jhcm9uaWFfb2FrLmpwZycsXG4gIExJR0hUX05BVFVSQUxfREFWRU5QT1JUX09BSyA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL0xpZ2h0X05hdHVyYWxfRGF2ZW5wb3J0X29hay5qcGcnLFxuICBOQVRVUkFMX0NBU0VMTEFfT0FLID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvbmF0dXJhbF9jYXNlbGxhX29hay5qcGcnLFxuICBQQVJPTkFfV0FMTE5VVCA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVuZWVyLW9hay13b29kL3Bhcm9uYV93YWxsbnV0LmpwZycsXG4gIFNFVklMTEFfQVNIID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2Qvc2V2aWxsYV9hc2guanBnJyxcbiAgVklDRU5aQV9PQUsgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3ZlbmVlci1vYWstd29vZC92aWNlbnphX29hay5qcGcnLFxuICBWSUNFTlpBX09BS18yID0gdGV4dHVyZXNSb290UGF0aCArICd2ZW5lZXItb2FrLXdvb2QvdmljZW56YV9vYWsyLmpwZycsXG59XG5cbi8vUGx5d29vZCBUZXh0dXJlc1xuZXhwb3J0IGVudW0gRVBseXdvb2RUZXh0dXJlcyB7XG4gIEJST05aRV9CUlVTSEVEX01FVEFMID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9icm9uemVfYnJ1c2hlZF9tZXRhbC5qcGcnLFxuICBBTE1PTkRfQkVJR0UgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2FsbW9uZF9iZWlnZS5qcGcnLFxuICBDQVJBVF9CRUlHRSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvY2FyYXRfYmVpZ2UuanBnJyxcbiAgQ0FTSE1FUkVfR1JFWSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvY2FzaG1lcmVfZ3JleS5qcGcnLFxuICBDT1JBX0JST05aRSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvY29icmFfYnJvbnplLmpwZycsXG4gIENVQkFOSVRFX0dSRVkgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2N1YmFuaXRlX2dyZXkuanBnJyxcbiAgRklSX0dSRUVOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy9maXJfZ3JlZW4uanBnJyxcbiAgRkpPUkRfR1JFRU4gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2Zqb3JkX2dyZWVuLmpwZycsXG4gIEdSQVBISVRFX0dSRVkgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2dyYXBoaXRlX2dyZXkuanBnJyxcbiAgSU5ESUdPX0JMVUUgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL2luZGlnb19ibHVlLmpwZycsXG4gIFJFRURfR1JFRU4gPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL3JlZWRfZ3JlZW4uanBnJyxcbiAgU0FHRV9HUkVFTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvc2FnZV9ncmVlbi5qcGcnLFxuICBTVE9ORV9HUkVFTiA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvc3RvbmVfZ3JlZW4uanBnJyxcbiAgVEFVUEVfR1JFWSA9IHRleHR1cmVzUm9vdFBhdGggKyAncGx5d29vZC1jb2xvcnMvdGF1cGVfZ3JleS5qcGcnLFxuICBUUlVGRkxFX0JST1dOID0gdGV4dHVyZXNSb290UGF0aCArICdwbHl3b29kLWNvbG9ycy90cnVmZmxlX2Jyb3duLmpwZycsXG4gIFU5OTlfUE1fQkxBQ0sgPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ3BseXdvb2QtY29sb3JzL1U5OTlfUE1fQmxhY2suanBnJyxcbn1cblxuLy8gT2NjbHVzaW9uIFRleHR1cmVzXG5leHBvcnQgY29uc3QgaG9yaXpvbnRhbE9jY2x1c2lvblRleHR1cmVQYXRoID0gdGV4dHVyZXNSb290UGF0aCArICdob3Jpem9udGFsLXBhbmVsLmpwZyc7XG5leHBvcnQgY29uc3QgdmVydGljYWxPY2NsdXNpb25UZXh0dXJlUGF0aCA9IHRleHR1cmVzUm9vdFBhdGggKyAndmVydGljYWwtcGFuZWwuanBnJztcbmV4cG9ydCBjb25zdCBiYWNrT2NjbHVzaW9uVGV4dHVyZVBhdGggPSB0ZXh0dXJlc1Jvb3RQYXRoICsgJ2JhY2stcGFuZWwuanBnJztcblxuZXhwb3J0IGVudW0gRU9jY2x1c2lvbkltYWdlcyB7XG4gIEhPUklaT05UQUwgPSBob3Jpem9udGFsT2NjbHVzaW9uVGV4dHVyZVBhdGgsXG4gIEJBQ0sgPSB2ZXJ0aWNhbE9jY2x1c2lvblRleHR1cmVQYXRoLFxuICBWRVJUSUNBTCA9IGJhY2tPY2NsdXNpb25UZXh0dXJlUGF0aCxcbn1cblxuLy8gTGF5b3V0IEljb25zXG5jb25zdCBsYXlvdXRJY29uUm9vdFBhdGggPSAnL2Fzc2V0cy9pY29ucy9vbi1tb2RlbC1lZGl0b3IvJztcblxuZXhwb3J0IGNvbnN0IGljb25pZnlJY29ucyA9IHtcbiAgbGF5b3V0SWNvbnM6IHtcbiAgICB1bmRvSWNvbjogJ3NvbGFyOnVuZG8tbGVmdC1yb3VuZC1vdXRsaW5lJyxcbiAgICBkaW1lbnNpb25zSWNvbjogJ3NvbGFyOnJ1bGVyLWxpbmVhcicsXG4gICAgZG9vcnNJY29uOiAnZmx1ZW50OmRvb3ItMjAtcmVndWxhcicsXG4gICAgYWxpZ25Db2x1bW5zSWNvbjogJ2Zsb3diaXRlOmdyaWQtcGx1cy1vdXRsaW5lJyxcbiAgICBzaG93RGVjb3JhdGlvbnNJY29uOiAnaHVnZWljb25zOnBhaW50LWJydXNoLTAyJyxcbiAgICBhc3NlbWJseUljb246ICdjYXJib246M2QtY3Vyc29yJyxcbiAgfSxcbiAgbWVudUljb25zOiB7XG4gICAgYXJyb3dVcDogJ2l3d2E6YXJyb3ctdXAnLFxuICAgIGFycm93RG93bjogJ2l3d2E6YXJyb3ctZG93bicsXG4gICAgaW5mb1F1ZXN0aW9uOiAncGg6cXVlc3Rpb24tYm9sZCcsXG4gIH0sXG4gIHNjZW5lSWNvbnM6IHtcbiAgICBlZGl0TGF5b3V0OiAnaWMtb3V0bGluZS1jcmVhdGUnLFxuICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IG1lbnVJY29uUGF0aHM6IHtcbiAgbGVnczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgaGFuZGxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgc3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufSA9IHtcbiAgbGVnczoge1xuICAgIG5vX2xlZzogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9sZWdzL25vX2xlZy5zdmcnLFxuICAgIGxlZ3M6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvbGVncy9sZWdzLnN2ZycsXG4gICAgZmxvYXRpbmc6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvbGVncy9mbG9hdGluZy5zdmcnLFxuICB9LFxuICBoYW5kbGVzOiB7XG4gICAgaGFuZGxlX2E6ICcvYXNzZXRzL2ljb25zL21lbnUtaWNvbnMvaGFuZGxlcy9oYW5kbGVfQS5zdmcnLFxuICAgIGhhbmRsZV9iOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL2hhbmRsZXMvaGFuZGxlX0Iuc3ZnJyxcbiAgICBwdXNoOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL2hhbmRsZXMvcHVzaC5zdmcnLFxuICB9LFxuICBzdHlsZXM6IHtcbiAgICBmcmFtZTogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9zdHlsZXMvZnJhbWUuc3ZnJyxcbiAgICBncmFkaWVudDogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9zdHlsZXMvZ3JhZGllbnQuc3ZnJyxcbiAgICBncmlkOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9ncmlkLnN2ZycsXG4gICAgbW9zYWljOiAnL2Fzc2V0cy9pY29ucy9tZW51LWljb25zL3N0eWxlcy9tb3NhaWMuc3ZnJyxcbiAgICBwaXhlbDogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9zdHlsZXMvcGl4ZWwuc3ZnJyxcbiAgICBzbGFudDogJy9hc3NldHMvaWNvbnMvbWVudS1pY29ucy9zdHlsZXMvc2xhbnQuc3ZnJyxcbiAgfSxcbn07XG5cbmNvbnN0IGdlbmVyYXRlTGF5b3V0SWNvbnMgPSAobGF5b3V0SGVpZ2h0OiBudW1iZXIsIGljb25Db3VudDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IGxheW91dFJvb3RQYXRoID0gYCR7bGF5b3V0SWNvblJvb3RQYXRofSR7bGF5b3V0SGVpZ2h0fS9gO1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogaWNvbkNvdW50IH0sIChfLCBpKSA9PiBgJHtsYXlvdXRSb290UGF0aH0ke2kgKyAxfS5zdmdgKTtcbn07XG5cbi8vIEdlbmVyYXRpbmcgaWNvbiBwYXRocyBmb3IgZWFjaCBsYXlvdXRcbmNvbnN0IGxheW91dDUzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDUzLCAzKTtcbmNvbnN0IGxheW91dDYzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDYzLCA2KTtcbmNvbnN0IGxheW91dDczSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDczLCA3KTtcbmNvbnN0IGxheW91dDkzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDkzLCA4KTtcbmNvbnN0IGxheW91dDEwM0ljb25zID0gZ2VuZXJhdGVMYXlvdXRJY29ucygxMDMsIDgpO1xuY29uc3QgbGF5b3V0MTIzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDEyMywgOCk7XG5jb25zdCBsYXlvdXQxMzNJY29ucyA9IGdlbmVyYXRlTGF5b3V0SWNvbnMoMTMzLCA2KTsgLy8gQWRqdXN0ZWQgZm9yIDYgaWNvbnMgb25seVxuY29uc3QgbGF5b3V0MTQzSWNvbnMgPSBnZW5lcmF0ZUxheW91dEljb25zKDE0MywgNik7XG5cbi8vIE1vZGVsIFBhdGhzXG5jb25zdCBtb2RlbHNSb290UGF0aCA9ICcvYXNzZXRzL21vZGVscy8nO1xuXG5leHBvcnQgY29uc3Qgc2hhZG93TWFuTW9kZWxQYXRoID0gbW9kZWxzUm9vdFBhdGggKyAnc2hhZG93X21hbi5nbGInO1xuZXhwb3J0IGNvbnN0IGhhbmRsZUFNb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICdoYW5kbGVfQS5nbGInO1xuZXhwb3J0IGNvbnN0IGhhbmRsZUJNb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICdoYW5kbGVfQi5nbGInO1xuZXhwb3J0IGNvbnN0IGxlZ3NNb2RlbFBhdGggPSBtb2RlbHNSb290UGF0aCArICdsZWdzLmdsYic7XG5leHBvcnQgY29uc3Qgbm9MZWdzTW9kZWxQYXRoID0gbW9kZWxzUm9vdFBhdGggKyAnbm9fbGVncy5nbGInO1xuZXhwb3J0IGNvbnN0IHR2TW9kZWxQYXRoID0gbW9kZWxzUm9vdFBhdGggKyAndHYuZ2xiJztcblxuLy8gRW51bXNcbmV4cG9ydCBlbnVtIEVDYWJpbmV0U3R5bGUge1xuICBHUklEID0gJ2dyaWQnLFxuICBHUkFESUVOVCA9ICdncmFkaWVudCcsXG4gIE1PU0FJQyA9ICdtb3NhaWMnLFxuICBGUkFNRSA9ICdmcmFtZScsXG4gIFNMQU5UID0gJ3NsYW50JyxcbiAgUElYRUwgPSAncGl4ZWwnLFxuICBNT0RFUk4gPSAnbW9kZXJuJyxcbiAgQ0xBU1NJQyA9ICdjbGFzc2ljJyxcbn1cblxuZXhwb3J0IGVudW0gRUNhYmluZXRMZWdzIHtcbiAgTEVHUyA9ICdMRUdTJyxcbiAgTk9fTEVHID0gJ05PX0xFRycsXG4gIEZMT0FUSU5HID0gJ0ZMT0FUSU5HJyxcbn1cblxuZXhwb3J0IGVudW0gRUNhYmluZXRIYW5kbGVzIHtcbiAgSEFORExFX0EgPSAnSEFORExFX0EnLFxuICBIQU5ETEVfQiA9ICdIQU5ETEVfQicsXG4gIFBVU0ggPSAnUFVTSCcsXG59XG5cbmV4cG9ydCBlbnVtIEVDYWJpbmV0RmluaXNoZXMge1xuICBQTFlXT09EID0gJ1BseXdvb2QnLFxuICBWRU5FRVIgPSAnVmVuZWVyJyxcbn1cblxuLy8gRnVuY3Rpb25zXG5cbi8vIEdldCB0aGUgYXJyYXkgb2YgcmVtYWluaW5nIGNvbHVtbnMgd2lkdGhzXG5leHBvcnQgY29uc3QgZ2V0V2lkdGhBcnJheSA9IChzdHlsZTogRUNhYmluZXRTdHlsZSwgdG90YWxXaWR0aDogbnVtYmVyKSA9PiB7XG4gIGxldCB3aWR0aEFycmF5OiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCB1bml0ID0gMTAwO1xuICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSBFQ2FiaW5ldFN0eWxlLkdSSUQ6XG4gICAgICBpZiAodG90YWxXaWR0aCA8IENFTExfU0laRS5tYXhXaWR0aCAqIHVuaXQpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFt0b3RhbFdpZHRoIC0gMiAqIFBMQVRFX1RISUNLTkVTUyAqIHVuaXRdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMTEyKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBnZXRSZW1haW5pbmdDb2x1bW5zKHRvdGFsV2lkdGggLSAzICogUExBVEVfVEhJQ0tORVNTICogdW5pdCk7XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAxNTQpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NF07XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAxOTcpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzhdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMjQzKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NF07XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAyODIpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzN107XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCAzMjcpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzNywgNDNdO1xuICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgMzcyKSB7XG4gICAgICAgIHdpZHRoQXJyYXkgPSBbNDQsIDM4LCA0NCwgMzcsIDQzLCA0M107XG4gICAgICB9IGVsc2UgaWYgKHRvdGFsV2lkdGggPCA0MTIpIHtcbiAgICAgICAgd2lkdGhBcnJheSA9IFs0NCwgMzgsIDQ0LCAzNywgNDMsIDQzLCAzOF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aEFycmF5ID0gWzQ0LCAzOCwgNDQsIDM3LCA0MywgNDMsIDM4LCA0NF07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHdpZHRoQXJyYXk7XG59O1xuXG4vLyBHZXQgdGhlIHZlcnRpY2FsIGxheW91dCBvZiBhIGNvbHVtbiBmb3IgYSBnaXZlbiBjYWJpbmV0IGhlaWdodFxuZXhwb3J0IGNvbnN0IGdldENvbHVtblZlcnRpY2FsTGF5b3V0ID0gKHsgY2FiaW5ldEhlaWdodCB9OiB7IGNhYmluZXRIZWlnaHQ6IG51bWJlciB9KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRsYXlvdXQgPSBbXTtcbiAgY29uc3QgbnVtYmVyT2ZSb3dzID0gZ2V0Um93Q291bnQoeyBjYWJpbmV0SGVpZ2h0IH0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mUm93czsgaSsrKSB7XG4gICAgY3VycmVudGxheW91dC5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgaGVpZ2h0OiBnZXRDZWxsSGVpZ2h0KG51bWJlck9mUm93cywgY2FiaW5ldEhlaWdodCksXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRsYXlvdXQ7XG59O1xuXG4vLyBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIFZlY3RvcjNzXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDE6IFZlY3RvcjMsIHAyOiBWZWN0b3IzKSB7XG4gIC8vIHJldHVybiB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB0aGUgZGlmZmVyZW5jZXMgb2YgdGhlIHggYW5kIHogY29vcmRpbmF0ZXNcbiAgcmV0dXJuIE1hdGguc3FydCgocDIueCAtIHAxLngpICoqIDIgKyAocDIueiAtIHAxLnopICoqIDIpO1xufVxuXG4vLyBHZXQgdGhlIGNvdW50IG9mIHJvd3MgZm9yIGEgZ2l2ZW4gY2FiaW5ldCBoZWlnaHRcbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dDb3VudCh7IGNhYmluZXRIZWlnaHQgfTogeyBjYWJpbmV0SGVpZ2h0OiBudW1iZXIgfSkge1xuICAvLyBHZXQgdGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgY2VsbFxuICBjb25zdCBtYXhIZWlnaHQgPSBDRUxMX1NJWkUubWF4SGVpZ2h0O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIHJvd3NcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGNhYmluZXRIZWlnaHQgLSBQTEFURV9USElDS05FU1MpIC8gKG1heEhlaWdodCArIFBMQVRFX1RISUNLTkVTUykpICsgMTtcbn1cblxuLy8gR2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBhbmQgdGhlIHdpZHRoIG9mIGEgY2VsbCBmb3IgYSBnaXZlbiB0b3RhbCB3aWR0aFxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbHVtbkNvdW50KHsgdG90YWxXaWR0aCB9OiB7IHRvdGFsV2lkdGg6IG51bWJlciB9KSB7XG4gIC8vIEdldCB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIGNlbGxcbiAgY29uc3QgbWF4V2lkdGggPSBDRUxMX1NJWkUubWF4V2lkdGg7XG5cbiAgLy8gR2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBhY2NvcmRpbmcgdG8gdGhlIHRvdGFsIHdpZHRoXG4gIGNvbnN0IG51bWJlck9mQ29sdW1ucyA9IE1hdGguZmxvb3IoKHRvdGFsV2lkdGggLSBQTEFURV9USElDS05FU1MpIC8gKG1heFdpZHRoICsgUExBVEVfVEhJQ0tORVNTKSkgKyAxO1xuXG4gIC8vIEdldCB0aGUgdG90YWwgd2lkdGggb2YgY2VsbHMgd2l0aG91dFxuICBjb25zdCBzdW0gPSB0b3RhbFdpZHRoIC0gKG51bWJlck9mQ29sdW1ucyArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuXG4gIC8vIFJvdW5kIHRvIDIgZGVjaW1hbCBwbGFjZXNcbiAgY29uc3Qgd2lkdGhPZkNlbGwgPSBNYXRoLnJvdW5kKChzdW0gLyBudW1iZXJPZkNvbHVtbnMpICogMTAwKSAvIDEwMDtcblxuICByZXR1cm4ge1xuICAgIG51bWJlck9mQ29sdW1ucyxcbiAgICB3aWR0aE9mQ2VsbCxcbiAgfTtcbn1cblxuLy8gR2V0IHRoZSBoZWlnaHQgb2YgYSBjZWxsIGZvciBhIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBhIGNhYmluZXQgaGVpZ2h0XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VsbEhlaWdodChyb3dDb3VudDogbnVtYmVyLCBjYWJpbmV0SGVpZ2h0OiBudW1iZXIpIHtcbiAgLy8gR2V0IHRoZSBoZWlnaHQgb2YgYSBjZWxsXG4gIGNvbnN0IGNlbGxIZWlnaHQgPSAoY2FiaW5ldEhlaWdodCAtIChyb3dDb3VudCAtIDEpICogUExBVEVfVEhJQ0tORVNTKSAvIHJvd0NvdW50O1xuICByZXR1cm4gY2VsbEhlaWdodDtcbn1cblxuLy8gR2V0IHRoZSB3aWR0aCBvZiBhIGNlbGwgZm9yIGEgZ2l2ZW4gbnVtYmVyIG9mIGNvbHVtbnMgYW5kIGEgdG90YWwgd2lkdGhcbmV4cG9ydCBmdW5jdGlvbiBnZXRDZWxsV2lkdGgoY29sdW1uQ291bnQ6IG51bWJlciwgdG90YWxXaWR0aDogbnVtYmVyKSB7XG4gIC8vIEdldCB0aGUgd2lkdGggb2YgYSBjZWxsXG4gIGNvbnN0IGNlbGxXaWR0aCA9ICh0b3RhbFdpZHRoIC0gKGNvbHVtbkNvdW50ICsgMSkgKiBQTEFURV9USElDS05FU1MpIC8gY29sdW1uQ291bnQ7XG4gIHJldHVybiBjZWxsV2lkdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21IZWlnaHQobGVnczogRUNhYmluZXRMZWdzKSB7XG4gIHJldHVybiBsZWdzID09PSBFQ2FiaW5ldExlZ3MuTk9fTEVHID8gMC4wMiA6IExFR19IRUlHSFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJ0aXRvblBsYXRlcyh7IGNvbHVtbnMsIHRvdGFsSGVpZ2h0LCB0b3RhbFdpZHRoLCB0b3RhbERlcHRoLCBsZWdIZWlnaHQgfTogeyBjb2x1bW5zOiBJQ29sdW1uW107IHRvdGFsSGVpZ2h0OiBudW1iZXI7IHRvdGFsV2lkdGg6IG51bWJlcjsgdG90YWxEZXB0aDogbnVtYmVyOyBsZWdIZWlnaHQ6IG51bWJlciB9KSB7XG4gIGNvbnN0IHZlcnRpY2FsczogSVBhcnRpdGlvbltdID0gW107XG4gIGNvbnN0IGhvcml6b250YWxzOiBJUGFydGl0aW9uW10gPSBbXTtcbiAgY29uc3QgYXZhaWxhYmxlU3BhY2VzOiBJUGFydGl0aW9uW10gPSBbXTtcbiAgY29uc3QgYmFja3NpZGVzOiBJUGFydGl0aW9uW10gPSBbXTtcblxuICBjb25zdCBzcGFjZUhlaWdodCA9IHRvdGFsSGVpZ2h0IC0gMiAqIFBMQVRFX1RISUNLTkVTUyAtIGxlZ0hlaWdodDtcblxuICBjb25zdCBwb3NZID0gKHRvdGFsSGVpZ2h0ICsgbGVnSGVpZ2h0KSAvIDI7XG5cbiAgY29uc3Qgc3RhcnRQb3NYID0gLSh0b3RhbFdpZHRoIC0gUExBVEVfVEhJQ0tORVNTKSAvIDI7XG4gIGNvbnN0IGJvdHRvbVBvc1kgPSBsZWdIZWlnaHQgKyBQTEFURV9USElDS05FU1MgLyAyO1xuXG4gIHZlcnRpY2Fscy5wdXNoKHtcbiAgICByb3c6IDAsXG4gICAgY29sOiAtMSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgeDogc3RhcnRQb3NYLFxuICAgICAgeTogcG9zWSxcbiAgICAgIHo6IDAsXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgd2lkdGg6IHNwYWNlSGVpZ2h0LFxuICAgICAgZGVwdGg6IHRvdGFsRGVwdGgsXG4gICAgfSxcbiAgfSk7XG4gIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHVtbnMubGVuZ3RoOyBjb2wrKykge1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbY29sXTtcbiAgICBjb25zdCByb3dzID0gY29sdW1uLnJvd3M7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2wgKyAxOyBpKyspIHtcbiAgICAgIHN1bSArPSBjb2x1bW5zW2ldLndpZHRoO1xuICAgIH1cbiAgICBjb25zdCBwb3NYID0gc3RhcnRQb3NYICsgc3VtICsgKGNvbCArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuICAgIGNvbnN0IHNwYWNlUG9zWCA9IHBvc1ggLSBQTEFURV9USElDS05FU1MgLyAyIC0gY29sdW1uLndpZHRoIC8gMjtcblxuICAgIHZlcnRpY2Fscy5wdXNoKHtcbiAgICAgIHJvdzogMCxcbiAgICAgIGNvbCxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHBvc1gsXG4gICAgICAgIHk6IHBvc1ksXG4gICAgICAgIHo6IDAsXG4gICAgICB9LFxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgd2lkdGg6IHNwYWNlSGVpZ2h0LFxuICAgICAgICBkZXB0aDogdG90YWxEZXB0aCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhdmFpbGFibGVTcGFjZXMucHVzaCh7XG4gICAgICByb3c6IDAsXG4gICAgICBjb2wsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBzcGFjZVBvc1gsXG4gICAgICAgIHk6IHBvc1ksXG4gICAgICAgIHo6IHRvdGFsRGVwdGggLyAyLFxuICAgICAgfSxcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGgsXG4gICAgICAgIGRlcHRoOiBzcGFjZUhlaWdodCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgIGxldCB2ZXJ0aWNhbFN1bSA9IDA7XG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHJvd0luZGV4ICsgMTsgcCsrKSB7XG4gICAgICAgIHZlcnRpY2FsU3VtICs9IHJvd3Nbcm93SW5kZXhdLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWlkZGxlUG9zWSA9IGJvdHRvbVBvc1kgKyB2ZXJ0aWNhbFN1bSArIChyb3dJbmRleCArIDEpICogUExBVEVfVEhJQ0tORVNTO1xuXG4gICAgICBjb25zdCBiYWNrUG9zWSA9IG1pZGRsZVBvc1kgLSBQTEFURV9USElDS05FU1MgLyAyIC0gcm93c1tyb3dJbmRleF0uaGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGJhY2tQb3NaID0gLSh0b3RhbERlcHRoIC0gUExBVEVfVEhJQ0tORVNTKSAvIDI7XG4gICAgICBpZiAocm93SW5kZXggPCByb3dzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaG9yaXpvbnRhbHMucHVzaCh7XG4gICAgICAgICAgcm93OiByb3dJbmRleCxcbiAgICAgICAgICBjb2wsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHNwYWNlUG9zWCxcbiAgICAgICAgICAgIHk6IG1pZGRsZVBvc1ksXG4gICAgICAgICAgICB6OiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGgsXG4gICAgICAgICAgICBkZXB0aDogdG90YWxEZXB0aCAtIEVER0VfR0FQLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBiYWNrc2lkZXMucHVzaCh7XG4gICAgICAgIHJvdzogcm93SW5kZXgsXG4gICAgICAgIGNvbCxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBzcGFjZVBvc1gsXG4gICAgICAgICAgeTogYmFja1Bvc1ksXG4gICAgICAgICAgejogYmFja1Bvc1osXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCxcbiAgICAgICAgICBkZXB0aDogcm93c1tyb3dJbmRleF0uaGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbHMsXG4gICAgYXZhaWxhYmxlU3BhY2VzLFxuICAgIGhvcml6b250YWxzLFxuICAgIGJhY2tzaWRlcyxcbiAgfTtcbn1cblxuLy8gVXBkYXRlIHRoZSB0eXBlIGRlZmluaXRpb24gdG8gaW5jbHVkZSBjb2x1bW5Db3VudFxudHlwZSBUR2V0Q2FsY3VsYXRlZENvbHVtbnNQcm9wcyA9IHtcbiAgY3VycmVudDogSUNvbHVtbltdO1xuICBjYWJpbmV0U2l6ZTogSUNhYmluZXRTaXplO1xuICBjYWJpbmV0U3R5bGU6IEVDYWJpbmV0U3R5bGU7XG4gIGxlZ0hlaWdodDogbnVtYmVyO1xuICBjb2x1bW5Db3VudD86IG51bWJlcjtcbn07XG5cbi8vIEZpeCB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlXG5leHBvcnQgY29uc3QgZ2V0Q2FsY3VsYXRlZENvbHVtbnMgPSAoe1xuICBjdXJyZW50OiBfY3VycmVudCxcbiAgY2FiaW5ldFNpemUsXG4gIGNhYmluZXRTdHlsZSxcbiAgbGVnSGVpZ2h0LFxuICBjb2x1bW5Db3VudCxcbn06IFRHZXRDYWxjdWxhdGVkQ29sdW1uc1Byb3BzKTogSUNvbHVtbltdID0+IHtcbiAgY29uc3QgeyB0b3RhbFdpZHRoLCB0b3RhbEhlaWdodCB9ID0gY2FiaW5ldFNpemU7XG4gIFxuICAvLyBDYWxjdWxhdGUgYXZhaWxhYmxlIHdpZHRoICh0b3RhbCB3aWR0aCBtaW51cyBzaWRlIHBsYXRlcylcbiAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSB0b3RhbFdpZHRoIC0gMiAqIFBMQVRFX1RISUNLTkVTUztcbiAgXG4gIC8vIERldGVybWluZSBob3cgbWFueSBjb2x1bW5zIGNhbiBmaXRcbiAgbGV0IG51bUNvbHVtbnM7XG4gIGlmIChjb2x1bW5Db3VudCkge1xuICAgIG51bUNvbHVtbnMgPSBjb2x1bW5Db3VudDtcbiAgfSBlbHNlIHtcbiAgICAvLyBDYWxjdWxhdGUgYmFzZWQgb24gbWluaW11bSBjb2x1bW4gd2lkdGhcbiAgICBudW1Db2x1bW5zID0gTWF0aC5mbG9vcihhdmFpbGFibGVXaWR0aCAvIChDRUxMX1NJWkUubWluV2lkdGggKyBQTEFURV9USElDS05FU1MpKTtcbiAgICAvLyBFbnN1cmUgYXQgbGVhc3Qgb25lIGNvbHVtblxuICAgIG51bUNvbHVtbnMgPSBNYXRoLm1heCgxLCBudW1Db2x1bW5zKTtcbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGNvbHVtbiB3aWR0aFxuICBjb25zdCBjb2x1bW5XaWR0aCA9IChhdmFpbGFibGVXaWR0aCAtIChudW1Db2x1bW5zIC0gMSkgKiBQTEFURV9USElDS05FU1MpIC8gbnVtQ29sdW1ucztcbiAgXG4gIC8vIENyZWF0ZSBjb2x1bW5zIGFycmF5XG4gIGNvbnN0IGNvbHVtbnM6IElDb2x1bW5bXSA9IFtdO1xuICBcbiAgLy8gR2VuZXJhdGUgZWFjaCBjb2x1bW5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb25cbiAgICBjb25zdCBwb3NYID0gLXRvdGFsV2lkdGggLyAyICsgUExBVEVfVEhJQ0tORVNTICsgaSAqIChjb2x1bW5XaWR0aCArIFBMQVRFX1RISUNLTkVTUykgKyBjb2x1bW5XaWR0aCAvIDI7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGNvbHVtbiB3aXRoIGFwcHJvcHJpYXRlIGxheW91dFxuICAgIGNvbnN0IGNvbHVtbiA9IGNyZWF0ZUNvbHVtbldpdGhMYXlvdXQoY29sdW1uV2lkdGgsIHBvc1gsIHRvdGFsSGVpZ2h0LCBsZWdIZWlnaHQsIGNhYmluZXRTdHlsZSk7XG4gICAgXG4gICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gIH1cbiAgXG4gIHJldHVybiBjb2x1bW5zO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbWFpbmluZ0NvbHVtbnMocmVtYWluaW5nV2lkdGg6IG51bWJlcikge1xuICBjb25zdCBiID0gcmVtYWluaW5nV2lkdGggJSAyID09PSAwID8gcmVtYWluaW5nV2lkdGggLyAyIDogKHJlbWFpbmluZ1dpZHRoICsgMSkgLyAyO1xuICBjb25zdCBjID0gcmVtYWluaW5nV2lkdGggLSBiO1xuXG4gIHJldHVybiBbYiwgY107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRpdmlkdWFsQ29sdW1uKHtcbiAgdGFyZ2V0SW5kZXgsXG4gIGNvbHVtbnMsXG4gIHRvdGFsV2lkdGgsXG4gIHRvdGFsRGVwdGgsXG4gIGxlZ0hlaWdodCxcbn06IHtcbiAgdGFyZ2V0SW5kZXg6IG51bWJlcjtcbiAgY29sdW1uczogSUNvbHVtbltdO1xuICB0b3RhbFdpZHRoOiBudW1iZXI7XG4gIHRvdGFsRGVwdGg6IG51bWJlcjtcbiAgbGVnSGVpZ2h0OiBudW1iZXI7XG59KSB7XG4gIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbdGFyZ2V0SW5kZXhdO1xuXG4gIGNvbnN0IHN0YXJ0UG9zWCA9IC0odG90YWxXaWR0aCAtIFBMQVRFX1RISUNLTkVTUykgLyAyO1xuICBjb25zdCBib3R0b21Qb3NZID0gbGVnSGVpZ2h0ICsgUExBVEVfVEhJQ0tORVNTIC8gMjtcbiAgY29uc3Qgcm93c1BvcyA9IFtdO1xuICBjb25zdCBkZWx0YSA9IDAuMDI7XG4gIGNvbnN0IHJvd3MgPSBjb2x1bW4ucm93cztcblxuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRJbmRleCArIDE7IGkrKykge1xuICAgIHN1bSArPSBjb2x1bW5zW2ldLndpZHRoO1xuICB9XG4gIGNvbnN0IHBvc1ggPSBzdGFydFBvc1ggKyBzdW0gKyAodGFyZ2V0SW5kZXggKyAxKSAqIFBMQVRFX1RISUNLTkVTUztcbiAgY29uc3Qgc3BhY2VQb3NYID0gcG9zWCAtIFBMQVRFX1RISUNLTkVTUyAvIDIgLSBjb2x1bW4ud2lkdGggLyAyO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCB2ZXJ0aWNhbFN1bSA9IDA7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCBpICsgMTsgcCsrKSB7XG4gICAgICB2ZXJ0aWNhbFN1bSArPSByb3dzW3BdLmhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgbWlkZGxlUG9zWSA9IGJvdHRvbVBvc1kgKyB2ZXJ0aWNhbFN1bSArIChpICsgMSkgKiBQTEFURV9USElDS05FU1M7XG4gICAgY29uc3QgYmFja1Bvc1kgPSBtaWRkbGVQb3NZIC0gUExBVEVfVEhJQ0tORVNTIC8gMiAtIHJvd3NbaV0uaGVpZ2h0IC8gMjtcbiAgICByb3dzUG9zLnB1c2goe1xuICAgICAgeDogc3BhY2VQb3NYIC0gY29sdW1uLndpZHRoIC8gMixcbiAgICAgIHk6IGJhY2tQb3NZLFxuICAgICAgejogdG90YWxEZXB0aCAvIDIgKyBkZWx0YSxcbiAgICAgIGhlaWdodDogcm93c1tpXS5oZWlnaHQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMyhzcGFjZVBvc1gsIGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUyArIGRlbHRhLCB0b3RhbERlcHRoIC8gMiArIGRlbHRhKSxcbiAgICByb3dzOiByb3dzUG9zLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0TGF5b3V0SW1hZ2VzID0gKHsgdG90YWxIZWlnaHQgfTogeyB0b3RhbEhlaWdodDogbnVtYmVyIH0pID0+IHtcbiAgbGV0IGltZ3NBcnJheSA9IFtdO1xuICBpZiAodG90YWxIZWlnaHQgPCAwLjUzKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDUzSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMC42Mykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQ2M0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDAuNzMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0NzNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAwLjkzKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDkzSWNvbnNdO1xuICB9IGVsc2UgaWYgKHRvdGFsSGVpZ2h0IDwgMS4wMykge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQxMDNJY29uc107XG4gIH0gZWxzZSBpZiAodG90YWxIZWlnaHQgPCAxLjIzKSB7XG4gICAgaW1nc0FycmF5ID0gWy4uLmxheW91dDEyM0ljb25zXTtcbiAgfSBlbHNlIGlmICh0b3RhbEhlaWdodCA8IDEuMzMpIHtcbiAgICBpbWdzQXJyYXkgPSBbLi4ubGF5b3V0MTMzSWNvbnNdO1xuICB9IGVsc2Uge1xuICAgIGltZ3NBcnJheSA9IFsuLi5sYXlvdXQxNDNJY29uc107XG4gIH1cblxuICByZXR1cm4gaW1nc0FycmF5O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldElkID0gKGl0ZW06IHN0cmluZykgPT4gYCR7aXRlbX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDMyKS5zbGljZSgtNCl9YDtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbHVtbldpdGhMYXlvdXQgPSAoY29sdW1uV2lkdGg6IG51bWJlciwgcG9zWDogbnVtYmVyLCB0b3RhbEhlaWdodDogbnVtYmVyLCBsZWdIZWlnaHQ6IG51bWJlciwgY2FiaW5ldFN0eWxlOiBFQ2FiaW5ldFN0eWxlKTogSUNvbHVtbiA9PiB7XG4gIC8vIENhbGN1bGF0ZSB0aGUgY2FiaW5ldCBoZWlnaHQgKGV4Y2x1ZGluZyBsZWdzIGFuZCBwbGF0ZSB0aGlja25lc3MpXG4gIGNvbnN0IGNhYmluZXRIZWlnaHQgPSB0b3RhbEhlaWdodCAtIGxlZ0hlaWdodCAtIDIgKiBQTEFURV9USElDS05FU1M7XG4gIFxuICAvLyBHZXQgdGhlIGJhc2ljIHZlcnRpY2FsIGxheW91dCBmb3IgdGhlIGNvbHVtblxuICBjb25zdCByb3dzID0gZ2V0Q29sdW1uVmVydGljYWxMYXlvdXQoeyBjYWJpbmV0SGVpZ2h0IH0pO1xuICBcbiAgLy8gR2V0IHRoZSBzdGFydGluZyBwb3NpdGlvbiBZIGNvb3JkaW5hdGVcbiAgY29uc3Qgc3RhcnRQb3NZID0gbGVnSGVpZ2h0ICsgUExBVEVfVEhJQ0tORVNTO1xuICBcbiAgLy8gRGVmYXVsdCB0byBhbiBlbXB0eSBsYXlvdXQgKHdpbGwgYmUgcG9wdWxhdGVkIGJhc2VkIG9uIHN0eWxlKVxuICBsZXQgbGF5b3V0SW5kZXggPSAwO1xuICBsZXQgZG9vcnM6IGFueVtdID0gW107XG4gIGxldCBkcmF3ZXJzOiBhbnlbXSA9IFtdO1xuICBcbiAgLy8gQmFzZWQgb24gY2FiaW5ldCBzdHlsZSwgY2hvb3NlIGFuIGFwcHJvcHJpYXRlIGxheW91dFxuICBzd2l0Y2ggKGNhYmluZXRTdHlsZSkge1xuICAgIGNhc2UgRUNhYmluZXRTdHlsZS5NT0RFUk46XG4gICAgICAvLyBGb3IgbW9kZXJuIHN0eWxlLCB1c2UgYWxsIGRyYXdlcnNcbiAgICAgIGxheW91dEluZGV4ID0gMTtcbiAgICAgIC8vIENyZWF0ZSBhIGRyYXdlciBmb3IgZWFjaCByb3dcbiAgICAgIGRyYXdlcnMgPSByb3dzLm1hcCgocm93LCBpbmRleCkgPT4gKHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiByb3cuaGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgICBwb3M6IHtcbiAgICAgICAgICB4OiBwb3NYLFxuICAgICAgICAgIHk6IHN0YXJ0UG9zWSArIChpbmRleCArIDAuNSkgKiByb3cuaGVpZ2h0ICsgaW5kZXggKiBQTEFURV9USElDS05FU1MsXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgICBicmVhaztcbiAgICAgIFxuICAgIGNhc2UgRUNhYmluZXRTdHlsZS5DTEFTU0lDOlxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3IgY2xhc3NpYyBzdHlsZSwgdXNlIGRvb3JzIGZvciBhbGwgcm93c1xuICAgICAgbGF5b3V0SW5kZXggPSAwO1xuICAgICAgLy8gQ3JlYXRlIGEgZG9vciBmb3IgdGhlIGZ1bGwgaGVpZ2h0XG4gICAgICBkb29ycyA9IFt7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2FiaW5ldEhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zOiB7XG4gICAgICAgICAgeDogcG9zWCxcbiAgICAgICAgICB5OiBzdGFydFBvc1kgKyBjYWJpbmV0SGVpZ2h0IC8gMixcbiAgICAgICAgfSxcbiAgICAgICAgb3BlbmluZzogMSwgLy8gRGVmYXVsdCBvcGVuaW5nIGRpcmVjdGlvblxuICAgICAgfV07XG4gICAgICBicmVhaztcbiAgfVxuICBcbiAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gdGhlIGNvbHVtbiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpLFxuICAgIGluZGV4OiAwLFxuICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICBwb3NYOiBwb3NYLFxuICAgIHJvd3M6IHJvd3MsXG4gICAgZG9vcnM6IGRvb3JzLFxuICAgIGRyYXdlcnM6IGRyYXdlcnMsXG4gICAgZGl2aWRlcnM6IFtdLFxuICAgIGxheW91dEluZGV4OiBsYXlvdXRJbmRleCxcbiAgICBpc0RpdmlkZTogZmFsc2UsXG4gICAgbGFzdFJvdzogZHJhd2Vycy5sZW5ndGggPiAwID8gJ2RyYXdlcicgOiAnZG9vcicsXG4gIH07XG59O1xuXG4vLyBVcGRhdGUgdGhlIGNhYmluZXQgc2l6ZSBjb25zdHJhaW50c1xuZXhwb3J0IGNvbnN0IENBQklORVRfU0laRV9DT05TVFJBSU5UUyA9IHtcbiAgbWluV2lkdGg6IDAuNCwgLy8gNDBjbSBpbiBtZXRlcnNcbiAgbWF4V2lkdGg6IDIuNSwgLy8gMjUwY20gaW4gbWV0ZXJzIChjaGFuZ2VkIGZyb20gNC41bS80NTBjbSlcbiAgbWluSGVpZ2h0OiAwLjQsIC8vIDQwY20gaW4gbWV0ZXJzXG4gIG1heEhlaWdodDogMi40LCAvLyAyNDBjbSBpbiBtZXRlcnNcbiAgbWluRGVwdGg6IDAuMywgLy8gMzBjbSBpbiBtZXRlcnNcbiAgbWF4RGVwdGg6IDAuOCwgLy8gODBjbSBpbiBtZXRlcnNcbn07XG5cbmV4cG9ydCBjb25zdCBhcHBseVJhbmRvbUxheW91dHNUb0NvbHVtbnMgPSAoY29sdW1uczogSUNvbHVtbltdLCB0b3RhbEhlaWdodDogbnVtYmVyLCBsZWdIZWlnaHQ6IG51bWJlcik6IElDb2x1bW5bXSA9PiB7XG4gIGNvbnN0IHN0YXJ0UG9zWSA9IGxlZ0hlaWdodCArIFBMQVRFX1RISUNLTkVTUztcbiAgXG4gIHJldHVybiBjb2x1bW5zLm1hcChjb2x1bW4gPT4ge1xuICAgIC8vIEdldCBhbGwgYXZhaWxhYmxlIGxheW91dCBvcHRpb25zIGZvciB0aGlzIGNvbHVtblxuICAgIGNvbnN0IGxheW91dE9wdGlvbnMgPSBnZXRMYXlvdXRPcHRpb25zT2ZDb2x1bW4oeyBcbiAgICAgIHRvdGFsSGVpZ2h0LCBcbiAgICAgIGxlZ0hlaWdodCwgXG4gICAgICBjb2x1bW5XaWR0aDogY29sdW1uLndpZHRoLCBcbiAgICAgIHBvc1g6IGNvbHVtbi5wb3NYLCBcbiAgICAgIHN0YXJ0UG9zWSxcbiAgICAgIGRvb3JEaXI6IDEgLy8gRGVmYXVsdCBkb29yIG9wZW5pbmcgZGlyZWN0aW9uXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2VsZWN0IGEgcmFuZG9tIGxheW91dCBvcHRpb25cbiAgICBjb25zdCByYW5kb21MYXlvdXRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxheW91dE9wdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCByYW5kb21MYXlvdXQgPSBsYXlvdXRPcHRpb25zW3JhbmRvbUxheW91dEluZGV4XTtcbiAgICBcbiAgICAvLyBBcHBseSB0aGUgcmFuZG9tIGxheW91dCB0byB0aGUgY29sdW1uXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbHVtbixcbiAgICAgIGxheW91dEluZGV4OiByYW5kb21MYXlvdXRJbmRleCxcbiAgICAgIHJvd3M6IHJhbmRvbUxheW91dC5yb3dzLFxuICAgICAgZG9vcnM6IHJhbmRvbUxheW91dC5kb29ycyxcbiAgICAgIGRyYXdlcnM6IHJhbmRvbUxheW91dC5kcmF3ZXJzLFxuICAgICAgbGFzdFJvdzogcmFuZG9tTGF5b3V0Lmxhc3RSb3dcbiAgICB9O1xuICB9KTtcbn07XG4iXSwibmFtZXMiOlsiVEhSRUUiLCJnZXRMYXlvdXRPcHRpb25zT2ZDb2x1bW4iLCJQTEFURV9USElDS05FU1MiLCJDRUxMX1NJWkUiLCJtYXhXaWR0aCIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwibWluSGVpZ2h0IiwiTEVHX0hFSUdIVCIsIkxFR19XSURUSCIsIkxFR19ERVBUSCIsIkVER0VfR0FQIiwid2FsbENvbG9yIiwiZmxvb3JDb2xvciIsImFtYmllbnRMaWdodENvbG9yIiwiZGlyZWN0aW9uYWxMaWdodENvbG9yIiwidGV4dHVyZXNSb290UGF0aCIsImVudmlyb25tZW50UGF0aCIsInBseXdvb2RSb290UGF0aCIsInBseXdvb2RBb01hcFBhdGgiLCJwbHl3b29kTm9ybWFsTWFwUGF0aCIsInBseXdvb2RSb3VnaG5lc3NNYXBQYXRoIiwicGx5d29vZFRleHR1cmVzIiwiYW9NYXAiLCJub3JtYWxNYXAiLCJyb3VnaG5lc3NNYXAiLCJ3b29kUm9vdFBhdGgiLCJ2ZW5lZXJBb01hcFBhdGgiLCJ2ZW5lZXJOb3JtYWxNYXBQYXRoIiwidmVuZWVyUm91Z2huZXNzTWFwUGF0aCIsInZlbmVlclRleHR1cmVzIiwiRVZlbmVlclRleHR1cmVzIiwiRVBseXdvb2RUZXh0dXJlcyIsImhvcml6b250YWxPY2NsdXNpb25UZXh0dXJlUGF0aCIsInZlcnRpY2FsT2NjbHVzaW9uVGV4dHVyZVBhdGgiLCJiYWNrT2NjbHVzaW9uVGV4dHVyZVBhdGgiLCJFT2NjbHVzaW9uSW1hZ2VzIiwibGF5b3V0SWNvblJvb3RQYXRoIiwiaWNvbmlmeUljb25zIiwibGF5b3V0SWNvbnMiLCJ1bmRvSWNvbiIsImRpbWVuc2lvbnNJY29uIiwiZG9vcnNJY29uIiwiYWxpZ25Db2x1bW5zSWNvbiIsInNob3dEZWNvcmF0aW9uc0ljb24iLCJhc3NlbWJseUljb24iLCJtZW51SWNvbnMiLCJhcnJvd1VwIiwiYXJyb3dEb3duIiwiaW5mb1F1ZXN0aW9uIiwic2NlbmVJY29ucyIsImVkaXRMYXlvdXQiLCJtZW51SWNvblBhdGhzIiwibGVncyIsIm5vX2xlZyIsImZsb2F0aW5nIiwiaGFuZGxlcyIsImhhbmRsZV9hIiwiaGFuZGxlX2IiLCJwdXNoIiwic3R5bGVzIiwiZnJhbWUiLCJncmFkaWVudCIsImdyaWQiLCJtb3NhaWMiLCJwaXhlbCIsInNsYW50IiwiZ2VuZXJhdGVMYXlvdXRJY29ucyIsImxheW91dEhlaWdodCIsImljb25Db3VudCIsImxheW91dFJvb3RQYXRoIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJsYXlvdXQ1M0ljb25zIiwibGF5b3V0NjNJY29ucyIsImxheW91dDczSWNvbnMiLCJsYXlvdXQ5M0ljb25zIiwibGF5b3V0MTAzSWNvbnMiLCJsYXlvdXQxMjNJY29ucyIsImxheW91dDEzM0ljb25zIiwibGF5b3V0MTQzSWNvbnMiLCJtb2RlbHNSb290UGF0aCIsInNoYWRvd01hbk1vZGVsUGF0aCIsImhhbmRsZUFNb2RlbFBhdGgiLCJoYW5kbGVCTW9kZWxQYXRoIiwibGVnc01vZGVsUGF0aCIsIm5vTGVnc01vZGVsUGF0aCIsInR2TW9kZWxQYXRoIiwiRUNhYmluZXRTdHlsZSIsIkVDYWJpbmV0TGVncyIsIkVDYWJpbmV0SGFuZGxlcyIsIkVDYWJpbmV0RmluaXNoZXMiLCJnZXRXaWR0aEFycmF5Iiwic3R5bGUiLCJ0b3RhbFdpZHRoIiwid2lkdGhBcnJheSIsInVuaXQiLCJnZXRSZW1haW5pbmdDb2x1bW5zIiwiZ2V0Q29sdW1uVmVydGljYWxMYXlvdXQiLCJjYWJpbmV0SGVpZ2h0IiwiY3VycmVudGxheW91dCIsIm51bWJlck9mUm93cyIsImdldFJvd0NvdW50IiwiaW5kZXgiLCJoZWlnaHQiLCJnZXRDZWxsSGVpZ2h0IiwiZ2V0RGlzdGFuY2UiLCJwMSIsInAyIiwiTWF0aCIsInNxcnQiLCJ4IiwieiIsImZsb29yIiwiZ2V0Q29sdW1uQ291bnQiLCJudW1iZXJPZkNvbHVtbnMiLCJzdW0iLCJ3aWR0aE9mQ2VsbCIsInJvdW5kIiwicm93Q291bnQiLCJjZWxsSGVpZ2h0IiwiZ2V0Q2VsbFdpZHRoIiwiY29sdW1uQ291bnQiLCJjZWxsV2lkdGgiLCJnZXRCb3R0b21IZWlnaHQiLCJnZXRQYXJ0aXRvblBsYXRlcyIsImNvbHVtbnMiLCJ0b3RhbEhlaWdodCIsInRvdGFsRGVwdGgiLCJsZWdIZWlnaHQiLCJ2ZXJ0aWNhbHMiLCJob3Jpem9udGFscyIsImF2YWlsYWJsZVNwYWNlcyIsImJhY2tzaWRlcyIsInNwYWNlSGVpZ2h0IiwicG9zWSIsInN0YXJ0UG9zWCIsImJvdHRvbVBvc1kiLCJyb3ciLCJjb2wiLCJwb3NpdGlvbiIsInkiLCJzY2FsZSIsIndpZHRoIiwiZGVwdGgiLCJjb2x1bW4iLCJyb3dzIiwicG9zWCIsInNwYWNlUG9zWCIsInJvd0luZGV4IiwidmVydGljYWxTdW0iLCJwIiwibWlkZGxlUG9zWSIsImJhY2tQb3NZIiwiYmFja1Bvc1oiLCJnZXRDYWxjdWxhdGVkQ29sdW1ucyIsImN1cnJlbnQiLCJfY3VycmVudCIsImNhYmluZXRTaXplIiwiY2FiaW5ldFN0eWxlIiwiYXZhaWxhYmxlV2lkdGgiLCJudW1Db2x1bW5zIiwibWF4IiwiY29sdW1uV2lkdGgiLCJjcmVhdGVDb2x1bW5XaXRoTGF5b3V0IiwicmVtYWluaW5nV2lkdGgiLCJiIiwiYyIsImdldEluZGl2aWR1YWxDb2x1bW4iLCJ0YXJnZXRJbmRleCIsInJvd3NQb3MiLCJkZWx0YSIsIlZlY3RvcjMiLCJnZXRMYXlvdXRJbWFnZXMiLCJpbWdzQXJyYXkiLCJnZXRJZCIsIml0ZW0iLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwic3RhcnRQb3NZIiwibGF5b3V0SW5kZXgiLCJkb29ycyIsImRyYXdlcnMiLCJtYXAiLCJzaXplIiwicG9zIiwib3BlbmluZyIsImlkIiwic3Vic3RyIiwiZGl2aWRlcnMiLCJpc0RpdmlkZSIsImxhc3RSb3ciLCJDQUJJTkVUX1NJWkVfQ09OU1RSQUlOVFMiLCJtaW5EZXB0aCIsIm1heERlcHRoIiwiYXBwbHlSYW5kb21MYXlvdXRzVG9Db2x1bW5zIiwibGF5b3V0T3B0aW9ucyIsImRvb3JEaXIiLCJyYW5kb21MYXlvdXRJbmRleCIsInJhbmRvbUxheW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/utilities.ts\n"));

/***/ })

});